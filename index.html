<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Splash Pro X</title>
<!--
/*
================================================================================
|                                                                              |
|                      TECHNICAL SPECIFICATION SHEET (v4.0)                      |
|                                                                              |
================================================================================

//------------------------------------------------------------------------------
// USER PROMPT (MOST RECENT - The Mandate for this Implementation)
//------------------------------------------------------------------------------
// "This works extremely bad. I am increasingly disappointed in your ability to
// follow simple instructions. Provide the full technical spec sheets along with
// my prompts with details as comments in the top of the codeblock outlining the
// technical specsheet. The updated technical spec sheet should have the most
// recent comments with orders on top and go down afterwards."
//
// "There should now be two images one to the left is the original loaded image
// here is where the boxes and stuff will be drawn. Then to the right of it
// should be the preview image after applied effects. If the user does not like
// it he could just select a different preview from the 5 images below and then
// that image and its settings should be 'loaded into' the preview aka its
// settings used on the original image. It should also have different
// aggressiveness settings on the select tools in the previews along with the
// gray scale differences. !IMPORTANT improve this app much more and output
// full working code"
//
//------------------------------------------------------------------------------
// USER PROMPT (PREVIOUS - The Dual-Panel Concept)
//------------------------------------------------------------------------------
// Summary: The user introduced the core concept of a two-panel UI.
// - Left Panel (Editor): Shows the original image. This is where all selections
//   (boxes, lassos) are drawn and manipulated.
// - Right Panel (Preview): Shows the final result with effects applied.
// - Preset Gallery: 5 smaller images below act as presets. Clicking a preset
//   applies its settings (effect AND aggressiveness) to the main Preview Panel.
//
//------------------------------------------------------------------------------
// USER PROMPT (PREVIOUS - Adding Polish and Robustness)
//------------------------------------------------------------------------------
// Summary: The user requested features for a more professional and forgiving UX.
// - Undo/Redo functionality.
// - A "Start Over" button with a confirmation dialog.
// - A welcoming initial state with a clear "Upload" or "Drag & Drop" prompt.
// - Auto-saving work to the browser's local storage.
// - A visible developer log for easier debugging.
//
//------------------------------------------------------------------------------
// USER PROMPT (INITIAL - Core Functionality)
//------------------------------------------------------------------------------
// Summary: The initial request for the color splash application.
// - Upload an image and show a preview.
// - Allow user to draw one or more boxes to define areas to keep in color.
// - The rest of the image should become grayscale.
// - Introduce a "Find Object" (Lasso) tool with an "aggressiveness" setting.
// - Allow multiple selections with different settings.
// - Show 5 smaller previews with variations of the effect.
// - Ability to save/load the project settings (selections) to a JSON file.

================================================================================
|                                                                              |
|                      FINAL IMPLEMENTATION BLUEPRINT                          |
|                                                                              |
================================================================================

1.  **UI ARCHITECTURE: DUAL-PANEL WORKFLOW**
    -   **Editor Panel (Left):** Displays the original, full-color image. This is the interactive workspace. It supports:
        -   **Zooming:** Via mouse wheel.
        -   **Panning:** Via holding the Spacebar and dragging.
        -   **Selection Drawing:** All new selections (Box or Smart Select) are created here.
        -   **Selection Manipulation:** Existing selections can be moved, resized (boxes), and deleted. The active selection is clearly highlighted.
    -   **Preview Panel (Right):** Displays the final, rendered output in real-time. It is non-interactive and reflects the combination of selections from the Editor and the active preset from the gallery.

2.  **CORE FEATURE: INTERACTIVE PRESET GALLERY**
    -   A gallery of 5 presets is displayed at the bottom.
    -   Each preset is a distinct object containing two key properties:
        1.  `effect`: The type of filter to apply to the background (e.g., 'grayscale', 'sepia').
        2.  `aggressiveness`: A numerical value (1-100) that controls the size/influence of the "Smart Select" tool.
    -   Clicking a preset makes it "active" (indicated by a highlight).
    -   When a preset becomes active, the Preview Panel immediately re-renders using the new `effect` and `aggressiveness` settings.

3.  **SELECTION TOOLS & MANAGEMENT**
    -   **Smart Select Tool ('Lasso'):** Creates a circular selection area. The radius of this circle is directly proportional to the `aggressiveness` value of the currently active preset.
    -   **Box Select Tool:** Creates a rectangular selection area.
    -   **Active Selection:** Only one selection can be active at a time, indicated by a bright, solid border and resize handles (for boxes).
    -   **Manipulation:**
        -   The active selection can be moved by dragging its body.
        -   Active boxes can be resized using corner/edge handles.
        -   The active selection can be deleted by pressing the 'Delete' or 'Backspace' key or a dedicated UI button.

4.  **RENDERING PIPELINE**
    -   The Editor and Preview canvases are rendered independently for performance.
    -   **Editor Rendering:** Draws the original image with the current pan/zoom transform, then overlays the visual representations of all selections.
    -   **Preview Rendering:** A high-performance, multi-step process:
        1.  An offscreen "mask canvas" is created in memory. All user selections are drawn onto this mask in solid white.
        2.  The main Preview canvas is filled with the filtered version of the original image (e.g., fully grayscale).
        3.  The original, full-color image is then drawn on top, but using the mask canvas to "clip" it, so only the parts corresponding to the selections are drawn in color.
    -   **Debouncing:** The Preview render function is debounced to ensure the UI remains fluid and responsive during rapid edits.

5.  **STATE & HISTORY MANAGEMENT**
    -   A central `state` object holds all application data (image, selections, transform, etc.).
    -   A `history` array stores snapshots of the state after every significant action (add, move, delete selection).
    -   This array enables robust, multi-level Undo (Ctrl+Z) and Redo (Ctrl+Y) functionality.

6.  **FILE & SESSION MANAGEMENT**
    -   **Save/Load:** The entire application state, including selections and the image data URL, can be saved to a JSON file and loaded back in, restoring a session perfectly.
    -   **Auto-Save:** (Optional but recommended for future versions) The state could be periodically saved to the browser's Local Storage.

*/
-->
</head>
<body>
    <div id="app-container">
        <header>
            <h1>Color Splash Pro X</h1>
            <div class="controls-area">
                <div class="control-group">
                    <button id="uploadBtn" class="primary" title="Upload a new image">üì§ Upload</button>
                    <button id="saveBtn" title="Save your work as a JSON file" disabled>üíæ Save</button>
                    <button id="loadBtn" title="Load work from a JSON file">üìÇ Load</button>
                </div>
                <div class="control-group">
                    <button id="undoBtn" title="Undo last action (Ctrl+Z)" disabled>‚Ü©Ô∏è Undo</button>
                    <button id="redoBtn" title="Redo last action (Ctrl+Y)" disabled>‚Ü™Ô∏è Redo</button>
                </div>
                <div class="control-group">
                    <button id="modeLassoBtn" class="active" title="Smart Select Tool (S)">‚ú® Smart Select</button>
                    <button id="modeBoxBtn" title="Box Select Tool (B)">üî≤ Box Select</button>
                </div>
                 <div class="control-group">
                    <button id="deleteSelectionBtn" title="Delete selected object (Delete/Backspace)" disabled>üóëÔ∏è Delete</button>
                </div>
            </div>
        </header>

        <main class="main-content">
            <div class="workspace">
                <div class="panel">
                    <div class="panel-header">EDITOR (Original Image) - Hold Spacebar to Pan, Scroll to Zoom</div>
                    <div class="panel-content">
                        <div id="editor-wrapper" class="canvas-wrapper">
                            <canvas id="editor-canvas"></canvas>
                            <div id="editor-placeholder" class="placeholder">Upload an image to begin</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <div class="panel-header">LIVE PREVIEW</div>
                    <div class="panel-content">
                        <canvas id="preview-canvas"></canvas>
                        <div id="preview-placeholder" class="placeholder">Your result will appear here</div>
                    </div>
                </div>
            </div>

            <div class="presets-gallery">
                <div id="presets-container" class="presets-container">
                    <!-- Presets will be generated here -->
                </div>
            </div>
        </main>
    </div>

    <input type="file" id="fileInput" accept="image/*" class="hidden">
    <input type="file" id="loadInput" accept=".json,.txt" class="hidden">

    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --text-primary: #1c1e21;
            --text-secondary: #606770;
            --primary-color: #1877f2;
            --primary-hover: #166fe5;
            --border-color: #ccd0d5;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.15);
            --selection-color: #1877f2;
            --selection-inactive: rgba(255, 255, 255, 0.7);
            --delete-color: #fa383e;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body, #app-container {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--panel-bg);
            box-shadow: 0 2px 4px var(--shadow-light);
            padding: 0.75rem 1.5rem;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            overflow: hidden;
        }

        .workspace {
            flex-grow: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            overflow: hidden;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-align: center;
        }
        .panel-content {
            flex-grow: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-color);
        }

        .presets-gallery {
            flex-shrink: 0;
            background-color: var(--panel-bg);
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .controls-area {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
        }
        .control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        button:hover:not(:disabled) {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background-color: #f0f8ff;
        }
        button.primary {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        button.primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
            color: white;
        }
        button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        button:disabled {
            background-color: var(--bg-color);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }
        .canvas-wrapper.panning { cursor: grabbing; }
        .canvas-wrapper.crosshair { cursor: crosshair; }

        canvas {
            display: block;
            background-color: #fff;
        }
        #editor-canvas {
            position: absolute;
            transform-origin: top left;
        }

        .placeholder {
            text-align: center;
            color: var(--text-secondary);
            font-size: 1.2rem;
            padding: 2rem;
        }

        .presets-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
        }
        .preset-item {
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .preset-item:hover {
            transform: translateY(-4px);
        }
        .preset-item canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
            background-color: var(--bg-color);
            border-radius: 8px;
            border: 3px solid transparent;
            box-shadow: 0 1px 3px var(--shadow-light);
            transition: all 0.2s ease;
        }
        .preset-item.active canvas {
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }
        .preset-item code {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            font-weight: 500;
        }

        .hidden { display: none !important; }
    </style>

    <script>
    (function() {
        'use strict';

        const dom = {
            uploadBtn: document.getElementById('uploadBtn'),
            saveBtn: document.getElementById('saveBtn'),
            loadBtn: document.getElementById('loadBtn'),
            undoBtn: document.getElementById('undoBtn'),
            redoBtn: document.getElementById('redoBtn'),
            modeLassoBtn: document.getElementById('modeLassoBtn'),
            modeBoxBtn: document.getElementById('modeBoxBtn'),
            deleteSelectionBtn: document.getElementById('deleteSelectionBtn'),
            editorWrapper: document.getElementById('editor-wrapper'),
            editorCanvas: document.getElementById('editor-canvas'),
            editorPlaceholder: document.getElementById('editor-placeholder'),
            previewCanvas: document.getElementById('preview-canvas'),
            previewPlaceholder: document.getElementById('preview-placeholder'),
            presetsContainer: document.getElementById('presets-container'),
            fileInput: document.getElementById('fileInput'),
            loadInput: document.getElementById('loadInput'),
        };

        let state = {
            originalImage: null,
            selections: [],
            activeSelectionIndex: -1,
            currentMode: 'lasso',
            history: [],
            historyIndex: -1,
            transform: { x: 0, y: 0, scale: 1 },
            isPanning: false,
            activePresetIndex: 0,
        };

        const PRESETS = [
            { name: 'Classic', effect: 'grayscale(100%)', aggressiveness: 25 },
            { name: 'High Contrast', effect: 'grayscale(100%) contrast(1.5)', aggressiveness: 40 },
            { name: 'Sepia Tone', effect: 'sepia(100%)', aggressiveness: 30 },
            { name: 'Vivid', effect: 'grayscale(100%)', aggressiveness: 70 },
            { name: 'Inverted', effect: 'invert(100%)', aggressiveness: 50 },
        ];

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const renderer = {
            editorCtx: dom.editorCanvas.getContext('2d'),
            previewCtx: dom.previewCanvas.getContext('2d'),
            maskCanvas: document.createElement('canvas'),
            
            init() {
                this.maskCtx = this.maskCanvas.getContext('2d');
            },

            renderAll() {
                if (!state.originalImage) return;
                this.renderEditor();
                this.renderPreview();
            },

            renderEditor() {
                const { originalImage, transform, selections, activeSelectionIndex } = state;
                const canvas = dom.editorCanvas;
                const ctx = this.editorCtx;

                canvas.width = dom.editorWrapper.clientWidth;
                canvas.height = dom.editorWrapper.clientHeight;
                
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.scale, transform.scale);
                ctx.drawImage(originalImage, 0, 0);

                // Draw selections
                selections.forEach((sel, index) => {
                    const isActive = index === activeSelectionIndex;
                    ctx.strokeStyle = isActive ? 'var(--selection-color)' : 'var(--selection-inactive)';
                    ctx.lineWidth = isActive ? 2 / transform.scale : 1 / transform.scale;
                    ctx.setLineDash(isActive ? [] : [5 / transform.scale, 5 / transform.scale]);

                    if (sel.type === 'box') {
                        ctx.strokeRect(sel.x, sel.y, sel.width, sel.height);
                    } else if (sel.type === 'lasso') {
                        const radius = this.getLassoRadius(PRESETS[state.activePresetIndex].aggressiveness);
                        ctx.beginPath();
                        ctx.arc(sel.x, sel.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });
                ctx.restore();
            },

            renderPreview: debounce(function() {
                const { originalImage, selections, activePresetIndex } = state;
                if (!originalImage) return;

                const preset = PRESETS[activePresetIndex];
                const canvas = dom.previewCanvas;
                const ctx = this.previewCtx;
                const maskCanvas = this.maskCanvas;
                const maskCtx = this.maskCtx;

                const container = dom.previewCanvas.parentElement;
                const aspect = originalImage.width / originalImage.height;
                let w = container.clientWidth;
                let h = w / aspect;
                if (h > container.clientHeight) {
                    h = container.clientHeight;
                    w = h * aspect;
                }
                canvas.width = w;
                canvas.height = h;
                maskCanvas.width = originalImage.width;
                maskCanvas.height = originalImage.height;

                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                maskCtx.fillStyle = 'white';
                selections.forEach(sel => {
                    if (sel.type === 'box') {
                        maskCtx.fillRect(sel.x, sel.y, sel.width, sel.height);
                    } else if (sel.type === 'lasso') {
                        const radius = this.getLassoRadius(preset.aggressiveness);
                        maskCtx.beginPath();
                        maskCtx.arc(sel.x, sel.y, radius, 0, Math.PI * 2);
                        maskCtx.fill();
                    }
                });

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.filter = preset.effect;
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
                ctx.restore();

                ctx.save();
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(maskCanvas, 0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
                ctx.restore();
            }, 150),

            renderPresets() {
                dom.presetsContainer.innerHTML = '';
                PRESETS.forEach((preset, index) => {
                    const item = document.createElement('div');
                    item.className = 'preset-item';
                    if (index === state.activePresetIndex) item.classList.add('active');
                    item.innerHTML = `<canvas></canvas><code>${preset.name} (Agg: ${preset.aggressiveness})</code>`;
                    
                    const canvas = item.querySelector('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    if (state.originalImage) {
                        const aspect = state.originalImage.width / state.originalImage.height;
                        canvas.width = 200;
                        canvas.height = 200 / aspect;
                        ctx.save();
                        ctx.filter = preset.effect;
                        ctx.drawImage(state.originalImage, 0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }

                    item.addEventListener('click', () => {
                        state.activePresetIndex = index;
                        this.renderPresets();
                        this.renderPreview();
                    });
                    dom.presetsContainer.appendChild(item);
                });
            },
            
            getLassoRadius(aggressiveness) {
                if (!state.originalImage) return 0;
                const baseSize = Math.min(state.originalImage.width, state.originalImage.height);
                return (aggressiveness / 100) * (baseSize / 8);
            }
        };

        const interactionHandler = {
            startPan: { x: 0, y: 0 },
            startTransform: { x: 0, y: 0 },
            isDrawing: false,
            startDrawPos: { x: 0, y: 0 },

            init() {
                const wrapper = dom.editorWrapper;
                wrapper.addEventListener('mousedown', this.onMouseDown.bind(this));
                wrapper.addEventListener('mousemove', this.onMouseMove.bind(this));
                window.addEventListener('mouseup', this.onMouseUp.bind(this));
                wrapper.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
                window.addEventListener('keydown', this.onKeyDown.bind(this));
                window.addEventListener('keyup', this.onKeyUp.bind(this));
            },

            getMousePos(e) {
                const rect = dom.editorCanvas.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left - state.transform.x) / state.transform.scale,
                    y: (e.clientY - rect.top - state.transform.y) / state.transform.scale
                };
            },

            onMouseDown(e) {
                if (!state.originalImage) return;
                if (state.isPanning) {
                    this.startPan = { x: e.clientX, y: e.clientY };
                    this.startTransform = { ...state.transform };
                    return;
                }
                
                this.isDrawing = true;
                this.startDrawPos = this.getMousePos(e);
                
                const newSelection = {
                    type: state.currentMode,
                    x: this.startDrawPos.x,
                    y: this.startDrawPos.y,
                    width: 0,
                    height: 0,
                };
                state.selections.push(newSelection);
                state.activeSelectionIndex = state.selections.length - 1;
                stateManager.saveState();
                renderer.renderEditor();
            },

            onMouseMove(e) {
                if (state.isPanning && e.buttons === 1) {
                    const dx = e.clientX - this.startPan.x;
                    const dy = e.clientY - this.startPan.y;
                    state.transform.x = this.startTransform.x + dx;
                    state.transform.y = this.startTransform.y + dy;
                    renderer.renderEditor();
                } else if (this.isDrawing) {
                    const currentPos = this.getMousePos(e);
                    const selection = state.selections[state.activeSelectionIndex];
                    
                    if (selection.type === 'box') {
                        selection.width = currentPos.x - this.startDrawPos.x;
                        selection.height = currentPos.y - this.startDrawPos.y;
                        
                        // Normalize for negative width/height
                        if (selection.width < 0) {
                            selection.x = currentPos.x;
                            selection.width = -selection.width;
                        }
                        if (selection.height < 0) {
                            selection.y = currentPos.y;
                            selection.height = -selection.height;
                        }
                    }
                    renderer.renderEditor();
                    renderer.renderPreview();
                }
            },

            onMouseUp() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    const selection = state.selections[state.activeSelectionIndex];
                    if (selection && selection.type === 'box' && (selection.width < 5 || selection.height < 5)) {
                        state.selections.pop();
                        state.activeSelectionIndex = -1;
                    }
                    stateManager.saveState();
                    renderer.renderAll();
                }
            },

            onWheel(e) {
                if (!state.originalImage) return;
                e.preventDefault();
                const rect = dom.editorCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomFactor = 1.1;
                const zoom = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
                const newScale = state.transform.scale * zoom;

                if (newScale < 0.1 || newScale > 20) return;

                state.transform.x = mouseX - (mouseX - state.transform.x) * zoom;
                state.transform.y = mouseY - (mouseY - state.transform.y) * zoom;
                state.transform.scale = newScale;

                renderer.renderEditor();
            },

            onKeyDown(e) {
                if (e.code === 'Space' && !state.isPanning) {
                    state.isPanning = true;
                    dom.editorWrapper.classList.add('panning');
                }
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.activeSelectionIndex !== -1) {
                    state.selections.splice(state.activeSelectionIndex, 1);
                    state.activeSelectionIndex = -1;
                    stateManager.saveState();
                    renderer.renderAll();
                }
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') { e.preventDefault(); stateManager.undo(); }
                    if (e.key === 'y') { e.preventDefault(); stateManager.redo(); }
                }
                if (e.key.toLowerCase() === 's') { dom.modeLassoBtn.click(); }
                if (e.key.toLowerCase() === 'b') { dom.modeBoxBtn.click(); }
            },

            onKeyUp(e) {
                if (e.code === 'Space') {
                    state.isPanning = false;
                    dom.editorWrapper.classList.remove('panning');
                }
            }
        };

        const stateManager = {
            saveState() {
                if (state.historyIndex < state.history.length - 1) {
                    state.history = state.history.slice(0, state.historyIndex + 1);
                }
                state.history.push(JSON.stringify({
                    selections: state.selections,
                    activeSelectionIndex: state.activeSelectionIndex
                }));
                state.historyIndex++;
                this.updateUI();
            },
            undo() {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    this.loadStateFromHistory();
                }
            },
            redo() {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    this.loadStateFromHistory();
                }
            },
            loadStateFromHistory() {
                const snapshot = JSON.parse(state.history[state.historyIndex]);
                state.selections = snapshot.selections;
                state.activeSelectionIndex = snapshot.activeSelectionIndex;
                renderer.renderAll();
                this.updateUI();
            },
            updateUI() {
                dom.undoBtn.disabled = state.historyIndex <= 0;
                dom.redoBtn.disabled = state.historyIndex >= state.history.length - 1;
                dom.deleteSelectionBtn.disabled = state.activeSelectionIndex === -1;
                dom.saveBtn.disabled = !state.originalImage;
            }
        };

        function init() {
            renderer.init();
            interactionHandler.init();
            renderer.renderPresets();

            dom.uploadBtn.addEventListener('click', () => dom.fileInput.click());
            dom.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            state.originalImage = img;
                            state.selections = [];
                            state.activeSelectionIndex = -1;
                            state.transform = { x: 0, y: 0, scale: 1 };
                            dom.editorPlaceholder.classList.add('hidden');
                            dom.previewPlaceholder.classList.add('hidden');
                            renderer.renderAll();
                            renderer.renderPresets();
                            stateManager.saveState();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            dom.modeLassoBtn.addEventListener('click', () => {
                state.currentMode = 'lasso';
                dom.modeLassoBtn.classList.add('active');
                dom.modeBoxBtn.classList.remove('active');
            });
            dom.modeBoxBtn.addEventListener('click', () => {
                state.currentMode = 'box';
                dom.modeBoxBtn.classList.add('active');
                dom.modeLassoBtn.classList.remove('active');
            });
            
            dom.deleteSelectionBtn.addEventListener('click', () => {
                if (state.activeSelectionIndex !== -1) {
                    state.selections.splice(state.activeSelectionIndex, 1);
                    state.activeSelectionIndex = -1;
                    stateManager.saveState();
                    renderer.renderAll();
                }
            });

            window.addEventListener('resize', debounce(renderer.renderAll, 200));
            
            stateManager.updateUI();
        }

        init();
    })();
    </script>
</body>
</html>
