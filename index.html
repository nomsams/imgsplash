<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Color Splash Pro X ‚Äî AI Mode</title>

<!--
================================================================================
TECHNICAL SPEC SHEET (v1.19.0 ‚ÄúAI Mode solid + Variants + Pinned Settings‚Äù)

This preserves everything and ADDS/FIXES:

- AI MODE (solid)
  ‚Ä¢ AI Active switch in the header AI bar.
  ‚Ä¢ Segmentation models: YOLOv8n-seg, YOLO11n-seg, MobileSAM (point), CLIPSeg (prompt).
  ‚Ä¢ Depth models: MobileDepth (tiny), MiDaS-small, Depth-Anything-V2-Small.
  ‚Ä¢ Optional prompt input (shown for promptable models like CLIPSeg).
  ‚Ä¢ ‚ÄúUse‚Äù button or clicking the ORIGINAL runs the pipeline:
      1) Segment near click (or prompt), 2) estimate depth, 3) (optional) refine with fancy math.
  ‚Ä¢ Model downloads only when triggered (Use/click). We still support background preloading if you enable the small "Preload" switch.
  ‚Ä¢ Progress bar + logs show download and inference stages.
  ‚Ä¢ AI mask + depth thumbnails appear in the RIGHT sidebar (the old Settings/Logs moved).
  ‚Ä¢ 5 AI VARIANTS (mini-previews) generated and clickable to select.

- PINNED SETTINGS/LOGS PANEL (bottom-left gear)
  ‚Ä¢ Holds Feather/Tolerance/Filter controls + full scrollable logs.
  ‚Ä¢ The old header ‚ÄúToggle Logs‚Äù now opens this panel.

- DUAL MONOCLES
  ‚Ä¢ Left monocle shows ORIGINAL; Right monocle shows actual PREVIEW pixels.
  ‚Ä¢ Monocles hop to the opposite side when cursor gets close, then snap back.

- FAILSAFES
  ‚Ä¢ WebGPU ‚Üí WASM fallback, timeouts, robust shape guards, CORS failure handling.
  ‚Ä¢ If models fail, fallback to Worker EdgeGrow + synthetic luminance-based depth.

App version bump: APP_VERSION = "1.19.0"
================================================================================
-->

  <style>
    :root{
      --bg:#edf1f7;--panel:#fff;--text:#1c1e21;--muted:#606770;--primary:#1877f2;--primary-2:#166fe5;
      --border:#d7dbe1;--shadow:rgba(0,0,0,.08);--shadow-2:rgba(0,0,0,.14);
      --danger:#fa383e;--ok:#19a974;--warn:#ffb700;
      --chip:#f4f7ff;
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;overflow:hidden;
    }
    header{
      background:var(--panel);box-shadow:0 2px 6px var(--shadow);padding:.55rem .8rem;display:flex;align-items:center;gap:.5rem;z-index:4;position:relative;
    }
    .brand{font-weight:800;color:var(--primary);letter-spacing:.2px}
    .badge{margin-left:auto;font-size:.8rem;color:#4a4f57;background:#eef3ff;border:1px solid #dfe7ff;padding:.2rem .5rem;border-radius:6px}
    .toolbar{display:flex;flex-wrap:wrap;gap:.4rem;align-items:center}
    .group{display:flex;gap:.4rem;align-items:center}
    button{
      padding:.42rem .7rem;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:default;
      font-weight:600;font-size:.9rem;display:inline-flex;gap:.42rem;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,.02);
      transition:transform .05s ease, border-color .2s, background .2s, color .2s;
    }
    button:hover:not(:disabled){border-color:var(--primary);background:#f6faff}
    button:active{transform:translateY(1px)}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    button.primary:hover{background:var(--primary-2);color:#fff}
    button.active{background:var(--primary);border-color:var(--primary);color:#fff}
    button.danger{border-color:#ffd2d6;background:#fff0f1;color:#b00020}
    button:disabled{opacity:.6;cursor:not-allowed}
    .icon{font-size:1.05rem}

    .chip{padding:.28rem .5rem;border:1px solid var(--border);border-radius:999px;background:var(--chip);font-size:.82rem;color:#334155}
    .switch{display:inline-flex;gap:.4rem;align-items:center;padding:.2rem .5rem;border:1px solid var(--border);border-radius:8px;background:#fff}

    /* Layout */
    .shell{flex:1;display:flex;flex-direction:column;gap:10px;padding:10px;overflow:hidden;}
    .row{display:grid;grid-template-columns:8fr 7fr;gap:10px;flex:1 1 auto;min-height:0;}
    .panel{background:var(--panel);border-radius:12px;box-shadow:0 2px 8px var(--shadow);display:flex;flex-direction:column;min-height:0;overflow:hidden;position:relative;}
    .panel-h{padding:.5rem .75rem;border-bottom:1px solid var(--border);font-weight:700;color:var(--muted);display:flex;align-items:center;justify-content:center;gap:.5rem}
    .panel-c{flex:1;min-height:0;position:relative;background:#e9eef6;display:flex;align-items:center;justify-content:center;overflow:hidden}

    .placeholder{color:var(--muted);font-weight:600;opacity:.85;pointer-events:none}
    .canvas-wrap{position:relative;width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;cursor:default;}
    .canvas-wrap.panning{cursor:grabbing}
    .canvas-wrap.drop-hover{outline:3px dashed var(--primary); outline-offset:-8px; background:rgba(24,119,242,0.1)}
    canvas{display:block;background:#fff}
    #editor-canvas{position:absolute;transform-origin:top left}
    #preview-canvas{position:absolute;top:0;left:0}

    /* Dual Monocles */
    .monocle{
      position:absolute;width:148px;height:148px;background:#fff;border:2px solid var(--border);
      border-radius:10px;box-shadow:0 6px 14px var(--shadow-2);overflow:hidden;display:none;z-index:3;
    }
    .monocle canvas{width:100%;height:100%;display:block;background:#000}
    #monocle-left{ top:10px; left:10px; }
    #monocle-right{ top:10px; right:10px; }

    /* Bottom strip */
    .bottom{display:grid;grid-template-columns:8fr 3fr;gap:10px;min-height:92px;max-height:26vh;}
    .presets.panel{min-height:92px}
    .presets-grid{display:grid;grid-template-columns:repeat(10,1fr);gap:8px;padding:10px;align-items:end;justify-items:center}
    .preset{cursor:pointer;text-align:center;width:100%;max-width:84px;margin:0 auto}
    .preset canvas{width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;box-shadow:0 1px 3px var(--shadow);transition:all .15s}
    .preset:hover canvas{transform:translateY(-2px)}
    .preset.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .preset label{display:block;margin-top:4px;font-size:.72rem;color:var(--muted);text-align:center}

    /* RIGHT sidebar now shows AI thumbnails + variants (Settings/Logs moved to pin panel) */
    .side.panel{min-height:92px}
    .side-c{display:flex;flex-direction:column;min-height:0;}
    .ai-thumbs{padding:8px 10px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:flex-start;overflow-x:auto}
    .ai-thumb{display:flex;flex-direction:column;align-items:center;gap:4px}
    .ai-thumb canvas{width:152px;height:auto;max-height:96px;background:#f6f8ff;border-radius:10px;border:1px solid var(--border);image-rendering:pixelated}
    .ai-thumb .cap{font-size:.75rem;color:#475569}

    .variants{flex:1;display:flex;flex-direction:column;min-height:0;}
    .variants-h{padding:6px 10px;border-bottom:1px solid var(--border);font-weight:700;color:#64748b}
    .variants-grid{flex:1;padding:10px;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;overflow:auto}
    .variant{cursor:pointer;text-align:center}
    .variant canvas{width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;box-shadow:0 1px 3px var(--shadow);image-rendering:pixelated}
    .variant.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .variant label{display:block;margin-top:4px;font-size:.72rem;color:#64748b}

    /* Progress bar */
    .progress-wrap{position:absolute;left:12px;right:12px;bottom:12px;height:8px;border-radius:6px;background:#eef2ff;border:1px solid #dde6ff;overflow:hidden; opacity:0; transition: opacity 0.2s; pointer-events:none;}
    .progress-wrap.visible{opacity:1;}
    .progress{height:100%;width:0%;background:linear-gradient(90deg,#7aa2ff,#1877f2);transition:width .1s}

    .version-pin{position:fixed;top:8px;right:8px;background:#101828;color:#fff;font-size:.75rem;padding:.25rem .5rem;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.18);z-index:10;opacity:.9}

    /* AI BAR (header bottom) */
    .ai-bar{position:absolute;left:0;right:0;bottom:-56px;background:#fff;border-top:1px solid var(--border);display:none;gap:.6rem;align-items:center;padding:.45rem .8rem;z-index:3;flex-wrap:wrap}
    .ai-bar.visible{display:flex}
    .ai-bar select,.ai-bar input[type=text]{padding:.32rem .5rem;border:1px solid var(--border);border-radius:8px;background:#fff;font-weight:600}
    .ai-bar .spacer{flex:1}

    /* Pinned FAB + Panel (Settings + Logs) */
    #pinFab{position:fixed;left:12px;bottom:12px;z-index:8;border-radius:999px;padding:.6rem .75rem;background:#1877f2;color:#fff;border:none;box-shadow:0 6px 14px rgba(0,0,0,.18);cursor:pointer;font-weight:800}
    #pinPanel{position:fixed;left:12px;bottom:64px;width:384px;height:60vh;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 12px 32px rgba(0,0,0,.18);display:none;flex-direction:column;overflow:hidden;z-index:9}
    #pinPanel.visible{display:flex}
    #pinPanel header{box-shadow:none;padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #pinPanel .body{flex:1;display:grid;grid-template-rows:auto 1fr;}
    #pinPanel .cfg{padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #pinPanel .cfg .row{display:flex;gap:.5rem;align-items:center;margin:.25rem 0}
    #pinPanel .ilog{overflow:auto;background:#fff}
    #pinPanel .ilog .line{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.84rem;color:#1f2937;padding:.25rem .5rem;border-bottom:1px dashed #eef2ff;white-space:pre-wrap}

    .range-row{display:flex;align-items:center;gap:10px}
    .range-row input[type=range]{flex:1}

    .hidden{display:none!important}
  </style>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <header>
    <div class="brand">Color Splash Pro X</div>

    <div class="toolbar">
      <div class="group">
        <button id="uploadBtn" class="primary"><span class="icon">üì§</span>Upload</button>
        <button id="saveBtn" title="Save project JSON" disabled>üíæ Save</button>
        <button id="loadBtn" title="Load project JSON">üìÇ Load</button>
        <button id="startOverBtn" class="danger" title="Clear image & selections" disabled>üßπ Start Over</button>
      </div>
      <div class="group">
        <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>‚Ü©Ô∏è Undo</button>
        <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>‚Ü™Ô∏è Redo</button>
      </div>
      <div class="group">
        <button id="modeLassoBtn" class="active" title="Smart Select (Lasso) (S)">‚ú® Lasso</button>
        <button id="newLassoBtn" title="Add new lasso object">‚ûï New Lasso</button>
        <button id="modeBoxBtn" title="Box Select (B)">üî≤ Box</button>
        <button id="deleteSelectionBtn" title="Delete active selection (Del)" disabled>üóëÔ∏è Delete</button>
      </div>
      <div class="group">
        <button id="autoWandBtn" title="Auto Wand (W)">ü™Ñ Auto Wand</button>
        <button id="autoSmartBtn" title="Auto Smart (G)">üß† Auto Smart</button>
        <button id="autoUltraBtn" title="Auto Ultra (U)">üß¨ Auto Ultra</button>
        <button id="autoObjectsBtn" title="Auto Objects (demo)">üõ∞Ô∏è Auto Objects</button>
      </div>
      <div class="group">
        <button id="protectEraserBtn" title="Paint protected areas (E)">üõ°Ô∏è Protect Eraser</button>
        <button id="removeEraserBtn" title="Erase colorized mask (R)">üßΩ Remove Eraser</button>
      </div>
      <div class="group">
        <button id="resetViewBtn" title="Reset pan/zoom & fit">üéØ Reset View</button>
        <button id="renderNowBtn" title="Render immediately">‚ö° Render Now</button>
        <button id="downloadBtn" title="Download final image (PNG)">‚¨áÔ∏è Download</button>
      </div>

      <!-- AI Mode -->
      <div class="group">
        <button id="aiModeBtn" title="Toggle AI Mode">ü§ñ AI Mode</button>
      </div>
      <div class="group">
        <button id="toggleLogsBtn" title="Open Settings & Logs (Pinned)">üõ†Ô∏è Settings</button>
      </div>
    </div>

    <span class="badge" id="versionBadge">v?</span>

    <!-- AI controls bar under header -->
    <div id="aiBar" class="ai-bar">
      <span class="chip">AI Controls</span>

      <span class="switch"><input id="aiActiveSwitch" type="checkbox"/><label for="aiActiveSwitch">AI Active</label></span>

      <label>Segmentation:</label>
      <select id="aiSegModel">
        <option value="yolov8n-seg">YOLOv8n-seg (~13MB)</option>
        <option value="yolo11n-seg">YOLO11n-seg (~6MB)</option>
        <option value="mobile-sam">MobileSAM (point)</option>
        <option value="clipseg">CLIPSeg (prompt)</option>
      </select>

      <label>Depth:</label>
      <select id="aiDepthModel">
        <option value="mobiledepth">MobileDepth (tiny)</option>
        <option value="midas-small">MiDaS-small</option>
        <option value="da-v2-small">Depth Anything V2 Small</option>
      </select>

      <input id="aiPrompt" type="text" class="hidden" placeholder="Prompt (for CLIPSeg)‚Ä¶" />

      <span class="switch"><input id="aiRefine" type="checkbox"/><label for="aiRefine">Refine w/ Fancy Math</label></span>
      <span class="switch"><input id="aiPreload" type="checkbox" checked/><label for="aiPreload">Preload</label></span>

      <button id="aiUseBtn" class="primary">üöÄ Use</button>
      <div class="spacer"></div>
      <span id="aiStatus" class="chip">idle</span>
    </div>
  </header>

  <div class="version-pin" id="versionPin">v?</div>

  <div class="shell">
    <div class="row">
      <!-- EDITOR -->
      <section class="panel" id="editor-panel">
        <div class="panel-h">EDITOR ‚Äî Original (Space = Pan ¬∑ Wheel = Zoom)</div>
        <div class="panel-c">
          <div id="editor-wrap" class="canvas-wrap">
            <canvas id="editor-canvas"></canvas>
            <div id="monocle-left" class="monocle"><canvas id="monocle-left-canvas"></canvas></div>
          </div>
          <div id="editor-empty" class="placeholder">Drop an image here or click ‚ÄúUpload‚Äù</div>
          <div class="progress-wrap" id="progressEditor"><div class="progress" id="progressBar"></div></div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel" id="preview-panel">
        <div class="panel-h">LIVE PREVIEW</div>
        <div class="panel-c" id="preview-container">
          <div id="preview-wrap" class="canvas-wrap">
            <canvas id="preview-canvas"></canvas>
            <div id="monocle-right" class="monocle"><canvas id="monocle-right-canvas"></canvas></div>
          </div>
          <div id="preview-empty" class="placeholder">Your result will appear here</div>
        </div>
      </section>
    </div>

    <div class="bottom">
      <!-- PRESETS -->
      <section class="presets panel">
        <div class="panel-h">PRESET GALLERY (click to apply)</div>
        <div id="presets" class="presets-grid"></div>
      </section>

      <!-- RIGHT side: AI thumbnails + variants -->
      <section class="side panel">
        <div class="side-c">
          <div class="ai-thumbs">
            <div class="ai-thumb">
              <canvas id="aiMaskThumb" width="152" height="96"></canvas>
              <div class="cap">AI Object Mask</div>
            </div>
            <div class="ai-thumb">
              <canvas id="aiDepthThumb" width="152" height="96"></canvas>
              <div class="cap">Depth Map</div>
            </div>
          </div>
          <div class="variants">
            <div class="variants-h">AI Variants (click to select)</div>
            <div id="aiVariants" class="variants-grid">
              <!-- 5 variant cells inserted dynamically -->
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Pinned panel (gear) for Settings + Logs -->
  <button id="pinFab" title="Settings & Logs">‚öôÔ∏è</button>
  <div id="pinPanel">
    <header><strong>‚öôÔ∏è Settings & Logs</strong></header>
    <div class="body">
      <div class="cfg">
        <div class="row"><span class="chip">Runtime</span><span id="runtimeChip" class="chip">‚Äî</span></div>
        <div class="row range-row">
          <label for="aggrRange" style="width:110px">Feather</label>
          <input type="range" id="aggrRange" min="0" max="100" value="35"/><span id="aggrVal">35</span>
        </div>
        <div class="row range-row">
          <label for="tolRange" style="width:110px">Tolerance</label>
          <input type="range" id="tolRange" min="0" max="100" value="25"/><span id="tolVal">25</span>
        </div>
        <div class="row range-row">
          <label for="fltRange" style="width:110px">Filter Strength</label>
          <input type="range" id="fltRange" min="0" max="100" value="100"/><span id="fltVal">100%</span>
        </div>
        <div class="row">
          <button id="clearLogsBtn">Clear Logs</button>
        </div>
        <div class="row"><small style="color:#64748b">Tip: In AI Mode, click the Original to set the seed. ‚ÄúUse‚Äù runs the current models.</small></div>
      </div>
      <div id="aiLogBody" class="ilog"></div>
    </div>
  </div>

  <!-- hidden inputs -->
  <input type="file" id="fileInput" accept="image/*" class="hidden"/>
  <input type="file" id="loadInput" accept=".json,.txt" class="hidden"/>

  <!-- Segmentation Worker (unchanged core, our reliable fallback/refiner) -->
  <script id="seg-worker-src" type="text/plain">
/* seg-worker.js ‚Äî minimal, fast, deterministic */
self.postMessage({type:'ready'});
self.onmessage = (e)=>{
  const {type, payload, reqId} = e.data || {};
  if(type!=='segment') return;
  try{
    const {tool, seedX, seedY, tol01, aggr, width, height, image} = payload;
    const data = image.data;
    const N = width*height;
    const gray = new Float32Array(N);
    for(let i=0,j=0;i<N;i++,j+=4){ gray[i]=0.2126*data[j]+0.7152*data[j+1]+0.0722*data[j+2]; }
    const grad = sobelMag(gray,width,height);
    const gradN = normalize01(grad);
    let alpha;
    const params = defaultsEdgeGrow(tol01,aggr);
    alpha = edgeAwareGrowMask(data,width,height,seedX,seedY,gradN,params);
    if(tool==='autoUltra'){
      paintDisk(alpha,width,height,seedX,seedY,Math.max(6,Math.round(Math.min(width,height)*0.01)),255);
    }
    returnMask(alpha,width,height,{tool:(tool==='autoUltra'?'grabcutLite':'edgeGrow'),seedX,seedY,params},reqId);
  }catch(err){
    self.postMessage({type:'error',reqId,payload:String(err)});
  }
};
function normalize01(arr){let mn=Infinity,mx=-Infinity;for(const v of arr){if(v<mn)mn=v;if(v>mx)mx=v;}const o=new Float32Array(arr.length);const d=mx-mn||1;for(let i=0;i<arr.length;i++)o[i]=(arr[i]-mn)/d;return o;}
function sobelMag(g,W,H){const o=new Float32Array(W*H);for(let y=1;y<H-1;y++){for(let x=1;x<W-1;x++){const i=y*W+x;const tl=(y-1)*W+(x-1),t=(y-1)*W+x,tr=(y-1)*W+(x+1);const ml=y*W+(x-1),mr=y*W+(x+1);const bl=(y+1)*W+(x-1),b=(y+1)*W+x,br=(y+1)*W+(x+1);const gx=-g[tl]-2*g[ml]-g[bl]+g[tr]+2*g[mr]+g[br];const gy=-g[tl]-2*g[t]-g[tr]+g[bl]+2*g[b]+g[br];o[i]=Math.hypot(gx,gy);} }return o;}
function defaultsEdgeGrow(tol01,aggr){return{wc:1.0,we:2.0+1.2*tol01,wd:0.02,tau:18+160*tol01+aggr*0.6,diag:true};}
function edgeAwareGrowMask(rgbU8,W,H,sx,sy,grad01,p){
  const idx=(x,y)=>y*W+x;const N=W*H;
  const cost=new Float32Array(N);cost.fill(1e20);
  const seen=new Uint8Array(N);
  const hc=new Float32Array(N),hi=new Int32Array(N);let hs=0;
  function push(c,i){let k=hs++;hc[k]=c;hi[k]=i;while(k){const pk=(k-1)>>1;if(hc[pk]<=c)break;swap(k,pk);k=pk;}}
  function pop(){if(!hs)return[-1,-1];const c=hc[0],i=hi[0];const ck=hc[--hs],ik=hi[hs];if(hs){hc[0]=ck;hi[0]=ik;down(0);}return[c,i];}
  function swap(a,b){const tc=hc[a];hc[a]=hc[b];hc[b]=tc;const ti=hi[a];hi[a]=hi[b];hi[b]=ti;}
  function down(k){for(;;){let l=k*2+1,r=l+1,s=k;if(l<hs&&hc[l]<hc[s])s=l;if(r<hs&&hc[r]<hc[s])s=r;if(s===k)break;swap(k,s);k=s;}}
  const R=new Float32Array(N),G=new Float32Array(N),B=new Float32Array(N);
  for(let i=0,j=0;i<N;i++,j+=4){R[i]=rgbU8[j];G[i]=rgbU8[j+1];B[i]=rgbU8[j+2];}
  const seed=idx(Math.max(0,Math.min(W-1,sx)),Math.max(0,Math.min(H-1,sy)));cost[seed]=0;push(0,seed);
  const del=p.diag?[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]:[[1,0],[-1,0],[0,1],[0,-1]];
  while(hs){const [c,i]=pop();if(i<0)break;if(seen[i])continue;seen[i]=1;if(c>p.tau)break;const x=i%W,y=(i-x)/W;
    for(const d of del){const nx=x+d[0],ny=y+d[1];if(nx<0||ny<0||nx>=W||ny>=H)continue;const j=idx(nx,ny);if(seen[j])continue;
      const dR=R[i]-R[j],dG=G[i]-G[j],dB=B[i]-B[j];const dE=Math.hypot(dR,dG,dB);
      const eStop=1.0-(grad01[j]/(grad01[j]+1e-6));const step=1.0*dE+(2.0+1.2)*eStop+0.02*((d[0]&&d[1])?Math.SQRT2:1.0);
      const nc=c+step;if(nc<cost[j]&&nc<=p.tau){cost[j]=nc;push(nc,j);}}}
  const a=new Uint8ClampedArray(N);const t0=0.92*p.tau,t1=p.tau;for(let i=0;i<N;i++){const ci=cost[i];if(ci>=1e18){a[i]=0;continue;}
    if(ci<=t0){a[i]=255;} else if(ci>=t1){a[i]=0;} else {const v=1-(ci-t0)/(t1-t0);a[i]=Math.round(255*v);} }
  return a;
}
function paintDisk(alpha,W,H,cx,cy,r,v){
  const r2=r*r;for(let y=Math.max(0,cy-r);y<Math.min(H,cy+r+1);y++){for(let x=Math.max(0,cx-r);x<Math.min(W,cx+r+1);x++){const dx=x-cx,dy=y-cy;if(dx*dx+dy*dy<=r2){alpha[y*W+x]=v;}}}
}
function returnMask(alphaU8,width,height,generator,reqId){
  self.postMessage({type:'mask',reqId,payload:{width,height,alphaU8,generator}},[alphaU8.buffer]);
}
  </script>

  <script>
  (function(){
    'use strict';

    const APP_VERSION = "1.19.0";
    const $ = (id)=>document.getElementById(id);
    $('versionBadge').textContent = APP_VERSION;
    $('versionPin').textContent = APP_VERSION;

    /* DOM refs */
    const dom = {
      // Top bar
      uploadBtn: $('uploadBtn'), saveBtn: $('saveBtn'), loadBtn: $('loadBtn'), startOverBtn: $('startOverBtn'),
      undoBtn: $('undoBtn'), redoBtn: $('redoBtn'),
      modeLassoBtn: $('modeLassoBtn'), newLassoBtn: $('newLassoBtn'), modeBoxBtn: $('modeBoxBtn'),
      deleteSelectionBtn: $('deleteSelectionBtn'), renderNowBtn: $('renderNowBtn'),
      autoWandBtn: $('autoWandBtn'), autoSmartBtn: $('autoSmartBtn'), autoUltraBtn: $('autoUltraBtn'), autoObjectsBtn: $('autoObjectsBtn'),
      protectEraserBtn: $('protectEraserBtn'), removeEraserBtn: $('removeEraserBtn'),
      resetViewBtn: $('resetViewBtn'), downloadBtn: $('downloadBtn'),
      aiModeBtn: $('aiModeBtn'), toggleLogsBtn: $('toggleLogsBtn'),

      // AI bar
      aiBar: $('aiBar'), aiActiveSwitch: $('aiActiveSwitch'),
      aiSegModel: $('aiSegModel'), aiDepthModel: $('aiDepthModel'), aiPrompt: $('aiPrompt'),
      aiRefine: $('aiRefine'), aiPreload: $('aiPreload'), aiUseBtn: $('aiUseBtn'), aiStatus: $('aiStatus'),

      // Editor / Preview
      fileInput: $('fileInput'), loadInput: $('loadInput'),
      editorPanel: $('editor-panel'), editorWrap: $('editor-wrap'), editorCanvas: $('editor-canvas'), editorEmpty: $('editor-empty'),
      previewPanel: $('preview-panel'), previewWrap: $('preview-wrap'), previewContainer: $('preview-container'), previewCanvas: $('preview-canvas'), previewEmpty: $('preview-empty'),

      // Monocles
      monoLeft: $('monocle-left'), monoLeftCanvas: $('monocle-left-canvas'),
      monoRight: $('monocle-right'), monoRightCanvas: $('monocle-right-canvas'),

      // Right sidebar AI thumbnails + variants
      aiMaskThumb: $('aiMaskThumb'), aiDepthThumb: $('aiDepthThumb'), aiVariants: $('aiVariants'),

      // Presets
      presets: $('presets'),

      // Progress
      progressWrap: $('progressEditor'), progressBar: $('progressBar'),

      // Pinned panel
      pinFab: $('pinFab'), pinPanel: $('pinPanel'), aiLogBody: $('aiLogBody'), runtimeChip: $('runtimeChip'),
      aggrRange: $('aggrRange'), aggrVal: $('aggrVal'),
      tolRange: $('tolRange'), tolVal: $('tolVal'),
      fltRange: $('fltRange'), fltVal: $('fltVal'),
      clearLogsBtn: $('clearLogsBtn'),
    };

    /* Logging (scrollable, mirrored in pinned panel only) */
    const log = (...args)=>{
      const text = `[${new Date().toLocaleTimeString()}] ` + args.join(' ');
      const l = document.createElement('div'); l.className='line'; l.textContent=text;
      dom.aiLogBody.appendChild(l);
      dom.aiLogBody.scrollTop = dom.aiLogBody.scrollHeight;
      console.log('[LOG]', ...args);
    };

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const debounce=(fn,ms)=>{let t;return (...x)=>{clearTimeout(t);t=setTimeout(()=>fn(...x),ms);}};

    /* STATE */
    const state = {
      image: null,
      selections: [],
      activeIndex: -1,
      mode: 'lasso',
      modeGroup: 'manual',
      transform: {x:0,y:0,scale:1},
      isPanning:false,
      drag:{active:false,startX:0,startY:0,kind:null,handle:null,moved:false,snapshot:null},
      history:[], histIndex:-1,
      activePreset:0,
      filters:[
        {name:'Classic',   css:(s)=>`grayscale(${s}%)`,                                                aggr:20},
        {name:'High Pop',  css:(s)=>`grayscale(${s}%) contrast(1.35) brightness(1.05)`,                aggr:30},
        {name:'Soft Film', css:(s)=>`grayscale(${s}%) brightness(1.03) contrast(1.08) saturate(.9)`,   aggr:35},
        {name:'Crunchy',   css:(s)=>`grayscale(${s}%) contrast(1.55)`,                                 aggr:45},
        {name:'Dreamy',    css:(s)=>`grayscale(${s}%) blur(0.6px) brightness(1.06)`,                   aggr:60},
        {name:'Neutral',   css:(s)=>`grayscale(${s}%) brightness(1.02)`,                               aggr:25}
      ],
      aggr:35, tol:25, filtStrength:100,
      brush:{size:28, hard:0.9},
      rendering:false,
      thumbnailsReady:false,

      ai:{
        active:false,
        segModel:'yolov8n-seg',
        depthModel:'mobiledepth',
        refine:false,
        preload:true,
        prompt:'',
        lastClick:null, // {x,y} in image coords
        sessions:{},    // key -> ort.InferenceSession
        outputs:{
          baseMask:null,     // canvas
          depthCanvas:null,  // canvas
          depthMap:null,     // Float32Array
          finalMask:null,    // canvas (selected variant)
          variants:[],       // [{canvas,label}], 5 items
        }
      }
    };

    /* Model registry (swap URLs to your mirrors if needed) */
    const MODEL_URLS = {
      // Segmentation
      'yolov8n-seg': {
        url:'https://huggingface.co/onnx-community/ultralytics-yolov8/resolve/main/yolov8n-seg.onnx',
        type:'seg-yolo', inputSize:640, sizeHintMB:13.2
      },
      'yolo11n-seg': {
        url:'https://huggingface.co/keremberke/yolo11n-seg-onnx/resolve/main/model.onnx',
        type:'seg-yolo', inputSize:640, sizeHintMB:6.0
      },
      'mobile-sam': {
        url:'https://huggingface.co/ziqiangxu/MobileSAM-onnx/resolve/main/mobile_sam.onnx',
        type:'seg-sam', inputSize:512, sizeHintMB:50.3
      },
      'clipseg': {
        url:'https://huggingface.co/CiaraRowles/clipseg-rd64-refined/resolve/main/clipseg-rd64-refined.onnx',
        type:'seg-clipseg', inputSize:352, sizeHintMB:52.0
      },
      // Depth
      'mobiledepth': {
        url:'https://huggingface.co/apple/ml-depth-pro/resolve/main/mobiledepth_tiny.onnx',
        type:'depth', inputSize:256, sizeHintMB:1.4
      },
      'midas-small': {
        url:'https://huggingface.co/onnx-community/MiDaS/resolve/main/midas_small.onnx',
        type:'depth', inputSize:256, sizeHintMB:63.0
      },
      'da-v2-small': {
        url:'https://huggingface.co/depth-anything/Depth-Anything-V2-Small/resolve/main/depth_anything_v2_small.onnx',
        type:'depth', inputSize:518, sizeHintMB:99.0
      }
    };

    /* Progress bar */
    let progressTimer=null, progressTarget=78;
    function startProgress(){
      dom.progressWrap.classList.add('visible');
      let p=0; dom.progressBar.style.width='0%';
      clearInterval(progressTimer);
      progressTimer=setInterval(()=>{p=clamp(p+12,0,progressTarget);dom.progressBar.style.width=p+'%';},60);
    }
    function finishProgress(){
      clearInterval(progressTimer); progressTimer=null;
      dom.progressBar.style.width='100%';
      setTimeout(()=>{dom.progressWrap.classList.remove('visible'); dom.progressBar.style.width='0%';},280);
    }

    /* Worker (built-in) */
    let segWorker=null, segReady=false;
    function initSegWorker(){
      if(segWorker) return;
      try{
        const src=$('seg-worker-src').textContent;
        const blob=new Blob([src],{type:'application/javascript'});
        const url=URL.createObjectURL(blob);
        segWorker=new Worker(url);
        segWorker.onmessage=(e)=>{
          const {type,payload}=e.data||{};
          if(type==='ready'){ segReady=true; log('Seg worker ready.'); return; }
          if(type==='error'){ log('Worker error:', payload); finishProgress(); return; }
          if(type==='mask'){
            const cnv=document.createElement('canvas');
            cnv.width=payload.width; cnv.height=payload.height;
            const ctx=cnv.getContext('2d');
            const id=ctx.createImageData(payload.width,payload.height);
            for(let i=0,j=0;i<id.data.length;i+=4,j++){
              id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=payload.alphaU8[j];
            }
            ctx.putImageData(id,0,0);
            state.selections.push({type:'mask', maskCanvas:cnv, generator:{...payload.generator,origin:'worker'}});
            state.activeIndex=state.selections.length-1;
            editor.draw(); schedulePreviewRender(true); history.save(); finishProgress();
            log('Mask (worker) added:', payload.generator?.tool||'');
          }
        };
      }catch(err){ log('Worker init failed:', String(err)); }
    }

    function requestSegMask(tool, sx, sy, tol, aggr){
      return new Promise((resolve)=>{
        const W=state.image.width, H=state.image.height;
        const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H;
        const tx=tmp.getContext('2d'); tx.drawImage(state.image,0,0);
        const imgData=tx.getImageData(0,0,W,H);
        const reqId=Math.random().toString(36).slice(2);
        segWorker.postMessage({type:'segment',reqId,payload:{tool,seedX:sx,seedY:sy,tol01:clamp(tol/100,0,1),aggr,width:W,height:H,image:imgData}},[imgData.data.buffer]);
        resolve();
      });
    }

    /* Editor */
    const editor={
      c:dom.editorCanvas, ctx:dom.editorCanvas.getContext('2d'),
      updateSize(){ const w=dom.editorWrap.clientWidth,h=dom.editorWrap.clientHeight; this.c.width=w; this.c.height=h; },
      imgToCanvasSpace(clientX,clientY){
        const r=this.c.getBoundingClientRect();
        const x=(clientX - r.left - state.transform.x)/state.transform.scale;
        const y=(clientY - r.top  - state.transform.y)/state.transform.scale;
        return {x,y};
      },
      draw(){
        if(!state.image){ this.ctx.clearRect(0,0,this.c.width,this.c.height); return; }
        const {ctx,c}=this; ctx.clearRect(0,0,c.width,c.height);
        ctx.save(); ctx.translate(state.transform.x,state.transform.y); ctx.scale(state.transform.scale,state.transform.scale);
        ctx.drawImage(state.image,0,0);

        state.selections.forEach((sel,i)=>{
          const active=i===state.activeIndex;
          ctx.save();
          ctx.lineWidth=active?2.5/state.transform.scale:1.5/state.transform.scale;
          ctx.strokeStyle=active?'#1877f2':'rgba(0,0,0,.45)';
          ctx.fillStyle=active?'rgba(24,119,242,.08)':'rgba(255,255,255,.18)';
          ctx.setLineDash(active?[]:[6/state.transform.scale,4/state.transform.scale]);
          if(sel.type==='box'){
            ctx.strokeRect(sel.x,sel.y,sel.w,sel.h); ctx.fillRect(sel.x,sel.y,sel.w,sel.h); if(active) drawBoxHandles(ctx,sel);
          }else if(sel.type==='lasso'){
            ctx.beginPath(); sel.points.forEach((p,idx)=> idx?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.closePath(); ctx.stroke(); ctx.fill();
          }else if((sel.type==='mask'||sel.type==='protect')&&sel.maskCanvas){
            ctx.globalAlpha=active?0.25:0.15; ctx.drawImage(sel.maskCanvas,0,0); ctx.globalAlpha=1;
            const edge=edgeFromMask(sel.maskCanvas,1); if(edge){ ctx.save(); ctx.strokeStyle=sel.type==='protect'?'#b00020':(active?'#1877f2':'rgba(0,0,0,.45)'); ctx.lineWidth=active?2.0/state.transform.scale:1.2/state.transform.scale; ctx.drawImage(edge,0,0); ctx.restore(); }
          }
          ctx.restore();
        });
        ctx.restore();
      }
    };

    /* Preview */
    const preview={
      c:dom.previewCanvas, ctx:dom.previewCanvas.getContext('2d'),
      layout(){
        if(!state.image) return;
        const rect=dom.previewContainer.getBoundingClientRect();
        const availW=Math.max(0,rect.width), availH=Math.max(0,rect.height);
        const aspect=state.image.width/state.image.height;
        let w=availW,h=w/aspect; if(h>availH){ h=availH; w=h*aspect; }
        this.c.width=Math.max(1,Math.round(w)); this.c.height=Math.max(1,Math.round(h));
        dom.previewCanvas.style.left=((availW-this.c.width)/2)+'px';
        dom.previewCanvas.style.top =((availH-this.c.height)/2)+'px';
      },
      render(){
        if(!state.image) return;
        const fullMask=buildFullMaskCanvas();
        const ctx=this.ctx; ctx.clearRect(0,0,this.c.width,this.c.height);
        const cssFilter=state.filters[state.activePreset].css(state.filtStrength);
        ctx.save(); ctx.filter=cssFilter; ctx.drawImage(state.image,0,0,this.c.width,this.c.height); ctx.restore();
        const colored=document.createElement('canvas'); colored.width=state.image.width; colored.height=state.image.height;
        const cctx=colored.getContext('2d'); cctx.drawImage(state.image,0,0); cctx.globalCompositeOperation='destination-in'; cctx.drawImage(fullMask,0,0);
        ctx.drawImage(colored,0,0,this.c.width,this.c.height);
      }
    };

    function buildFullMaskCanvas(){
      const m=document.createElement('canvas'); const W=state.image.width,H=state.image.height; m.width=W; m.height=H; const mctx=m.getContext('2d');
      mctx.fillStyle='#fff';
      state.selections.forEach(sel=>{
        if(sel.type==='box'){ mctx.fillRect(sel.x,sel.y,sel.w,sel.h); }
        else if(sel.type==='lasso'){ mctx.beginPath(); sel.points.forEach((p,i)=> i?mctx.lineTo(p.x,p.y):mctx.moveTo(p.x,p.y)); mctx.closePath(); mctx.fill(); }
        else if(sel.type==='mask'&&sel.maskCanvas){ mctx.drawImage(sel.maskCanvas,0,0); }
      });
      // subtract protects
      state.selections.forEach(sel=>{
        if(sel.type==='protect'&&sel.maskCanvas){ mctx.globalCompositeOperation='destination-out'; mctx.drawImage(sel.maskCanvas,0,0); mctx.globalCompositeOperation='source-over'; }
      });
      // AI final mask (if AI active)
      if(state.ai.active && state.ai.outputs.finalMask){ mctx.drawImage(state.ai.outputs.finalMask,0,0); }
      const blurPx=Math.round(clamp(state.aggr,0,100)*0.22);
      if(blurPx>0){ const t=document.createElement('canvas'); t.width=W; t.height=H; const tx=t.getContext('2d'); tx.filter=`blur(${blurPx}px)`; tx.drawImage(m,0,0); mctx.clearRect(0,0,W,H); mctx.drawImage(t,0,0); }
      return m;
    }

    /* Presets */
    function renderPresets(lazy=false){
      if(!state.image){
        dom.presets.innerHTML=''; for(let i=0;i<state.filters.length;i++){ const item=document.createElement('div'); item.className='preset'; item.innerHTML= `<canvas width="84" height="60"></canvas><label>${state.filters[i].name}</label>`; dom.presets.appendChild(item); }
        return;
      }
      const doRender=()=>{
        dom.presets.innerHTML='';
        state.filters.forEach((flt,idx)=>{
          const item=document.createElement('div'); item.className='preset'+(idx===state.activePreset?' active':''); item.innerHTML=`<canvas></canvas><label>${flt.name}</label>`;
          const c=item.querySelector('canvas'), cx=c.getContext('2d'); const aspect=state.image.width/state.image.height;
          c.width=84; c.height=Math.max(56,Math.round(84/aspect));
          cx.save(); cx.filter=flt.css(100); cx.drawImage(state.image,0,0,c.width,c.height); cx.restore();
          item.addEventListener('click',()=>{ state.activePreset=idx; state.aggr=state.filters[idx].aggr; updateSettingsUI(); document.querySelectorAll('.preset').forEach(el=>el.classList.remove('active')); item.classList.add('active'); schedulePreviewRender(true); log('Preset:', flt.name,'Feather:',state.aggr); });
          dom.presets.appendChild(item);
        });
        state.thumbnailsReady=true;
      };
      if(lazy){ state.thumbnailsReady=false; setTimeout(doRender,500); } else { doRender(); }
    }

    /* History */
    const history={
      save(){
        const snapshot={
          selections: JSON.parse(JSON.stringify(state.selections,(k,v)=> (k==='maskCanvas'&&v&&v.toDataURL)?v.toDataURL():v)),
          activeIndex:state.activeIndex, transform:{...state.transform},
          activePreset:state.activePreset, aggr:state.aggr, tol:state.tol, filtStrength:state.filtStrength,
          ai:{
            active:state.ai.active, segModel:state.ai.segModel, depthModel:state.ai.depthModel, refine:state.ai.refine,
            prompt:state.ai.prompt, lastClick:state.ai.lastClick
          }
        };
        if(state.histIndex<state.history.length-1) state.history=state.history.slice(0,state.histIndex+1);
        state.history.push(JSON.stringify(snapshot)); state.histIndex++; refreshButtons();
      },
      load(i){
        const snap=JSON.parse(state.history[i]);
        state.selections=(snap.selections||[]).map(s=>{
          if((s.type==='mask'||s.type==='protect')&&s.maskCanvas&&typeof s.maskCanvas==='string'){ const cnv=dataURLToCanvas(s.maskCanvas); return {...s, maskCanvas:cnv}; }
          return s;
        });
        state.activeIndex=snap.activeIndex; state.transform=snap.transform;
        state.activePreset=snap.activePreset??state.activePreset; state.aggr=snap.aggr??state.aggr; state.tol=snap.tol??state.tol; state.filtStrength=snap.filtStrength??state.filtStrength;
        if(snap.ai){ state.ai.active=!!snap.ai.active; state.ai.segModel=snap.ai.segModel||state.ai.segModel; state.ai.depthModel=snap.ai.depthModel||state.ai.depthModel; state.ai.refine=!!snap.ai.refine; state.ai.prompt=snap.ai.prompt||''; state.ai.lastClick=snap.ai.lastClick||null; setAIModeUI(); }
        editor.draw(); schedulePreviewRender(true); renderPresets(true); updateSettingsUI(); refreshButtons();
      },
      undo(){ if(state.histIndex>0){ state.histIndex--; history.load(state.histIndex); log('Undo'); } },
      redo(){ if(state.histIndex<state.history.length-1){ state.histIndex++; history.load(state.histIndex); log('Redo'); } }
    };

    /* Box/Lasso helpers */
    function drawBoxHandles(ctx,sel){
      const r=5/state.transform.scale;
      const pts=[[sel.x,sel.y],[ sel.x+sel.w/2, sel.y],[ sel.x+sel.w, sel.y],[ sel.x+sel.w, sel.y+sel.h/2],[ sel.x+sel.w, sel.y+sel.h],[ sel.x+sel.w/2, sel.y+sel.h],[ sel.x, sel.y+sel.h],[ sel.x, sel.y+sel.h/2]];
      ctx.fillStyle='#1877f2'; ctx.strokeStyle='#fff'; ctx.lineWidth=1.5/state.transform.scale;
      pts.forEach(([px,py])=>{ ctx.beginPath(); ctx.rect(px-r,py-r,r*2,r*2); ctx.fill(); ctx.stroke(); });
    }
    const pointInBox=(sel,x,y)=> x>=sel.x&&y>=sel.y&&x<=sel.x+sel.w&&y<=sel.y+sel.h;
    function pointInLasso(sel,x,y){
      let inside=false; const pts=sel.points;
      for(let i=0,j=pts.length-1;i<pts.length;j=i++){
        const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
        const intersect=((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }

    /* Render flow */
    const renderPreviewDebounced=debounce(()=>{ if(!state.image) return; state.rendering=true; preview.layout(); preview.render(); state.rendering=false; finishProgress(); renderPresets(true); log('Preview rendered.'); },360);
    function schedulePreviewRender(start=true){ if(!state.image) return; if(start) startProgress(); renderPreviewDebounced(); }

    /* File I/O */
    dom.uploadBtn.addEventListener('click',()=>dom.fileInput.click());
    dom.fileInput.addEventListener('change',onFileInput);
    function onFileInput(e){ const f=e.target.files[0]; if(f) readImageFile(f); }
    dom.editorWrap.addEventListener('dragover',(e)=>{e.preventDefault(); dom.editorWrap.classList.add('drop-hover');});
    dom.editorWrap.addEventListener('dragenter',(e)=>{e.preventDefault(); dom.editorWrap.classList.add('drop-hover');});
    dom.editorWrap.addEventListener('dragleave',(e)=>{e.preventDefault(); dom.editorWrap.classList.remove('drop-hover');});
    dom.editorWrap.addEventListener('drop',(e)=>{e.preventDefault(); dom.editorWrap.classList.remove('drop-hover'); const f=e.dataTransfer?.files?.[0]; if(f&&f.type.startsWith('image/')) readImageFile(f); });

    function readImageFile(file){
      const r=new FileReader();
      r.onload=()=>{ const img=new Image(); img.onload=()=>{ state.image=img; state.selections=[]; state.activeIndex=-1;
          resetAIBuffers();
          dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
          editor.updateSize(); focal.fit(); editor.draw(); renderPresets(true); history.save(); refreshButtons(); schedulePreviewRender(true); initSegWorker(); log('Image loaded:', file.name, `${img.width}x${img.height}`); };
        img.src=r.result; };
      r.readAsDataURL(file);
    }

    /* Fit / reset view */
    const focal={ fit(){ if(!state.image) return; const iW=state.image.width,iH=state.image.height; const cW=dom.editorWrap.clientWidth,cH=dom.editorWrap.clientHeight; const s=Math.min(cW/iW,cH/iH)*0.97; const x=(cW-iW*s)/2, y=(cH-iH*s)/2; state.transform={x,y,scale:s}; } };
    const refitDebounced=debounce(()=>{ if(state.image){ focal.fit(); editor.draw(); preview.layout(); } },140);
    window.addEventListener('resize',()=>{ editor.updateSize(); preview.layout(); refitDebounced(); });

    /* Interactions */
    let painting=false;
    dom.editorWrap.addEventListener('mousedown', async (e)=>{
      if(!state.image) return;

      // AI group click: set seed & run (if AI active)
      if(state.ai.active){
        const p=editor.imgToCanvasSpace(e.clientX,e.clientY);
        const sx=Math.round(clamp(p.x,0,state.image.width-1));
        const sy=Math.round(clamp(p.y,0,state.image.height-1));
        state.ai.lastClick={x:sx,y:sy};
        log(`AI seed set @ (${sx}, ${sy}).`);
        runAIPipeline({trigger:'click'}).catch(err=>log('AI error:', err?.message||err));
        return;
      }

      if(state.isPanning){
        state.drag={active:true,kind:'pan',startX:e.clientX,startY:e.clientY,tx:state.transform.x,ty:state.transform.y,moved:false};
        dom.editorWrap.classList.add('panning'); return;
      }

      const p=editor.imgToCanvasSpace(e.clientX,e.clientY);

      if(state.mode==='autoSmart'||state.mode==='autoUltra'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        if(segReady){ startProgress(); await requestSegMask(state.mode,sx,sy,state.tol,state.aggr); }
        else{
          const mask=(state.mode==='autoUltra')? ultraMask(state.image,sx,sy,state.tol/100,state.aggr) : magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
          if(mask){
            state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:(state.mode==='autoUltra'?'grabcutLite':'edgeGrow'), seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}});
            state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save();
          }
        }
        return;
      }
      if(state.mode==='autoWand'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
        if(mask){
          state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}});
          state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Auto Wand added.');
        }
        return;
      }
      if(state.mode==='protectEraser'||state.mode==='removeEraser'){
        painting=true; ensureBrushLayer(state.mode==='protectEraser'?'protect':'mask'); paintOnActiveMask(p.x,p.y,true); editor.draw(); schedulePreviewRender(); return;
      }

      // hit-testing for move/resize
      let hitIndex=-1, hitHandle=null, hitKind='none';
      for(let i=state.selections.length-1;i>=0;i--){
        const sel=state.selections[i];
        if(sel.type==='box'){
          const h=hitBoxHandle(sel,p.x,p.y); if(h){ hitIndex=i; hitHandle=h; hitKind='box-resize'; break; }
          if(pointInBox(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='lasso'){ if(pointInLasso(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='mask'||sel.type==='protect'){ if(maskHit(sel.maskCanvas,p.x,p.y)){ hitIndex=i; hitKind='move'; break; } }
      }
      if(hitIndex>=0){
        state.activeIndex=hitIndex;
        state.drag={active:true,kind:hitKind,handle:hitHandle,startX:p.x,startY:p.y,moved:false,
          snapshot: JSON.parse(JSON.stringify(state.selections[hitIndex],(k,v)=> (k==='maskCanvas'&&v&&v.toDataURL)?v.toDataURL():v))
        };
        editor.draw(); return;
      }

      // start new selection
      state.activeIndex=-1;
      if(state.mode==='box'){
        const seed={type:'box', x:p.x, y:p.y, w:0, h:0}; state.selections.push(seed); state.activeIndex=state.selections.length-1; state.drag={active:true,kind:'box-make',startX:p.x,startY:p.y,moved:false};
      }else if(state.mode==='lasso'){
        state.activeIndex=state.selections.length; const sel={type:'lasso', points:[p]}; state.selections.push(sel); state.drag={active:true,kind:'lasso-make',last:p,moved:false};
      }
      editor.draw();
    });

    dom.editorWrap.addEventListener('mousemove',(e)=>{
      if(!state.image) return;
      updateMonocle(e,'editor');

      if(painting && (state.mode==='protectEraser'||state.mode==='removeEraser')){
        const p=editor.imgToCanvasSpace(e.clientX,e.clientY); paintOnActiveMask(p.x,p.y,false); editor.draw(); schedulePreviewRender(); return;
      }
      if(!state.drag.active) return;
      const p=editor.imgToCanvasSpace(e.clientX,e.clientY);
      if(!state.drag.moved && (Math.abs(e.clientX-state.drag.startX)>3 || Math.abs(e.clientY-state.drag.startY)>3)) state.drag.moved=true;

      switch(state.drag.kind){
        case 'pan':{
          state.transform.x=state.drag.tx + (e.clientX-state.drag.startX);
          state.transform.y=state.drag.ty + (e.clientY-state.drag.startY);
          editor.draw(); break;
        }
        case 'box-resize':{
          const sel=state.selections[state.activeIndex]; const snap=reviveMaskInSnapshot(state.drag.snapshot); const handle=state.drag.handle; const minSize=10; const right=snap.x+snap.w, bottom=snap.y+snap.h;
          let nx=snap.x, ny=snap.y, nw=snap.w, nh=snap.h;
          if(handle.includes('n')){ ny=Math.min(bottom-minSize,p.y); nh=bottom-ny; }
          if(handle.includes('s')){ nh=Math.max(minSize,p.y-snap.y); }
          if(handle.includes('w')){ nx=Math.min(right-minSize,p.x); nw=right-nx; }
          if(handle.includes('e')){ nw=Math.max(minSize,p.x-snap.x); }
          Object.assign(sel,{x:nx,y:ny,w:nw,h:nh}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'move':{
          const sel=state.selections[state.activeIndex]; const snap=reviveMaskInSnapshot(state.drag.snapshot); const dx=p.x-state.drag.startX, dy=p.y-state.drag.startY;
          if(sel.type==='box'){ sel.x=snap.x+dx; sel.y=snap.y+dy; }
          else if(sel.type==='lasso'){ sel.points=snap.points.map(pt=>({x:pt.x+dx,y:pt.y+dy})); }
          else if(sel.type==='mask'||sel.type==='protect'){ const moved=document.createElement('canvas'); moved.width=snap.maskCanvas.width; moved.height=snap.maskCanvas.height; moved.getContext('2d').drawImage(snap.maskCanvas,dx,dy); sel.maskCanvas=moved; }
          editor.draw(); schedulePreviewRender(); break;
        }
        case 'box-make':{
          const sx=state.drag.startX, sy=state.drag.startY; const x=Math.min(sx,p.x), y=Math.min(sy,p.y); const w=Math.abs(p.x-sx), h=Math.abs(p.y-sy);
          const sel=state.selections[state.activeIndex]; Object.assign(sel,{x,y,w,h}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'lasso-make':{
          const sel=state.selections[state.activeIndex]; const last=state.drag.last; const dist2=(p.x-last.x)**2 + (p.y-last.y)**2;
          if(dist2>(4/state.transform.scale)**2){ sel.points.push(p); state.drag.last=p; editor.draw(); }
          break;
        }
      }
    });

    window.addEventListener('mouseup',()=>{
      if(!state.image) return;
      if(painting){ painting=false; history.save(); return; }
      if(!state.drag.active) return;
      const wasMake=/-make$/.test(state.drag.kind);
      if(state.drag.kind==='lasso-make'){
        const sel=state.selections[state.activeIndex];
        if(sel&&sel.points.length>2){ const a=sel.points[0], b=sel.points[sel.points.length-1]; if(a.x!==b.x||a.y!==b.y) sel.points.push({x:a.x,y:a.y}); }
        if(sel && sel.points.length<3){ state.selections.splice(state.activeIndex,1); state.activeIndex=-1; }
      }
      if(state.drag.kind==='box-make'){
        const sel=state.selections[state.activeIndex];
        if(!state.drag.moved){ const s=Math.max(40,Math.min(state.image.width,state.image.height)*0.12); state.selections[state.activeIndex]={type:'box',x:clamp(state.drag.startX - s/2,0,state.image.width - s), y:clamp(state.drag.startY - s/2,0,state.image.height - s), w:s,h:s}; }
        if(sel && (sel.w<5||sel.h<5)){ state.selections.splice(state.activeIndex,1); state.activeIndex=-1; }
      }
      state.drag.active=false; dom.editorWrap.classList.remove('panning'); editor.draw(); schedulePreviewRender(true); history.save(); if(wasMake) log('Selection added.');
    });

    dom.editorWrap.addEventListener('wheel',(e)=>{
      if(!state.image) return; e.preventDefault();
      const r=dom.editorCanvas.getBoundingClientRect(); const mx=e.clientX - r.left, my=e.clientY - r.top;
      const zf=1.1; const zoom=e.deltaY<0?zf:1/zf; const newScale=clamp(state.transform.scale*zoom,0.1,20);
      state.transform.x = mx - (mx - state.transform.x)*zoom; state.transform.y = my - (my - state.transform.y)*zoom; state.transform.scale=newScale;
      editor.draw(); updateMonocle(e,'editor');
    },{passive:false});

    dom.previewWrap.addEventListener('mousemove',(e)=>{ if(!state.image) return; updateMonocle(e,'preview'); });
    dom.editorWrap.addEventListener('mouseenter',()=> dom.monoLeft.style.display='block');
    dom.previewWrap.addEventListener('mouseenter',()=> dom.monoRight.style.display='block');

    /* Buttons */
    dom.modeLassoBtn.addEventListener('click',()=>{ setAIMode(false); setMode('lasso'); });
    dom.newLassoBtn.addEventListener('click',()=>{ setAIMode(false); setMode('lasso'); state.activeIndex=-1; editor.draw(); log('Ready: draw new lasso.'); });
    dom.modeBoxBtn.addEventListener('click',()=>{ setAIMode(false); setMode('box'); });
    dom.deleteSelectionBtn.addEventListener('click',()=>{ if(state.activeIndex!==-1){ const t=state.selections[state.activeIndex]?.type; state.selections.splice(state.activeIndex,1); state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted:',t||''); }});
    dom.autoWandBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoWand'); });
    dom.autoSmartBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoSmart'); });
    dom.autoUltraBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoUltra'); });
    dom.autoObjectsBtn.addEventListener('click',async()=>{
      setAIMode(false);
      if(!state.image){ alert('Load an image first.'); return; }
      const sx=Math.round(state.image.width/2), sy=Math.round(state.image.height/2);
      if(segReady){ startProgress(); await requestSegMask('autoSmart',sx,sy,state.tol,state.aggr); }
      else{
        const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
        if(mask){ state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}}); state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); }
      }
    });
    dom.protectEraserBtn.addEventListener('click',()=>{ setAIMode(false); setMode('protectEraser'); });
    dom.removeEraserBtn.addEventListener('click',()=>{ setAIMode(false); setMode('removeEraser'); });
    dom.undoBtn.addEventListener('click',()=>history.undo());
    dom.redoBtn.addEventListener('click',()=>history.redo());
    dom.renderNowBtn.addEventListener('click',()=>{ startProgress(); preview.layout(); preview.render(); finishProgress(); renderPresets(true); log('Manual render complete.'); });
    dom.resetViewBtn.addEventListener('click',()=>{ if(!state.image) return; focal.fit(); editor.draw(); log('View reset.'); });

    dom.downloadBtn.addEventListener('click',()=>{
      if(!state.image){ alert('Load an image first.'); return; }
      const out=document.createElement('canvas'); out.width=state.image.width; out.height=state.image.height; const octx=out.getContext('2d');
      // grayscale BG
      const tmpC=document.createElement('canvas'); tmpC.width=out.width; tmpC.height=out.height; const tmpX=tmpC.getContext('2d'); tmpX.drawImage(state.image,0,0);
      const src=tmpX.getImageData(0,0,out.width,out.height); const data=src.data;
      for(let i=0;i<data.length;i+=4){ const y=Math.round(0.2126*data[i]+0.7152*data[i+1]+0.0722*data[i+2]); data[i]=y; data[i+1]=y; data[i+2]=y; data[i+3]=255; }
      tmpX.putImageData(src,0,0); octx.drawImage(tmpC,0,0);
      // Foreground
      const fullMask=buildFullMaskCanvas(); const fg=document.createElement('canvas'); fg.width=out.width; fg.height=out.height; const fgx=fg.getContext('2d'); fgx.drawImage(state.image,0,0); fgx.globalCompositeOperation='destination-in'; fgx.drawImage(fullMask,0,0); octx.drawImage(fg,0,0);
      const url=out.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=`colorsplash-result-${Date.now()}.png`; a.click();
    });

    dom.startOverBtn.addEventListener('click',()=>{
      if(!state.image) return;
      if(confirm('Clear image and selections?')){
        state.image=null; state.selections=[]; state.activeIndex=-1; state.history=[]; state.histIndex=-1; resetAIBuffers();
        dom.editorEmpty.classList.remove('hidden'); dom.previewEmpty.classList.remove('hidden');
        editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width,editor.c.height); preview.ctx.clearRect(0,0,preview.c.width,preview.c.height);
        dom.aiVariants.innerHTML=''; dom.aiMaskThumb.getContext('2d').clearRect(0,0,dom.aiMaskThumb.width,dom.aiMaskThumb.height); dom.aiDepthThumb.getContext('2d').clearRect(0,0,dom.aiDepthThumb.width,dom.aiDepthThumb.height);
        renderPresets(); refreshButtons(); log('Project cleared.');
      }
    });

    dom.saveBtn.addEventListener('click',()=>{
      if(!state.image) return;
      const payload={
        app:'Color Splash Pro X', version:APP_VERSION,
        imageDataURL:getCurrentImageDataURL(),
        selections: state.selections.map(s=>{ const base={...s}; if((s.type==='mask'||s.type==='protect')&&s.maskCanvas) base.maskCanvas=s.maskCanvas.toDataURL(); return base; }),
        activePreset:state.activePreset, aggr:state.aggr, tol:state.tol, filtStrength:state.filtStrength,
        ai:{ active:state.ai.active, segModel:state.ai.segModel, depthModel:state.ai.depthModel, refine:state.ai.refine, prompt:state.ai.prompt, lastClick:state.ai.lastClick }
      };
      const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`colorsplash-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href); log('Saved project JSON.');
    });

    dom.loadBtn.addEventListener('click',()=>dom.loadInput.click());
    dom.loadInput.addEventListener('change',(e)=>{
      const f=e.target.files[0]; if(!f) return; const r=new FileReader();
      r.onload=()=>{ try{ const obj=JSON.parse(r.result); loadFromObject(obj); log('Loaded project JSON.'); } catch(err){ alert('Invalid JSON'); }};
      r.readAsText(f);
    });

    function loadFromObject(obj){
      const img=new Image();
      img.onload=()=>{
        state.image=img;
        state.selections=(obj.selections||[]).map(s=>{
          if((s.type==='mask'||s.type==='protect')&&s.maskCanvas&&typeof s.maskCanvas==='string'){ const cnv=dataURLToCanvas(s.maskCanvas); return {...s, maskCanvas:cnv}; }
          return s;
        });
        state.activeIndex=-1; state.activePreset=obj.activePreset??0; state.aggr=obj.aggr??35; state.tol=obj.tol??25; state.filtStrength=obj.filtStrength??100;
        if(obj.ai){ state.ai.active=!!obj.ai.active; state.ai.segModel=obj.ai.segModel||state.ai.segModel; state.ai.depthModel=obj.ai.depthModel||state.ai.depthModel; state.ai.refine=!!obj.ai.refine; state.ai.prompt=obj.ai.prompt||''; state.ai.lastClick=obj.ai.lastClick||null; }
        dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
        editor.updateSize(); focal.fit(); editor.draw(); renderPresets(true); updateSettingsUI(); state.history=[]; state.histIndex=-1; history.save(); refreshButtons(); schedulePreviewRender(true); initSegWorker(); setAIModeUI();
      };
      img.src=obj.imageDataURL;
    }

    /* Settings (in pinned panel) */
    function updateSettingsUI(){
      dom.aggrRange.value=state.aggr; dom.aggrVal.textContent=state.aggr;
      dom.tolRange.value=state.tol; dom.tolVal.textContent=state.tol;
      dom.fltRange.value=state.filtStrength; dom.fltVal.textContent=state.filtStrength+'%';
      dom.aiActiveSwitch.checked=state.ai.active;
      dom.aiSegModel.value=state.ai.segModel; dom.aiDepthModel.value=state.ai.depthModel; dom.aiRefine.checked=state.ai.refine; dom.aiPreload.checked=state.ai.preload; dom.aiPrompt.value=state.ai.prompt||'';
      showPromptIfNeeded();
    }

    dom.aggrRange.addEventListener('input',()=>{ state.aggr=parseInt(dom.aggrRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });
    dom.tolRange.addEventListener('input',()=>{ state.tol=parseInt(dom.tolRange.value,10); updateSettingsUI(); if(state.modeGroup==='manual'){ recomputeGeneratedMasks(); } });
    dom.fltRange.addEventListener('input',()=>{ state.filtStrength=parseInt(dom.fltRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });
    dom.clearLogsBtn.addEventListener('click',()=>{ dom.aiLogBody.innerHTML=''; });

    /* Pinned panel open */
    dom.pinFab.addEventListener('click',()=> dom.pinPanel.classList.toggle('visible'));
    dom.toggleLogsBtn.addEventListener('click',()=> dom.pinPanel.classList.add('visible'));

    /* Modes */
    function setMode(m){
      state.mode=m;
      dom.modeLassoBtn.classList.toggle('active',m==='lasso');
      dom.modeBoxBtn.classList.toggle('active',m==='box');
      dom.autoWandBtn.classList.toggle('active',m==='autoWand');
      dom.autoSmartBtn.classList.toggle('active',m==='autoSmart');
      dom.autoUltraBtn.classList.toggle('active',m==='autoUltra');
      dom.protectEraserBtn.classList.toggle('active',m==='protectEraser');
      dom.removeEraserBtn.classList.toggle('active',m==='removeEraser');
      log('Mode:',m);
    }
    function refreshButtons(){
      dom.undoBtn.disabled=state.histIndex<=0;
      dom.redoBtn.disabled=state.histIndex>=state.history.length-1||state.history.length===0;
      dom.deleteSelectionBtn.disabled=state.activeIndex===-1;
      dom.saveBtn.disabled=!state.image;
      dom.startOverBtn.disabled=!state.image;
    }

    /* Init */
    function init(){
      editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width,editor.c.height);
      preview.ctx.clearRect(0,0,preview.c.width,preview.c.height);
      renderPresets(); updateSettingsUI(); refreshButtons();
      log(`App ready. Version ${APP_VERSION}`);
      log('Shortcuts: S=Lasso, B=Box, W=Auto Wand, G=Auto Smart, U=Auto Ultra, E=Protect, R=Remove. Space-drag Pan. Wheel Zoom.');
      setAIModeUI(); detectRuntime();
    }
    init();

    /* Smart recompute (manual) */
    async function recomputeGeneratedMasks(){
      if(!state.image) return;
      const targets=[];
      state.selections.forEach((s,idx)=>{ if(s && s.type==='mask' && s.generator && s.generator.tool && s.generator.origin!=='ai'){ const t=s.generator.tool; if(t==='edgeGrow'||t==='grabcutLite'||t==='magicWand'){ targets.push(idx); } }});
      if(targets.length===0){ schedulePreviewRender(true); return; }
      startProgress();
      const newMasks=[];
      for(const idx of targets){
        const s=state.selections[idx], g=s.generator||{}; const sx=Math.round(g.seedX??(state.image.width/2)), sy=Math.round(g.seedY??(state.image.height/2));
        const tool=(g.tool==='edgeGrow')?'autoSmart':(g.tool==='grabcutLite')?'autoUltra':(g.tool==='magicWand')?'autoWand':'autoSmart';
        if(tool==='autoWand'){ const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr); if(mask) newMasks.push({i:idx,canvas:mask,generator:{tool:'magicWand',seedX:sx,seedY:sy,params:{tol:state.tol,aggr:state.aggr},origin:'manual'}}); }
        else if(segReady){ await requestSegMask(tool,sx,sy,state.tol,state.aggr); newMasks.push({i:idx,replace:true}); }
        else{
          const fb=(tool==='autoUltra')? ultraMask(state.image,sx,sy,state.tol/100,state.aggr) : magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
          if(fb) newMasks.push({i:idx,canvas:fb,generator:{tool:(tool==='autoUltra'?'grabcutLite':'edgeGrow'),seedX:sx,seedY:sy,params:{tol:state.tol,aggr:state.aggr, fallback:true},origin:'manual'}});
        }
      }
      const toDelete=[]; for(const nm of newMasks){ if(nm.replace){ toDelete.push(nm.i);} else { state.selections[nm.i]={type:'mask',maskCanvas:nm.canvas,generator:nm.generator}; } }
      toDelete.sort((a,b)=>b-a).forEach(i=> state.selections.splice(i,1));
      editor.draw(); schedulePreviewRender(false); history.save(); finishProgress(); log('Recomputed',targets.length,'mask(s).');
    }

    /* Built-in magic wand/ultra */
    function magicWandMask(img, sx, sy, tol01, grow){
      const w=img.width,h=img.height, maxSide=1024, scale=Math.min(1,maxSide/Math.max(w,h));
      const sw=Math.max(1,Math.round(w*scale)), sh=Math.max(1,Math.round(h*scale));
      const sC=document.createElement('canvas'); sC.width=sw; sC.height=sh; const sX=sC.getContext('2d'); sX.drawImage(img,0,0,sw,sh);
      const x=clamp(Math.round(sx*scale),0,sw-1), y=clamp(Math.round(sy*scale),0,sh-1);
      const src=sX.getImageData(0,0,sw,sh); const data=src.data; const mask=new Uint8Array(sw*sh);
      const idx=(x,y)=> y*sw+x, pIdx=(x,y)=> idx(x,y)*4;
      const r0=data[pIdx(x,y)], g0=data[pIdx(x,y)+1], b0=data[pIdx(x,y)+2]; const thr=8 + tol01*132;
      const st=[[x,y]]; mask[idx(x,y)]=1;
      while(st.length){ const [cx,cy]=st.pop(); for(const [nx,ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){ if(nx<0||ny<0||nx>=sw||ny>=sh) continue; const id=idx(nx,ny); if(mask[id]) continue; const p=pIdx(nx,ny); const dr=data[p]-r0,dg=data[p+1]-g0,db=data[p+2]-b0; const dist=Math.sqrt(dr*dr+dg*dg+db*db); if(dist<=thr){ mask[id]=1; st.push([nx,ny]); } } }
      if(grow>0){ const it=Math.round(clamp(grow,0,100)*0.08), nb=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        for(let k=0;k<it;k++){ const copy=mask.slice(0); for(let yy=0;yy<sh;yy++){ for(let xx=0;xx<sw;xx++){ if(copy[idx(xx,yy)]) continue; let on=0; for(const [dx,dy] of nb){ const xx2=xx+dx, yy2=yy+dy; if(xx2>=0&&yy2>=0&&xx2<sw&&yy2<sh && copy[idx(xx2,yy2)]){ on=1; break; } } if(on) mask[idx(xx,yy)]=1; } } }
      }
      const mC=document.createElement('canvas'); mC.width=w; mC.height=h; const mX=mC.getContext('2d');
      const mSmall=document.createElement('canvas'); mSmall.width=sw; mSmall.height=sh; const msx=mSmall.getContext('2d'); const id=msx.createImageData(sw,sh);
      for(let i=0;i<sw*sh;i++){ const v=mask[i]?255:0; id.data[i*4]=255; id.data[i*4+1]=255; id.data[i*4+2]=255; id.data[i*4+3]=v; }
      msx.putImageData(id,0,0); mX.imageSmoothingEnabled=false; mX.drawImage(mSmall,0,0,sw,sh,0,0,w,h);
      return mC;
    }
    function ultraMask(img,sx,sy,tol01,aggr){ return magicWandMask(img,sx,sy,Math.min(1,tol01*1.2+0.05),aggr+8); }
    function maskHit(maskCanvas,x,y){ if(x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return false; const ctx=maskCanvas.getContext('2d'); const d=ctx.getImageData(Math.floor(x),Math.floor(y),1,1).data; return d[3]>10; }
    function edgeFromMask(maskCanvas,r){
      const w=maskCanvas.width,h=maskCanvas.height; if(!w||!h) return null;
      const srcCtx=maskCanvas.getContext('2d'); const src=srcCtx.getImageData(0,0,w,h);
      const er=document.createElement('canvas'); er.width=w; er.height=h; const ex=er.getContext('2d'); ex.filter=`blur(${Math.max(0.5,r)}px)`; ex.drawImage(maskCanvas,0,0); ex.filter='none'; const eData=ex.getImageData(0,0,w,h);
      const out=document.createElement('canvas'); out.width=w; out.height=h; const ox=out.getContext('2d'); const oData=ox.createImageData(w,h);
      for(let i=0;i<oData.data.length;i+=4){ const a=src.data[i+3], b=eData.data[i+3]; const v=Math.max(0,a-b); oData.data[i]=0; oData.data[i+1]=0; oData.data[i+2]=0; oData.data[i+3]=v>8?220:0; } ox.putImageData(oData,0,0); return out;
    }
    function reviveMaskInSnapshot(snap){ if(snap && (snap.type==='mask'||snap.type==='protect') && snap.maskCanvas && typeof snap.maskCanvas==='string'){ snap.maskCanvas=dataURLToCanvas(snap.maskCanvas);} return snap; }
    function dataURLToCanvas(url){ const img=new Image(); const cnv=document.createElement('canvas'); img.onload=()=>{ cnv.width=img.width; cnv.height=img.height; cnv.getContext('2d').drawImage(img,0,0); }; img.src=url; return cnv; }
    function getCurrentImageDataURL(){ if(!state.image) return ''; if(typeof state.image.src==='string' && state.image.src.startsWith('data:')) return state.image.src; const c=document.createElement('canvas'); c.width=state.image.width; c.height=state.image.height; c.getContext('2d').drawImage(state.image,0,0); return c.toDataURL('image/png'); }

    /* Erasers */
    function ensureBrushLayer(kind){ const idx=state.selections.findIndex(s=>s.type === (kind==='protect'?'protect':'mask')); if(idx>=0){ state.activeIndex=idx; return; } const cnv=document.createElement('canvas'); cnv.width=state.image.width; cnv.height=state.image.height; state.selections.push({type:(kind==='protect'?'protect':'mask'), maskCanvas:cnv}); state.activeIndex=state.selections.length-1; }
    let lastPaint=null;
    function paintOnActiveMask(x,y,fresh){
      const sel=state.selections[state.activeIndex]; if(!sel||!sel.maskCanvas) return; const ctx=sel.maskCanvas.getContext('2d'); const size=state.brush.size, hard=state.brush.hard, r=size/2;
      ctx.save(); ctx.globalCompositeOperation='source-over'; const gx=ctx.createRadialGradient(x,y,r*hard,x,y,r); const color=(sel.type==='protect')?'rgba(255,0,0,1)':'rgba(255,255,255,1)'; gx.addColorStop(0,color); gx.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gx;
      if(fresh||!lastPaint){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } else { const dx=x-lastPaint.x, dy=y-lastPaint.y; const steps=Math.max(1,Math.ceil(Math.hypot(dx,dy)/(r*0.5))); for(let i=1;i<=steps;i++){ const t=i/steps; const px=lastPaint.x+dx*t, py=lastPaint.y+dy*t; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); } }
      ctx.restore(); lastPaint={x,y};
    }

    /* Dual monocles with hop + correct preview sampling */
    function updateMonocle(e,where){
      if(!state.image) return;
      const hopIfNear=(el,panelRect,side)=>{
        const pad=10; const rect=el.getBoundingClientRect();
        const dx = (rect.left>e.clientX)? rect.left-e.clientX : (e.clientX>rect.right? e.clientX-rect.right : 0);
        const dy = (rect.top>e.clientY)? rect.top-e.clientY : (e.clientY>rect.bottom? e.clientY-rect.bottom : 0);
        const dist=Math.hypot(dx,dy);
        if(dist<18){ if(side==='left'){ el.style.left=(panelRect.width-rect.width-pad)+'px'; el.style.right='auto'; }else{ el.style.right=(panelRect.width-rect.width-pad)+'px'; el.style.left='auto'; } }
        else{ if(side==='left'){ el.style.left=pad+'px'; el.style.right='auto'; } else { el.style.right=pad+'px'; el.style.left='auto'; } }
      };

      if(where==='editor'){
        const mctx=dom.monoLeftCanvas.getContext('2d'); if(dom.monoLeftCanvas.width===0){ dom.monoLeftCanvas.width=148; dom.monoLeftCanvas.height=148; }
        const rect=dom.editorCanvas.getBoundingClientRect();
        const cx=(e.clientX-rect.left - state.transform.x)/state.transform.scale;
        const cy=(e.clientY-rect.top  - state.transform.y)/state.transform.scale;
        const box=64; const sx=Math.floor(clamp(cx-box/2,0,state.image.width-box)); const sy=Math.floor(clamp(cy-box/2,0,state.image.height-box));
        mctx.imageSmoothingEnabled=false; mctx.clearRect(0,0,dom.monoLeftCanvas.width,dom.monoLeftCanvas.height);
        mctx.drawImage(state.image,sx,sy,box,box,0,0,dom.monoLeftCanvas.width,dom.monoLeftCanvas.height);
        const fx=((cx-sx)/box)*dom.monoLeftCanvas.width, fy=((cy-sy)/box)*dom.monoLeftCanvas.height; mctx.strokeStyle='#0a46ff'; mctx.lineWidth=1; mctx.beginPath(); mctx.moveTo(fx,0); mctx.lineTo(fx,dom.monoLeftCanvas.height); mctx.moveTo(0,fy); mctx.lineTo(dom.monoLeftCanvas.width,fy); mctx.stroke();
        dom.monoLeft.style.display='block'; hopIfNear(dom.monoLeft, dom.editorWrap.getBoundingClientRect(),'left');
      }else{
        const mctx=dom.monoRightCanvas.getContext('2d'); if(dom.monoRightCanvas.width===0){ dom.monoRightCanvas.width=148; dom.monoRightCanvas.height=148; }
        const rect=dom.previewCanvas.getBoundingClientRect();
        const scaleX=state.image.width/Math.max(1,dom.previewCanvas.width), scaleY=state.image.height/Math.max(1,dom.previewCanvas.height);
        const cx=(e.clientX-rect.left)*scaleX, cy=(e.clientY-rect.top)*scaleY;
        const box=64; const sx=Math.floor(clamp(cx-box/2,0,state.image.width-box)); const sy=Math.floor(clamp(cy-box/2,0,state.image.height-box));
        // sample directly from preview canvas using mapped rectangle
        const sxPrev = sx/scaleX, syPrev = sy/scaleY, swPrev = box/scaleX, shPrev = box/scaleY;
        mctx.imageSmoothingEnabled=false; mctx.clearRect(0,0,dom.monoRightCanvas.width,dom.monoRightCanvas.height);
        mctx.drawImage(dom.previewCanvas, sxPrev, syPrev, swPrev, shPrev, 0,0, dom.monoRightCanvas.width, dom.monoRightCanvas.height);
        const fx=((cx-sx)/box)*dom.monoRightCanvas.width, fy=((cy-sy)/box)*dom.monoRightCanvas.height; mctx.strokeStyle='#0a46ff'; mctx.lineWidth=1; mctx.beginPath(); mctx.moveTo(fx,0); mctx.lineTo(fx,dom.monoRightCanvas.height); mctx.moveTo(0,fy); mctx.lineTo(dom.monoRightCanvas.width,fy); mctx.stroke();
        dom.monoRight.style.display='block'; hopIfNear(dom.monoRight, dom.previewWrap.getBoundingClientRect(),'right');
      }
    }

    /* AI bar & toggles */
    dom.aiModeBtn.addEventListener('click',()=> setAIMode(!state.ai.active));
    dom.aiActiveSwitch.addEventListener('change',()=> setAIMode(dom.aiActiveSwitch.checked));
    dom.aiSegModel.addEventListener('change',()=>{ state.ai.segModel=dom.aiSegModel.value; showPromptIfNeeded(); if(state.ai.preload) backgroundPreload(state.ai.segModel); log('AI seg model:',state.ai.segModel); maybeAutoRunIfSeed(); });
    dom.aiDepthModel.addEventListener('change',()=>{ state.ai.depthModel=dom.aiDepthModel.value; if(state.ai.preload) backgroundPreload(state.ai.depthModel); log('AI depth model:',state.ai.depthModel); maybeAutoRunIfSeed(); });
    dom.aiRefine.addEventListener('change',()=>{ state.ai.refine=dom.aiRefine.checked; dom.aiStatus.textContent = state.ai.refine?'refine: on':'refine: off'; if(state.ai.active && state.ai.outputs.baseMask){ // regenerate variants fast
        generateVariantsAndShow(); schedulePreviewRender(true);
      }});
    dom.aiPreload.addEventListener('change',()=>{ state.ai.preload=dom.aiPreload.checked; log('Preload', state.ai.preload?'ON':'OFF'); });
    dom.aiPrompt.addEventListener('input',()=>{ state.ai.prompt=dom.aiPrompt.value; });

    dom.aiUseBtn.addEventListener('click',()=>{ if(!state.image){ alert('Load an image first.'); return; } runAIPipeline({trigger:'use'}).catch(err=>log('AI error:', err?.message||err)); });

    function setAIMode(flag){
      state.ai.active=!!flag; state.modeGroup = flag?'ai':'manual'; setAIModeUI();
      if(flag){
        if(state.ai.preload){ backgroundPreload(state.ai.segModel); backgroundPreload(state.ai.depthModel); }
        log('AI Mode ON. Select models, click Original to set seed, or press Use.');
      } else { log('AI Mode OFF. Manual tools active.'); }
      history.save();
    }
    function setAIModeUI(){
      dom.aiModeBtn.classList.toggle('active',state.ai.active);
      dom.aiBar.classList.toggle('visible',state.ai.active);
      dom.aiActiveSwitch.checked=state.ai.active;
      dom.aiSegModel.value=state.ai.segModel; dom.aiDepthModel.value=state.ai.depthModel; dom.aiRefine.checked=state.ai.refine; dom.aiPreload.checked=state.ai.preload; dom.aiPrompt.value=state.ai.prompt||'';
      dom.aiStatus.textContent = state.ai.active? 'AI mode: ready' : 'AI mode: off';
      showPromptIfNeeded();
    }
    function showPromptIfNeeded(){ const needsPrompt = (dom.aiSegModel.value==='clipseg'); dom.aiPrompt.classList.toggle('hidden', !needsPrompt); }

    function maybeAutoRunIfSeed(){ if(state.ai.active && state.ai.lastClick){ runAIPipeline({trigger:'model-change'}).catch(e=>log('AI error:', e?.message||e)); } }

    /* Runtime detect */
    async function detectRuntime(){
      try{ const gpuAvail = !!ort.env.webgpu && (await navigator.gpu?.requestAdapter())!=null; dom.runtimeChip.textContent = gpuAvail? 'WebGPU + WASM':'WASM only'; log('Runtime:',dom.runtimeChip.textContent); }
      catch{ dom.runtimeChip.textContent='WASM only'; }
    }

    /* ORT sessions with download progress (ArrayBuffer path) */
    const downloadCache={}; // key -> ArrayBuffer
    async function ensureORTSession(key, {withProgress=true}={}){
      if(state.ai.sessions[key]) return state.ai.sessions[key];
      const entry=MODEL_URLS[key]; if(!entry) throw new Error('Unknown model '+key);
      // fetch with progress unless cached
      let modelBuf=downloadCache[key];
      if(!modelBuf){
        if(!withProgress){ // simple fetch
          const res=await fetch(entry.url,{mode:'cors'}); if(!res.ok) throw new Error('HTTP '+res.status);
          modelBuf=await res.arrayBuffer();
        }else{
          modelBuf=await fetchWithProgress(entry.url, key, entry.sizeHintMB);
        }
        downloadCache[key]=modelBuf;
      }
      // pick providers
      let providers=['wasm'];
      try{ if(ort.env.webgpu){ const ad=await navigator.gpu?.requestAdapter(); if(ad) providers=['webgpu','wasm']; } }catch{}
      dom.aiStatus.textContent = `initializing ${key}‚Ä¶`;
      const t0=performance.now();
      const session=await ort.InferenceSession.create(modelBuf,{executionProviders:providers, graphOptimizationLevel:'all'});
      const ms=Math.round(performance.now()-t0);
      log(`AI: ${key} initialized in ${ms} ms via ${providers[0]}.`);
      dom.aiStatus.textContent = `loaded ${key}`;
      state.ai.sessions[key]=session;
      return session;
    }
    async function fetchWithProgress(url, key, sizeHintMB){
      log(`Downloading ${key} (~${sizeHintMB}MB)‚Ä¶`);
      dom.aiStatus.textContent=`downloading ${key}‚Ä¶`;
      startProgress();
      const res=await fetch(url,{mode:'cors'}); if(!res.ok) throw new Error('HTTP '+res.status);
      const reader=res.body.getReader(); const chunks=[]; let rec=0; const contentLength=Number(res.headers.get('content-length'))||0;
      while(true){ const {done,value}=await reader.read(); if(done) break; chunks.push(value); rec+=value.byteLength; const ratio=contentLength? rec/contentLength : Math.min(1, rec/(sizeHintMB*1024*1024)); dom.progressBar.style.width = Math.round(100*ratio)+'%'; }
      const buf=mergeChunks(chunks, rec); finishProgress(); log(`Downloaded ${key} (${(rec/1024/1024).toFixed(1)}MB).`); return buf;
    }
    function mergeChunks(chunks,total){ const out=new Uint8Array(total); let off=0; for(const ch of chunks){ out.set(ch,off); off+=ch.length; } return out.buffer; }

    /* AI pipeline */
    function resetAIBuffers(){
      state.ai.outputs={baseMask:null, depthCanvas:null, depthMap:null, finalMask:null, variants:[]};
      dom.aiVariants.innerHTML='';
      const c1=dom.aiMaskThumb.getContext('2d'); c1.clearRect(0,0,dom.aiMaskThumb.width,dom.aiMaskThumb.height);
      const c2=dom.aiDepthThumb.getContext('2d'); c2.clearRect(0,0,dom.aiDepthThumb.width,dom.aiDepthThumb.height);
    }

    async function runAIPipeline({trigger}={}){
      if(!state.image) return;
      state.modeGroup='ai';
      startProgress(); dom.aiStatus.textContent='running‚Ä¶';

      // Load models as needed
      let segSess=null, depthSess=null;
      try{ segSess = await ensureORTSession(state.ai.segModel); }catch(err){ log('Seg model failed:', err?.message||err); }
      try{ depthSess = await ensureORTSession(state.ai.depthModel); }catch(err){ log('Depth model failed:', err?.message||err); }

      const img=state.image;
      const seed=state.ai.lastClick || {x:Math.round(img.width/2), y:Math.round(img.height/2)};

      // SEGMENT
      let baseMask=null;
      try{
        const segKey=state.ai.segModel, info=MODEL_URLS[segKey];
        if(segKey==='yolov8n-seg' || segKey==='yolo11n-seg'){
          baseMask = await segWithYOLO(segSess, img, info.inputSize, seed);
        }else if(segKey==='mobile-sam'){
          if(!state.ai.lastClick) throw new Error('MobileSAM needs a seed point; click the object.');
          baseMask = await segWithMobileSAM(segSess, img, info.inputSize, seed);
        }else if(segKey==='clipseg'){
          if(!state.ai.prompt){ log('CLIPSeg: empty prompt ‚Üí defaulting to click seed fallback.'); baseMask = null; }
          else baseMask = await segWithCLIPSeg(segSess, img, info.inputSize, state.ai.prompt);
        }
        if(!baseMask) throw new Error('No mask from model');
        state.ai.outputs.baseMask=baseMask;
      }catch(err){
        log('Segmentation failed ‚Üí fallback:', err?.message||err);
        // Fallback to worker edgeGrow around seed
        if(segReady){ await requestSegMask('autoSmart', seed.x, seed.y, state.tol, state.aggr); }
        else{
          const m = magicWandMask(img, seed.x, seed.y, state.tol/100, state.aggr);
          if(m){ state.selections.push({type:'mask',maskCanvas:m,generator:{tool:'edgeGrow',seedX:seed.x,seedY:seed.y,params:{tol:state.tol,aggr:state.aggr},origin:'ai-fallback'}}); }
        }
      }

      // DEPTH
      let depthRes=null;
      try{
        if(depthSess){ depthRes = await depthPredict(depthSess, img, MODEL_URLS[state.ai.depthModel].inputSize); }
        else throw new Error('depth session missing');
      }catch(err){
        log('Depth failed ‚Üí synthetic luminance depth:', err?.message||err);
        depthRes = syntheticDepth(img);
      }
      state.ai.outputs.depthCanvas = depthRes.canvas; state.ai.outputs.depthMap = depthRes.map;

      // Show thumbs BEFORE refine/math
      drawThumb(dom.aiMaskThumb, state.ai.outputs.baseMask || lastMaskFromSelections(), img);
      drawThumb(dom.aiDepthThumb, state.ai.outputs.depthCanvas, img);

      // VARIANTS (generate 5 and display)
      await generateVariantsAndShow();

      // Pick best default (variant #3) as final
      selectVariant(2); // middle one often balanced
      schedulePreviewRender(true);
      history.save();
      dom.aiStatus.textContent='done';
      finishProgress();
    }

    function drawThumb(canvas, sourceCanvas, img){
      if(!canvas) return;
      const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
      if(!sourceCanvas){ return; }
      const aspect=img.height/img.width; const th=Math.round(canvas.width*aspect); canvas.height=th;
      ctx.imageSmoothingEnabled=false; ctx.drawImage(sourceCanvas,0,0,canvas.width,canvas.height);
    }

    function lastMaskFromSelections(){ for(let i=state.selections.length-1;i>=0;i--){ const s=state.selections[i]; if(s.type==='mask'&&s.maskCanvas) return s.maskCanvas; } return null; }

    /* YOLO seg (decoding similar to previous attempt, but guarded) */
    async function segWithYOLO(session,img,inputSize,seed){
      const {tensor, scale, dx, dy} = makeLetterboxInput(img,inputSize);
      const feeds={}; feeds[session.inputNames?.[0]||'images']=tensor;
      const outputs = await session.run(feeds);
      const names = Object.keys(outputs);
      if(names.length<2) throw new Error('unexpected outputs');
      const det=outputs[names[0]], proto=outputs[names[1]];
      return decodeYOLO(det,proto,inputSize,scale,dx,dy,img.width,img.height,seed);
    }
    function decodeYOLO(det,proto,inputSize,scale,dx,dy,outW,outH,seed){
      const detData=det.data, detShape=det.dims; const protoData=proto.data, protoShape=proto.dims; // [1,N,C], [1,maskDim,mh,mw]
      const N=detShape[1], C=detShape[2], maskDim=protoShape[1]; const clsCount=C-4-1-maskDim;
      const candidates=[];
      for(let i=0;i<N;i++){
        const off=i*C; const cx=detData[off+0], cy=detData[off+1], bw=detData[off+2], bh=detData[off+3]; const conf=detData[off+4];
        if(conf<0.2) continue;
        let best=-1,score=-1; for(let c=0;c<clsCount;c++){ const sc=detData[off+5+c]; if(sc>best){best=sc; score=sc;} }
        const final=conf*score; if(final<0.25) continue;
        const coeff=detData.slice(off+5+clsCount,off+5+clsCount+maskDim);
        const x1=cx-bw/2, y1=cy-bh/2, x2=cx+bw/2, y2=cy+bh/2;
        candidates.push({x1,y1,x2,y2,score:final,coeff});
      }
      candidates.sort((a,b)=>b.score-a.score);
      const kept=[]; const iouThr=0.5;
      for(const a of candidates){
        let ok=true; for(const b of kept){ if(IOU(a,b)>iouThr){ ok=false; break; } }
        if(ok) kept.push(a); if(kept.length>20) break;
      }
      if(kept.length===0) return null;

      const mw=protoShape[3], mh=protoShape[2]; const maskDim=protoShape[1];
      // build proto matrix transposed: we‚Äôll compute on the fly
      let chosen=null, bestScore=-1;
      for(const det of kept){
        const mSmall=document.createElement('canvas'); mSmall.width=mw; mSmall.height=mh; const sctx=mSmall.getContext('2d'); const id=sctx.createImageData(mw,mh);
        for(let i=0;i<mw*mh;i++){
          let s=0; for(let k=0;k<maskDim;k++) s += protoData[k*mw*mh + i] * det.coeff[k];
          const v=1/(1+Math.exp(-s)); const a=Math.round(255*clamp(v,0,1)); const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=a;
        }
        sctx.putImageData(id,0,0);

        // place into image coords: invert letterbox
        const maskCanvas=document.createElement('canvas'); maskCanvas.width=outW; maskCanvas.height=outH; const mctx=maskCanvas.getContext('2d');
        mctx.drawImage(mSmall,0,0,inputSize,inputSize, -dx, -dy, inputSize/scale, inputSize/scale);

        if(seed){
          if(maskHit(maskCanvas,seed.x,seed.y)) return maskCanvas;
          // else keep best by score and proximity
          const cx=(det.x1+det.x2)/2, cy=(det.y1+det.y2)/2; const dxs=seed.x - (cx-dx)/scale, dys=seed.y - (cy-dy)/scale;
          const prox=Math.hypot(dxs,dys); const score=det.score/(1+0.001*prox); if(score>bestScore){ bestScore=score; chosen=maskCanvas; }
        }else{
          if(det.score>bestScore){ bestScore=det.score; chosen=maskCanvas; }
        }
      }
      return chosen;
    }
    function IOU(a,b){ const xx1=Math.max(a.x1,b.x1),yy1=Math.max(a.y1,b.y1),xx2=Math.min(a.x2,b.x2),yy2=Math.min(a.y2,b.y2); const w=Math.max(0,xx2-xx1),h=Math.max(0,yy2-yy1); const inter=w*h; const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1); return inter/Math.max(1e-6, areaA+areaB-inter); }
    function makeLetterboxInput(img,size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d'); x.fillStyle='#000'; x.fillRect(0,0,size,size);
      const r=Math.min(size/img.width,size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r); const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
      x.drawImage(img,dx,dy,nw,nh); const d=x.getImageData(0,0,size,size).data; const arr=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ arr[j++]=d[i]/255; arr[j++]=d[i+1]/255; arr[j++]=d[i+2]/255; }
      const tensor=new ort.Tensor('float32',arr,[1,size,size,3]); return {tensor,scale:r,dx,dy};
    }

    /* MobileSAM best-effort (point) */
    async function segWithMobileSAM(session,img,inputSize,seed){
      if(!seed) throw new Error('MobileSAM needs a click point');
      // Simplified preprocessing + feeds; many MobileSAM ONNX exports vary; we guard failures.
      try{
        const c=document.createElement('canvas'); c.width=inputSize; c.height=inputSize; const cx=c.getContext('2d'); cx.drawImage(img,0,0,inputSize,inputSize);
        const d=cx.getImageData(0,0,inputSize,inputSize).data; const a=new Float32Array(inputSize*inputSize*3);
        for(let i=0,j=0;i<d.length;i+=4){ a[j++]=(d[i]/255 - 0.5)/0.5; a[j++]=(d[i+1]/255 - 0.5)/0.5; a[j++]=(d[i+2]/255 - 0.5)/0.5; }
        const tImg=new ort.Tensor('float32',a,[1,inputSize,inputSize,3]);
        const pn = session.inputNames?.find(n=>/point/i.test(n)) || 'point_coords';
        const imgName = session.inputNames?.find(n=>/image|input/i.test(n)) || 'input_image';
        const feeds={}; feeds[imgName]=tImg; feeds[pn]= new ort.Tensor('float32', new Float32Array([seed.x/img.width, seed.y/img.height]), [1,2]);
        const outs=await session.run(feeds); const out = outs[Object.keys(outs)[0]];
        return tensorToMaskCanvas(out, img.width, img.height);
      }catch(e){ throw new Error('MobileSAM signature mismatch'); }
    }
    function tensorToMaskCanvas(tensor,outW,outH){
      const data=tensor.data, dims=tensor.dims;
      let H=0,W=0; if(dims.length===4){ H=dims[dims.length-2]; W=dims[dims.length-1]; } else if(dims.length===3){ H=dims[1]; W=dims[2]; } else throw new Error('bad dims');
      const s=document.createElement('canvas'); s.width=W; s.height=H; const sx=s.getContext('2d'); const id=sx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=1/(1+Math.exp(-(data[i]||0))); const a=Math.round(255*clamp(v,0,1)); const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=a; }
      sx.putImageData(id,0,0);
      const c=document.createElement('canvas'); c.width=outW; c.height=outH; const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(s,0,0,outW,outH);
      return c;
    }

    /* CLIPSeg (prompt) ‚Äì best-effort; if shape/signature mismatches, we fallback */
    async function segWithCLIPSeg(session,img,inputSize,prompt){
      try{
        // Simple image resize NHWC [1,H,W,3] in [0,1]; text embedding handling varies; some ONNX bundles include text encoder.
        const c=document.createElement('canvas'); c.width=inputSize; c.height=inputSize; const x=c.getContext('2d'); x.drawImage(img,0,0,inputSize,inputSize);
        const d=x.getImageData(0,0,inputSize,inputSize).data; const a=new Float32Array(inputSize*inputSize*3);
        for(let i=0,j=0;i<d.length;i+=4){ a[j++]=d[i]/255; a[j++]=d[i+1]/255; a[j++]=d[i+2]/255; }
        const tImg=new ort.Tensor('float32',a,[1,inputSize,inputSize,3]);
        // Text: very model-specific; we try feeding a naive [1,77,512] zeros which some refined exporters ignore (class-agnostic)
        const txt = new Float32Array(77*512); // zeros
        const feeds={}; const names=session.inputNames||[];
        const imgName=names.find(n=>/image|input/i.test(n)) || names[0]; feeds[imgName]=tImg;
        const textName=names.find(n=>/text|prompt/i.test(n)); if(textName) feeds[textName]= new ort.Tensor('float32', txt, [1,77,512]);
        const outs=await session.run(feeds); const out=outs[Object.keys(outs)[0]];
        return tensorToMaskCanvas(out, img.width, img.height);
      }catch(e){ log('CLIPSeg failed:', e?.message||e); return null; }
    }

    /* Depth prediction */
    async function depthPredict(session,img,inputSize){
      const {tensor} = prepareDepthInput(img,inputSize);
      const inputName = session.inputNames?.[0]||'input';
      const outs = await session.run({[inputName]:tensor});
      const out = outs[Object.keys(outs)[0]];
      return toDepthCanvasAndMap(out,img.width,img.height);
    }
    function prepareDepthInput(img,size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d');
      const r=Math.min(size/img.width,size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r); const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
      x.fillStyle='#000'; x.fillRect(0,0,size,size); x.drawImage(img,dx,dy,nw,nh);
      const d=x.getImageData(0,0,size,size).data; const a=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ a[j++]=d[i]/255; a[j++]=d[i+1]/255; a[j++]=d[i+2]/255; }
      const t=new ort.Tensor('float32',a,[1,size,size,3]); return {tensor:t};
    }
    function toDepthCanvasAndMap(out,outW,outH){
      const dims=out.dims, data=out.data; let H=dims[dims.length-2], W=dims[dims.length-1]; if(!H||!W){ H=outW; W=outH; }
      let mn=Infinity,mx=-Infinity; for(let i=0;i<data.length;i++){ const v=data[i]; if(v<mn) mn=v; if(v>mx) mx=v; } const range=mx-mn||1;
      const s=document.createElement('canvas'); s.width=W; s.height=H; const sx=s.getContext('2d'); const id=sx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=(data[i]-mn)/range; const g=Math.round(255*v); const p=i*4; id.data[p]=g; id.data[p+1]=g; id.data[p+2]=g; id.data[p+3]=255; }
      sx.putImageData(id,0,0);
      const big=document.createElement('canvas'); big.width=outW; big.height=outH; big.getContext('2d').drawImage(s,0,0,outW,outH);
      // map
      const map=new Float32Array(outW*outH); const bd=big.getContext('2d').getImageData(0,0,outW,outH).data;
      for(let i=0,j=0;i<map.length;i++,j+=4) map[i]=bd[j]/255;
      return {canvas:big, map};
    }
    function syntheticDepth(img){
      const c=document.createElement('canvas'); c.width=img.width; c.height=img.height; const x=c.getContext('2d'); x.drawImage(img,0,0); const d=x.getImageData(0,0,c.width,c.height); const data=d.data;
      for(let i=0;i<data.length;i+=4){ const y=0.2126*data[i]+0.7152*data[i+1]+0.0722*data[i+2]; data[i]=data[i+1]=data[i+2]=y; data[i+3]=255; }
      x.putImageData(d,0,0);
      const map=new Float32Array(img.width*img.height); for(let i=0,j=0;i<map.length;i++,j+=4) map[i]=d.data[j]/255;
      return {canvas:c, map};
    }

    /* Variants: create 5 alternatives using depth band & morph tweaks */
    async function generateVariantsAndShow(){
      const base = state.ai.outputs.baseMask || lastMaskFromSelections();
      const depth = state.ai.outputs.depthMap;
      const W=state.image.width,H=state.image.height;
      const seed = state.ai.lastClick || {x:Math.round(W/2),y:Math.round(H/2)};

      const variants=[];
      if(!base){ // fallback: make one from worker seed to still show suggestions
        const fb = magicWandMask(state.image, seed.x, seed.y, state.tol/100, state.aggr);
        if(fb) variants.push({canvas:fb,label:'Auto'});
      }else{
        // produce 5 bands
        const bands=[0.04,0.06,0.08,0.10,0.13];
        for(let i=0;i<5;i++){
          const vMask = state.ai.refine? refineWithDepth(base, depth, W,H, seed, bands[i]) : depthBandMask(base, depth, W,H, seed, bands[i]);
          variants.push({canvas:vMask,label:`Band ${Math.round(bands[i]*100)}%`});
        }
      }
      state.ai.outputs.variants = variants;
      // render into UI
      dom.aiVariants.innerHTML='';
      variants.forEach((v,idx)=>{
        const cell=document.createElement('div'); cell.className='variant';
        const c=document.createElement('canvas'); c.width=152; c.height=Math.round(152*(H/W)); const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(v.canvas,0,0,c.width,c.height);
        const lab=document.createElement('label'); lab.textContent = v.label;
        cell.appendChild(c); cell.appendChild(lab);
        cell.addEventListener('click',()=> selectVariant(idx));
        dom.aiVariants.appendChild(cell);
      });
    }
    function selectVariant(idx){
      const items=[...dom.aiVariants.querySelectorAll('.variant')]; items.forEach(el=>el.classList.remove('active'));
      if(items[idx]) items[idx].classList.add('active');
      const chosen=state.ai.outputs.variants[idx]; if(chosen){ state.ai.outputs.finalMask = chosen.canvas; schedulePreviewRender(true); }
    }

    function depthBandMask(baseMaskCanvas, depthMap, W,H, seed, band){
      if(!depthMap) return baseMaskCanvas;
      // compute seed depth
      const sd = depthMap[seed.y*W + seed.x];
      const lo=Math.max(0, sd-band), hi=Math.min(1, sd+band);
      // intersect base with band
      const out=document.createElement('canvas'); out.width=W; out.height=H; const ox=out.getContext('2d');
      // band canvas
      const bandC=document.createElement('canvas'); bandC.width=W; bandC.height=H; const bx=bandC.getContext('2d'); const id=bx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=depthMap[i]; const ok=(v>=lo&&v<=hi)?255:0; const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=ok; } bx.putImageData(id,0,0);
      ox.drawImage(baseMaskCanvas,0,0); ox.globalCompositeOperation='destination-in'; ox.drawImage(bandC,0,0); ox.globalCompositeOperation='source-over';
      // slight blur to soften
      const soft = blurMask(out, 1.2); return soft;
    }

    function refineWithDepth(baseMaskCanvas, depthMap, W,H, seed, band){
      // depth band + slight dilation + intersection to tighten edges
      const banded = depthBandMask(baseMaskCanvas, depthMap, W,H, seed, band);
      const refined = blurMask(banded, 0.8);
      return refined;
    }

    function blurMask(maskCanvas, r){
      const W=maskCanvas.width,H=maskCanvas.height; const out=document.createElement('canvas'); out.width=W; out.height=H; const x=out.getContext('2d'); x.filter=`blur(${r}px)`; x.drawImage(maskCanvas,0,0); x.filter='none'; return out;
    }

    /* AI helpers */
    function setStatus(t){ dom.aiStatus.textContent=t; }

    /* Hotkeys */
    window.addEventListener('keydown',(e)=>{
      if(e.code==='Space' && !state.isPanning){ state.isPanning=true; dom.editorWrap.classList.add('panning'); }
      if((e.key==='Delete'||e.key==='Backspace') && state.activeIndex!==-1){ const removed=state.selections.splice(state.activeIndex,1)[0]; state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted selection:', removed?.type||''); }
      if(e.ctrlKey||e.metaKey){ if(e.key.toLowerCase()==='z'){ e.preventDefault(); history.undo(); } if(e.key.toLowerCase()==='y'){ e.preventDefault(); history.redo(); } }
      if(e.key.toLowerCase()==='s'){ setAIMode(false); setMode('lasso'); }
      if(e.key.toLowerCase()==='b'){ setAIMode(false); setMode('box'); }
      if(e.key.toLowerCase()==='w'){ setAIMode(false); setMode('autoWand'); }
      if(e.key.toLowerCase()==='g'){ setAIMode(false); setMode('autoSmart'); }
      if(e.key.toLowerCase()==='u'){ setAIMode(false); setMode('autoUltra'); }
      if(e.key.toLowerCase()==='e'){ setAIMode(false); setMode('protectEraser'); }
      if(e.key.toLowerCase()==='r'){ setAIMode(false); setMode('removeEraser'); }
    });
    window.addEventListener('keyup',(e)=>{ if(e.code==='Space'){ state.isPanning=false; dom.editorWrap.classList.remove('panning'); } });

    /* Small helpers */
    function hitBoxHandle(sel,x,y){
      const pad=8/state.transform.scale;
      const pts=[ ['nw',sel.x,sel.y], ['n',sel.x+sel.w/2,sel.y], ['ne',sel.x+sel.w,sel.y], ['e',sel.x+sel.w,sel.y+sel.h/2], ['se',sel.x+sel.w,sel.y+sel.h], ['s',sel.x+sel.w/2,sel.y+sel.h], ['sw',sel.x,sel.y+sel.h], ['w',sel.x,sel.y+sel.h/2] ];
      for(const [name,px,py] of pts){ if(Math.abs(x-px)<=pad && Math.abs(y-py)<=pad) return name; } return null;
    }

  })();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Color Splash Pro X ‚Äî AI Mode</title>

<!--
================================================================================
TECHNICAL SPEC SHEET (v1.19.0 ‚ÄúAI Mode solid + Variants + Pinned Settings‚Äù)

This preserves everything and ADDS/FIXES:

- AI MODE (solid)
  ‚Ä¢ AI Active switch in the header AI bar.
  ‚Ä¢ Segmentation models: YOLOv8n-seg, YOLO11n-seg, MobileSAM (point), CLIPSeg (prompt).
  ‚Ä¢ Depth models: MobileDepth (tiny), MiDaS-small, Depth-Anything-V2-Small.
  ‚Ä¢ Optional prompt input (shown for promptable models like CLIPSeg).
  ‚Ä¢ ‚ÄúUse‚Äù button or clicking the ORIGINAL runs the pipeline:
      1) Segment near click (or prompt), 2) estimate depth, 3) (optional) refine with fancy math.
  ‚Ä¢ Model downloads only when triggered (Use/click). We still support background preloading if you enable the small "Preload" switch.
  ‚Ä¢ Progress bar + logs show download and inference stages.
  ‚Ä¢ AI mask + depth thumbnails appear in the RIGHT sidebar (the old Settings/Logs moved).
  ‚Ä¢ 5 AI VARIANTS (mini-previews) generated and clickable to select.

- PINNED SETTINGS/LOGS PANEL (bottom-left gear)
  ‚Ä¢ Holds Feather/Tolerance/Filter controls + full scrollable logs.
  ‚Ä¢ The old header ‚ÄúToggle Logs‚Äù now opens this panel.

- DUAL MONOCLES
  ‚Ä¢ Left monocle shows ORIGINAL; Right monocle shows actual PREVIEW pixels.
  ‚Ä¢ Monocles hop to the opposite side when cursor gets close, then snap back.

- FAILSAFES
  ‚Ä¢ WebGPU ‚Üí WASM fallback, timeouts, robust shape guards, CORS failure handling.
  ‚Ä¢ If models fail, fallback to Worker EdgeGrow + synthetic luminance-based depth.

App version bump: APP_VERSION = "1.19.0"
================================================================================
-->

  <style>
    :root{
      --bg:#edf1f7;--panel:#fff;--text:#1c1e21;--muted:#606770;--primary:#1877f2;--primary-2:#166fe5;
      --border:#d7dbe1;--shadow:rgba(0,0,0,.08);--shadow-2:rgba(0,0,0,.14);
      --danger:#fa383e;--ok:#19a974;--warn:#ffb700;
      --chip:#f4f7ff;
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;overflow:hidden;
    }
    header{
      background:var(--panel);box-shadow:0 2px 6px var(--shadow);padding:.55rem .8rem;display:flex;align-items:center;gap:.5rem;z-index:4;position:relative;
    }
    .brand{font-weight:800;color:var(--primary);letter-spacing:.2px}
    .badge{margin-left:auto;font-size:.8rem;color:#4a4f57;background:#eef3ff;border:1px solid #dfe7ff;padding:.2rem .5rem;border-radius:6px}
    .toolbar{display:flex;flex-wrap:wrap;gap:.4rem;align-items:center}
    .group{display:flex;gap:.4rem;align-items:center}
    button{
      padding:.42rem .7rem;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:default;
      font-weight:600;font-size:.9rem;display:inline-flex;gap:.42rem;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,.02);
      transition:transform .05s ease, border-color .2s, background .2s, color .2s;
    }
    button:hover:not(:disabled){border-color:var(--primary);background:#f6faff}
    button:active{transform:translateY(1px)}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    button.primary:hover{background:var(--primary-2);color:#fff}
    button.active{background:var(--primary);border-color:var(--primary);color:#fff}
    button.danger{border-color:#ffd2d6;background:#fff0f1;color:#b00020}
    button:disabled{opacity:.6;cursor:not-allowed}
    .icon{font-size:1.05rem}

    .chip{padding:.28rem .5rem;border:1px solid var(--border);border-radius:999px;background:var(--chip);font-size:.82rem;color:#334155}
    .switch{display:inline-flex;gap:.4rem;align-items:center;padding:.2rem .5rem;border:1px solid var(--border);border-radius:8px;background:#fff}

    /* Layout */
    .shell{flex:1;display:flex;flex-direction:column;gap:10px;padding:10px;overflow:hidden;}
    .row{display:grid;grid-template-columns:8fr 7fr;gap:10px;flex:1 1 auto;min-height:0;}
    .panel{background:var(--panel);border-radius:12px;box-shadow:0 2px 8px var(--shadow);display:flex;flex-direction:column;min-height:0;overflow:hidden;position:relative;}
    .panel-h{padding:.5rem .75rem;border-bottom:1px solid var(--border);font-weight:700;color:var(--muted);display:flex;align-items:center;justify-content:center;gap:.5rem}
    .panel-c{flex:1;min-height:0;position:relative;background:#e9eef6;display:flex;align-items:center;justify-content:center;overflow:hidden}

    .placeholder{color:var(--muted);font-weight:600;opacity:.85;pointer-events:none}
    .canvas-wrap{position:relative;width:100%;height:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;cursor:default;}
    .canvas-wrap.panning{cursor:grabbing}
    .canvas-wrap.drop-hover{outline:3px dashed var(--primary); outline-offset:-8px; background:rgba(24,119,242,0.1)}
    canvas{display:block;background:#fff}
    #editor-canvas{position:absolute;transform-origin:top left}
    #preview-canvas{position:absolute;top:0;left:0}

    /* Dual Monocles */
    .monocle{
      position:absolute;width:148px;height:148px;background:#fff;border:2px solid var(--border);
      border-radius:10px;box-shadow:0 6px 14px var(--shadow-2);overflow:hidden;display:none;z-index:3;
    }
    .monocle canvas{width:100%;height:100%;display:block;background:#000}
    #monocle-left{ top:10px; left:10px; }
    #monocle-right{ top:10px; right:10px; }

    /* Bottom strip */
    .bottom{display:grid;grid-template-columns:8fr 3fr;gap:10px;min-height:92px;max-height:26vh;}
    .presets.panel{min-height:92px}
    .presets-grid{display:grid;grid-template-columns:repeat(10,1fr);gap:8px;padding:10px;align-items:end;justify-items:center}
    .preset{cursor:pointer;text-align:center;width:100%;max-width:84px;margin:0 auto}
    .preset canvas{width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;box-shadow:0 1px 3px var(--shadow);transition:all .15s}
    .preset:hover canvas{transform:translateY(-2px)}
    .preset.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .preset label{display:block;margin-top:4px;font-size:.72rem;color:var(--muted);text-align:center}

    /* RIGHT sidebar now shows AI thumbnails + variants (Settings/Logs moved to pin panel) */
    .side.panel{min-height:92px}
    .side-c{display:flex;flex-direction:column;min-height:0;}
    .ai-thumbs{padding:8px 10px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:flex-start;overflow-x:auto}
    .ai-thumb{display:flex;flex-direction:column;align-items:center;gap:4px}
    .ai-thumb canvas{width:152px;height:auto;max-height:96px;background:#f6f8ff;border-radius:10px;border:1px solid var(--border);image-rendering:pixelated}
    .ai-thumb .cap{font-size:.75rem;color:#475569}

    .variants{flex:1;display:flex;flex-direction:column;min-height:0;}
    .variants-h{padding:6px 10px;border-bottom:1px solid var(--border);font-weight:700;color:#64748b}
    .variants-grid{flex:1;padding:10px;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;overflow:auto}
    .variant{cursor:pointer;text-align:center}
    .variant canvas{width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;box-shadow:0 1px 3px var(--shadow);image-rendering:pixelated}
    .variant.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .variant label{display:block;margin-top:4px;font-size:.72rem;color:#64748b}

    /* Progress bar */
    .progress-wrap{position:absolute;left:12px;right:12px;bottom:12px;height:8px;border-radius:6px;background:#eef2ff;border:1px solid #dde6ff;overflow:hidden; opacity:0; transition: opacity 0.2s; pointer-events:none;}
    .progress-wrap.visible{opacity:1;}
    .progress{height:100%;width:0%;background:linear-gradient(90deg,#7aa2ff,#1877f2);transition:width .1s}

    .version-pin{position:fixed;top:8px;right:8px;background:#101828;color:#fff;font-size:.75rem;padding:.25rem .5rem;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.18);z-index:10;opacity:.9}

    /* AI BAR (header bottom) */
    .ai-bar{position:absolute;left:0;right:0;bottom:-56px;background:#fff;border-top:1px solid var(--border);display:none;gap:.6rem;align-items:center;padding:.45rem .8rem;z-index:3;flex-wrap:wrap}
    .ai-bar.visible{display:flex}
    .ai-bar select,.ai-bar input[type=text]{padding:.32rem .5rem;border:1px solid var(--border);border-radius:8px;background:#fff;font-weight:600}
    .ai-bar .spacer{flex:1}

    /* Pinned FAB + Panel (Settings + Logs) */
    #pinFab{position:fixed;left:12px;bottom:12px;z-index:8;border-radius:999px;padding:.6rem .75rem;background:#1877f2;color:#fff;border:none;box-shadow:0 6px 14px rgba(0,0,0,.18);cursor:pointer;font-weight:800}
    #pinPanel{position:fixed;left:12px;bottom:64px;width:384px;height:60vh;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 12px 32px rgba(0,0,0,.18);display:none;flex-direction:column;overflow:hidden;z-index:9}
    #pinPanel.visible{display:flex}
    #pinPanel header{box-shadow:none;padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #pinPanel .body{flex:1;display:grid;grid-template-rows:auto 1fr;}
    #pinPanel .cfg{padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #pinPanel .cfg .row{display:flex;gap:.5rem;align-items:center;margin:.25rem 0}
    #pinPanel .ilog{overflow:auto;background:#fff}
    #pinPanel .ilog .line{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.84rem;color:#1f2937;padding:.25rem .5rem;border-bottom:1px dashed #eef2ff;white-space:pre-wrap}

    .range-row{display:flex;align-items:center;gap:10px}
    .range-row input[type=range]{flex:1}

    .hidden{display:none!important}
  </style>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <header>
    <div class="brand">Color Splash Pro X</div>

    <div class="toolbar">
      <div class="group">
        <button id="uploadBtn" class="primary"><span class="icon">üì§</span>Upload</button>
        <button id="saveBtn" title="Save project JSON" disabled>üíæ Save</button>
        <button id="loadBtn" title="Load project JSON">üìÇ Load</button>
        <button id="startOverBtn" class="danger" title="Clear image & selections" disabled>üßπ Start Over</button>
      </div>
      <div class="group">
        <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>‚Ü©Ô∏è Undo</button>
        <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>‚Ü™Ô∏è Redo</button>
      </div>
      <div class="group">
        <button id="modeLassoBtn" class="active" title="Smart Select (Lasso) (S)">‚ú® Lasso</button>
        <button id="newLassoBtn" title="Add new lasso object">‚ûï New Lasso</button>
        <button id="modeBoxBtn" title="Box Select (B)">üî≤ Box</button>
        <button id="deleteSelectionBtn" title="Delete active selection (Del)" disabled>üóëÔ∏è Delete</button>
      </div>
      <div class="group">
        <button id="autoWandBtn" title="Auto Wand (W)">ü™Ñ Auto Wand</button>
        <button id="autoSmartBtn" title="Auto Smart (G)">üß† Auto Smart</button>
        <button id="autoUltraBtn" title="Auto Ultra (U)">üß¨ Auto Ultra</button>
        <button id="autoObjectsBtn" title="Auto Objects (demo)">üõ∞Ô∏è Auto Objects</button>
      </div>
      <div class="group">
        <button id="protectEraserBtn" title="Paint protected areas (E)">üõ°Ô∏è Protect Eraser</button>
        <button id="removeEraserBtn" title="Erase colorized mask (R)">üßΩ Remove Eraser</button>
      </div>
      <div class="group">
        <button id="resetViewBtn" title="Reset pan/zoom & fit">üéØ Reset View</button>
        <button id="renderNowBtn" title="Render immediately">‚ö° Render Now</button>
        <button id="downloadBtn" title="Download final image (PNG)">‚¨áÔ∏è Download</button>
      </div>

      <!-- AI Mode -->
      <div class="group">
        <button id="aiModeBtn" title="Toggle AI Mode">ü§ñ AI Mode</button>
      </div>
      <div class="group">
        <button id="toggleLogsBtn" title="Open Settings & Logs (Pinned)">üõ†Ô∏è Settings</button>
      </div>
    </div>

    <span class="badge" id="versionBadge">v?</span>

    <!-- AI controls bar under header -->
    <div id="aiBar" class="ai-bar">
      <span class="chip">AI Controls</span>

      <span class="switch"><input id="aiActiveSwitch" type="checkbox"/><label for="aiActiveSwitch">AI Active</label></span>

      <label>Segmentation:</label>
      <select id="aiSegModel">
        <option value="yolov8n-seg">YOLOv8n-seg (~13MB)</option>
        <option value="yolo11n-seg">YOLO11n-seg (~6MB)</option>
        <option value="mobile-sam">MobileSAM (point)</option>
        <option value="clipseg">CLIPSeg (prompt)</option>
      </select>

      <label>Depth:</label>
      <select id="aiDepthModel">
        <option value="mobiledepth">MobileDepth (tiny)</option>
        <option value="midas-small">MiDaS-small</option>
        <option value="da-v2-small">Depth Anything V2 Small</option>
      </select>

      <input id="aiPrompt" type="text" class="hidden" placeholder="Prompt (for CLIPSeg)‚Ä¶" />

      <span class="switch"><input id="aiRefine" type="checkbox"/><label for="aiRefine">Refine w/ Fancy Math</label></span>
      <span class="switch"><input id="aiPreload" type="checkbox" checked/><label for="aiPreload">Preload</label></span>

      <button id="aiUseBtn" class="primary">üöÄ Use</button>
      <div class="spacer"></div>
      <span id="aiStatus" class="chip">idle</span>
    </div>
  </header>

  <div class="version-pin" id="versionPin">v?</div>

  <div class="shell">
    <div class="row">
      <!-- EDITOR -->
      <section class="panel" id="editor-panel">
        <div class="panel-h">EDITOR ‚Äî Original (Space = Pan ¬∑ Wheel = Zoom)</div>
        <div class="panel-c">
          <div id="editor-wrap" class="canvas-wrap">
            <canvas id="editor-canvas"></canvas>
            <div id="monocle-left" class="monocle"><canvas id="monocle-left-canvas"></canvas></div>
          </div>
          <div id="editor-empty" class="placeholder">Drop an image here or click ‚ÄúUpload‚Äù</div>
          <div class="progress-wrap" id="progressEditor"><div class="progress" id="progressBar"></div></div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel" id="preview-panel">
        <div class="panel-h">LIVE PREVIEW</div>
        <div class="panel-c" id="preview-container">
          <div id="preview-wrap" class="canvas-wrap">
            <canvas id="preview-canvas"></canvas>
            <div id="monocle-right" class="monocle"><canvas id="monocle-right-canvas"></canvas></div>
          </div>
          <div id="preview-empty" class="placeholder">Your result will appear here</div>
        </div>
      </section>
    </div>

    <div class="bottom">
      <!-- PRESETS -->
      <section class="presets panel">
        <div class="panel-h">PRESET GALLERY (click to apply)</div>
        <div id="presets" class="presets-grid"></div>
      </section>

      <!-- RIGHT side: AI thumbnails + variants -->
      <section class="side panel">
        <div class="side-c">
          <div class="ai-thumbs">
            <div class="ai-thumb">
              <canvas id="aiMaskThumb" width="152" height="96"></canvas>
              <div class="cap">AI Object Mask</div>
            </div>
            <div class="ai-thumb">
              <canvas id="aiDepthThumb" width="152" height="96"></canvas>
              <div class="cap">Depth Map</div>
            </div>
          </div>
          <div class="variants">
            <div class="variants-h">AI Variants (click to select)</div>
            <div id="aiVariants" class="variants-grid">
              <!-- 5 variant cells inserted dynamically -->
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Pinned panel (gear) for Settings + Logs -->
  <button id="pinFab" title="Settings & Logs">‚öôÔ∏è</button>
  <div id="pinPanel">
    <header><strong>‚öôÔ∏è Settings & Logs</strong></header>
    <div class="body">
      <div class="cfg">
        <div class="row"><span class="chip">Runtime</span><span id="runtimeChip" class="chip">‚Äî</span></div>
        <div class="row range-row">
          <label for="aggrRange" style="width:110px">Feather</label>
          <input type="range" id="aggrRange" min="0" max="100" value="35"/><span id="aggrVal">35</span>
        </div>
        <div class="row range-row">
          <label for="tolRange" style="width:110px">Tolerance</label>
          <input type="range" id="tolRange" min="0" max="100" value="25"/><span id="tolVal">25</span>
        </div>
        <div class="row range-row">
          <label for="fltRange" style="width:110px">Filter Strength</label>
          <input type="range" id="fltRange" min="0" max="100" value="100"/><span id="fltVal">100%</span>
        </div>
        <div class="row">
          <button id="clearLogsBtn">Clear Logs</button>
        </div>
        <div class="row"><small style="color:#64748b">Tip: In AI Mode, click the Original to set the seed. ‚ÄúUse‚Äù runs the current models.</small></div>
      </div>
      <div id="aiLogBody" class="ilog"></div>
    </div>
  </div>

  <!-- hidden inputs -->
  <input type="file" id="fileInput" accept="image/*" class="hidden"/>
  <input type="file" id="loadInput" accept=".json,.txt" class="hidden"/>

  <!-- Segmentation Worker (unchanged core, our reliable fallback/refiner) -->
  <script id="seg-worker-src" type="text/plain">
/* seg-worker.js ‚Äî minimal, fast, deterministic */
self.postMessage({type:'ready'});
self.onmessage = (e)=>{
  const {type, payload, reqId} = e.data || {};
  if(type!=='segment') return;
  try{
    const {tool, seedX, seedY, tol01, aggr, width, height, image} = payload;
    const data = image.data;
    const N = width*height;
    const gray = new Float32Array(N);
    for(let i=0,j=0;i<N;i++,j+=4){ gray[i]=0.2126*data[j]+0.7152*data[j+1]+0.0722*data[j+2]; }
    const grad = sobelMag(gray,width,height);
    const gradN = normalize01(grad);
    let alpha;
    const params = defaultsEdgeGrow(tol01,aggr);
    alpha = edgeAwareGrowMask(data,width,height,seedX,seedY,gradN,params);
    if(tool==='autoUltra'){
      paintDisk(alpha,width,height,seedX,seedY,Math.max(6,Math.round(Math.min(width,height)*0.01)),255);
    }
    returnMask(alpha,width,height,{tool:(tool==='autoUltra'?'grabcutLite':'edgeGrow'),seedX,seedY,params},reqId);
  }catch(err){
    self.postMessage({type:'error',reqId,payload:String(err)});
  }
};
function normalize01(arr){let mn=Infinity,mx=-Infinity;for(const v of arr){if(v<mn)mn=v;if(v>mx)mx=v;}const o=new Float32Array(arr.length);const d=mx-mn||1;for(let i=0;i<arr.length;i++)o[i]=(arr[i]-mn)/d;return o;}
function sobelMag(g,W,H){const o=new Float32Array(W*H);for(let y=1;y<H-1;y++){for(let x=1;x<W-1;x++){const i=y*W+x;const tl=(y-1)*W+(x-1),t=(y-1)*W+x,tr=(y-1)*W+(x+1);const ml=y*W+(x-1),mr=y*W+(x+1);const bl=(y+1)*W+(x-1),b=(y+1)*W+x,br=(y+1)*W+(x+1);const gx=-g[tl]-2*g[ml]-g[bl]+g[tr]+2*g[mr]+g[br];const gy=-g[tl]-2*g[t]-g[tr]+g[bl]+2*g[b]+g[br];o[i]=Math.hypot(gx,gy);} }return o;}
function defaultsEdgeGrow(tol01,aggr){return{wc:1.0,we:2.0+1.2*tol01,wd:0.02,tau:18+160*tol01+aggr*0.6,diag:true};}
function edgeAwareGrowMask(rgbU8,W,H,sx,sy,grad01,p){
  const idx=(x,y)=>y*W+x;const N=W*H;
  const cost=new Float32Array(N);cost.fill(1e20);
  const seen=new Uint8Array(N);
  const hc=new Float32Array(N),hi=new Int32Array(N);let hs=0;
  function push(c,i){let k=hs++;hc[k]=c;hi[k]=i;while(k){const pk=(k-1)>>1;if(hc[pk]<=c)break;swap(k,pk);k=pk;}}
  function pop(){if(!hs)return[-1,-1];const c=hc[0],i=hi[0];const ck=hc[--hs],ik=hi[hs];if(hs){hc[0]=ck;hi[0]=ik;down(0);}return[c,i];}
  function swap(a,b){const tc=hc[a];hc[a]=hc[b];hc[b]=tc;const ti=hi[a];hi[a]=hi[b];hi[b]=ti;}
  function down(k){for(;;){let l=k*2+1,r=l+1,s=k;if(l<hs&&hc[l]<hc[s])s=l;if(r<hs&&hc[r]<hc[s])s=r;if(s===k)break;swap(k,s);k=s;}}
  const R=new Float32Array(N),G=new Float32Array(N),B=new Float32Array(N);
  for(let i=0,j=0;i<N;i++,j+=4){R[i]=rgbU8[j];G[i]=rgbU8[j+1];B[i]=rgbU8[j+2];}
  const seed=idx(Math.max(0,Math.min(W-1,sx)),Math.max(0,Math.min(H-1,sy)));cost[seed]=0;push(0,seed);
  const del=p.diag?[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]:[[1,0],[-1,0],[0,1],[0,-1]];
  while(hs){const [c,i]=pop();if(i<0)break;if(seen[i])continue;seen[i]=1;if(c>p.tau)break;const x=i%W,y=(i-x)/W;
    for(const d of del){const nx=x+d[0],ny=y+d[1];if(nx<0||ny<0||nx>=W||ny>=H)continue;const j=idx(nx,ny);if(seen[j])continue;
      const dR=R[i]-R[j],dG=G[i]-G[j],dB=B[i]-B[j];const dE=Math.hypot(dR,dG,dB);
      const eStop=1.0-(grad01[j]/(grad01[j]+1e-6));const step=1.0*dE+(2.0+1.2)*eStop+0.02*((d[0]&&d[1])?Math.SQRT2:1.0);
      const nc=c+step;if(nc<cost[j]&&nc<=p.tau){cost[j]=nc;push(nc,j);}}}
  const a=new Uint8ClampedArray(N);const t0=0.92*p.tau,t1=p.tau;for(let i=0;i<N;i++){const ci=cost[i];if(ci>=1e18){a[i]=0;continue;}
    if(ci<=t0){a[i]=255;} else if(ci>=t1){a[i]=0;} else {const v=1-(ci-t0)/(t1-t0);a[i]=Math.round(255*v);} }
  return a;
}
function paintDisk(alpha,W,H,cx,cy,r,v){
  const r2=r*r;for(let y=Math.max(0,cy-r);y<Math.min(H,cy+r+1);y++){for(let x=Math.max(0,cx-r);x<Math.min(W,cx+r+1);x++){const dx=x-cx,dy=y-cy;if(dx*dx+dy*dy<=r2){alpha[y*W+x]=v;}}}
}
function returnMask(alphaU8,width,height,generator,reqId){
  self.postMessage({type:'mask',reqId,payload:{width,height,alphaU8,generator}},[alphaU8.buffer]);
}
  </script>

  <script>
  (function(){
    'use strict';

    const APP_VERSION = "1.19.0";
    const $ = (id)=>document.getElementById(id);
    $('versionBadge').textContent = APP_VERSION;
    $('versionPin').textContent = APP_VERSION;

    /* DOM refs */
    const dom = {
      // Top bar
      uploadBtn: $('uploadBtn'), saveBtn: $('saveBtn'), loadBtn: $('loadBtn'), startOverBtn: $('startOverBtn'),
      undoBtn: $('undoBtn'), redoBtn: $('redoBtn'),
      modeLassoBtn: $('modeLassoBtn'), newLassoBtn: $('newLassoBtn'), modeBoxBtn: $('modeBoxBtn'),
      deleteSelectionBtn: $('deleteSelectionBtn'), renderNowBtn: $('renderNowBtn'),
      autoWandBtn: $('autoWandBtn'), autoSmartBtn: $('autoSmartBtn'), autoUltraBtn: $('autoUltraBtn'), autoObjectsBtn: $('autoObjectsBtn'),
      protectEraserBtn: $('protectEraserBtn'), removeEraserBtn: $('removeEraserBtn'),
      resetViewBtn: $('resetViewBtn'), downloadBtn: $('downloadBtn'),
      aiModeBtn: $('aiModeBtn'), toggleLogsBtn: $('toggleLogsBtn'),

      // AI bar
      aiBar: $('aiBar'), aiActiveSwitch: $('aiActiveSwitch'),
      aiSegModel: $('aiSegModel'), aiDepthModel: $('aiDepthModel'), aiPrompt: $('aiPrompt'),
      aiRefine: $('aiRefine'), aiPreload: $('aiPreload'), aiUseBtn: $('aiUseBtn'), aiStatus: $('aiStatus'),

      // Editor / Preview
      fileInput: $('fileInput'), loadInput: $('loadInput'),
      editorPanel: $('editor-panel'), editorWrap: $('editor-wrap'), editorCanvas: $('editor-canvas'), editorEmpty: $('editor-empty'),
      previewPanel: $('preview-panel'), previewWrap: $('preview-wrap'), previewContainer: $('preview-container'), previewCanvas: $('preview-canvas'), previewEmpty: $('preview-empty'),

      // Monocles
      monoLeft: $('monocle-left'), monoLeftCanvas: $('monocle-left-canvas'),
      monoRight: $('monocle-right'), monoRightCanvas: $('monocle-right-canvas'),

      // Right sidebar AI thumbnails + variants
      aiMaskThumb: $('aiMaskThumb'), aiDepthThumb: $('aiDepthThumb'), aiVariants: $('aiVariants'),

      // Presets
      presets: $('presets'),

      // Progress
      progressWrap: $('progressEditor'), progressBar: $('progressBar'),

      // Pinned panel
      pinFab: $('pinFab'), pinPanel: $('pinPanel'), aiLogBody: $('aiLogBody'), runtimeChip: $('runtimeChip'),
      aggrRange: $('aggrRange'), aggrVal: $('aggrVal'),
      tolRange: $('tolRange'), tolVal: $('tolVal'),
      fltRange: $('fltRange'), fltVal: $('fltVal'),
      clearLogsBtn: $('clearLogsBtn'),
    };

    /* Logging (scrollable, mirrored in pinned panel only) */
    const log = (...args)=>{
      const text = `[${new Date().toLocaleTimeString()}] ` + args.join(' ');
      const l = document.createElement('div'); l.className='line'; l.textContent=text;
      dom.aiLogBody.appendChild(l);
      dom.aiLogBody.scrollTop = dom.aiLogBody.scrollHeight;
      console.log('[LOG]', ...args);
    };

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const debounce=(fn,ms)=>{let t;return (...x)=>{clearTimeout(t);t=setTimeout(()=>fn(...x),ms);}};

    /* STATE */
    const state = {
      image: null,
      selections: [],
      activeIndex: -1,
      mode: 'lasso',
      modeGroup: 'manual',
      transform: {x:0,y:0,scale:1},
      isPanning:false,
      drag:{active:false,startX:0,startY:0,kind:null,handle:null,moved:false,snapshot:null},
      history:[], histIndex:-1,
      activePreset:0,
      filters:[
        {name:'Classic',   css:(s)=>`grayscale(${s}%)`,                                                aggr:20},
        {name:'High Pop',  css:(s)=>`grayscale(${s}%) contrast(1.35) brightness(1.05)`,                aggr:30},
        {name:'Soft Film', css:(s)=>`grayscale(${s}%) brightness(1.03) contrast(1.08) saturate(.9)`,   aggr:35},
        {name:'Crunchy',   css:(s)=>`grayscale(${s}%) contrast(1.55)`,                                 aggr:45},
        {name:'Dreamy',    css:(s)=>`grayscale(${s}%) blur(0.6px) brightness(1.06)`,                   aggr:60},
        {name:'Neutral',   css:(s)=>`grayscale(${s}%) brightness(1.02)`,                               aggr:25}
      ],
      aggr:35, tol:25, filtStrength:100,
      brush:{size:28, hard:0.9},
      rendering:false,
      thumbnailsReady:false,

      ai:{
        active:false,
        segModel:'yolov8n-seg',
        depthModel:'mobiledepth',
        refine:false,
        preload:true,
        prompt:'',
        lastClick:null, // {x,y} in image coords
        sessions:{},    // key -> ort.InferenceSession
        outputs:{
          baseMask:null,     // canvas
          depthCanvas:null,  // canvas
          depthMap:null,     // Float32Array
          finalMask:null,    // canvas (selected variant)
          variants:[],       // [{canvas,label}], 5 items
        }
      }
    };

    /* Model registry (swap URLs to your mirrors if needed) */
    const MODEL_URLS = {
      // Segmentation
      'yolov8n-seg': {
        url:'https://huggingface.co/onnx-community/ultralytics-yolov8/resolve/main/yolov8n-seg.onnx',
        type:'seg-yolo', inputSize:640, sizeHintMB:13.2
      },
      'yolo11n-seg': {
        url:'https://huggingface.co/keremberke/yolo11n-seg-onnx/resolve/main/model.onnx',
        type:'seg-yolo', inputSize:640, sizeHintMB:6.0
      },
      'mobile-sam': {
        url:'https://huggingface.co/ziqiangxu/MobileSAM-onnx/resolve/main/mobile_sam.onnx',
        type:'seg-sam', inputSize:512, sizeHintMB:50.3
      },
      'clipseg': {
        url:'https://huggingface.co/CiaraRowles/clipseg-rd64-refined/resolve/main/clipseg-rd64-refined.onnx',
        type:'seg-clipseg', inputSize:352, sizeHintMB:52.0
      },
      // Depth
      'mobiledepth': {
        url:'https://huggingface.co/apple/ml-depth-pro/resolve/main/mobiledepth_tiny.onnx',
        type:'depth', inputSize:256, sizeHintMB:1.4
      },
      'midas-small': {
        url:'https://huggingface.co/onnx-community/MiDaS/resolve/main/midas_small.onnx',
        type:'depth', inputSize:256, sizeHintMB:63.0
      },
      'da-v2-small': {
        url:'https://huggingface.co/depth-anything/Depth-Anything-V2-Small/resolve/main/depth_anything_v2_small.onnx',
        type:'depth', inputSize:518, sizeHintMB:99.0
      }
    };

    /* Progress bar */
    let progressTimer=null, progressTarget=78;
    function startProgress(){
      dom.progressWrap.classList.add('visible');
      let p=0; dom.progressBar.style.width='0%';
      clearInterval(progressTimer);
      progressTimer=setInterval(()=>{p=clamp(p+12,0,progressTarget);dom.progressBar.style.width=p+'%';},60);
    }
    function finishProgress(){
      clearInterval(progressTimer); progressTimer=null;
      dom.progressBar.style.width='100%';
      setTimeout(()=>{dom.progressWrap.classList.remove('visible'); dom.progressBar.style.width='0%';},280);
    }

    /* Worker (built-in) */
    let segWorker=null, segReady=false;
    function initSegWorker(){
      if(segWorker) return;
      try{
        const src=$('seg-worker-src').textContent;
        const blob=new Blob([src],{type:'application/javascript'});
        const url=URL.createObjectURL(blob);
        segWorker=new Worker(url);
        segWorker.onmessage=(e)=>{
          const {type,payload}=e.data||{};
          if(type==='ready'){ segReady=true; log('Seg worker ready.'); return; }
          if(type==='error'){ log('Worker error:', payload); finishProgress(); return; }
          if(type==='mask'){
            const cnv=document.createElement('canvas');
            cnv.width=payload.width; cnv.height=payload.height;
            const ctx=cnv.getContext('2d');
            const id=ctx.createImageData(payload.width,payload.height);
            for(let i=0,j=0;i<id.data.length;i+=4,j++){
              id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=payload.alphaU8[j];
            }
            ctx.putImageData(id,0,0);
            state.selections.push({type:'mask', maskCanvas:cnv, generator:{...payload.generator,origin:'worker'}});
            state.activeIndex=state.selections.length-1;
            editor.draw(); schedulePreviewRender(true); history.save(); finishProgress();
            log('Mask (worker) added:', payload.generator?.tool||'');
          }
        };
      }catch(err){ log('Worker init failed:', String(err)); }
    }

    function requestSegMask(tool, sx, sy, tol, aggr){
      return new Promise((resolve)=>{
        const W=state.image.width, H=state.image.height;
        const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H;
        const tx=tmp.getContext('2d'); tx.drawImage(state.image,0,0);
        const imgData=tx.getImageData(0,0,W,H);
        const reqId=Math.random().toString(36).slice(2);
        segWorker.postMessage({type:'segment',reqId,payload:{tool,seedX:sx,seedY:sy,tol01:clamp(tol/100,0,1),aggr,width:W,height:H,image:imgData}},[imgData.data.buffer]);
        resolve();
      });
    }

    /* Editor */
    const editor={
      c:dom.editorCanvas, ctx:dom.editorCanvas.getContext('2d'),
      updateSize(){ const w=dom.editorWrap.clientWidth,h=dom.editorWrap.clientHeight; this.c.width=w; this.c.height=h; },
      imgToCanvasSpace(clientX,clientY){
        const r=this.c.getBoundingClientRect();
        const x=(clientX - r.left - state.transform.x)/state.transform.scale;
        const y=(clientY - r.top  - state.transform.y)/state.transform.scale;
        return {x,y};
      },
      draw(){
        if(!state.image){ this.ctx.clearRect(0,0,this.c.width,this.c.height); return; }
        const {ctx,c}=this; ctx.clearRect(0,0,c.width,c.height);
        ctx.save(); ctx.translate(state.transform.x,state.transform.y); ctx.scale(state.transform.scale,state.transform.scale);
        ctx.drawImage(state.image,0,0);

        state.selections.forEach((sel,i)=>{
          const active=i===state.activeIndex;
          ctx.save();
          ctx.lineWidth=active?2.5/state.transform.scale:1.5/state.transform.scale;
          ctx.strokeStyle=active?'#1877f2':'rgba(0,0,0,.45)';
          ctx.fillStyle=active?'rgba(24,119,242,.08)':'rgba(255,255,255,.18)';
          ctx.setLineDash(active?[]:[6/state.transform.scale,4/state.transform.scale]);
          if(sel.type==='box'){
            ctx.strokeRect(sel.x,sel.y,sel.w,sel.h); ctx.fillRect(sel.x,sel.y,sel.w,sel.h); if(active) drawBoxHandles(ctx,sel);
          }else if(sel.type==='lasso'){
            ctx.beginPath(); sel.points.forEach((p,idx)=> idx?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.closePath(); ctx.stroke(); ctx.fill();
          }else if((sel.type==='mask'||sel.type==='protect')&&sel.maskCanvas){
            ctx.globalAlpha=active?0.25:0.15; ctx.drawImage(sel.maskCanvas,0,0); ctx.globalAlpha=1;
            const edge=edgeFromMask(sel.maskCanvas,1); if(edge){ ctx.save(); ctx.strokeStyle=sel.type==='protect'?'#b00020':(active?'#1877f2':'rgba(0,0,0,.45)'); ctx.lineWidth=active?2.0/state.transform.scale:1.2/state.transform.scale; ctx.drawImage(edge,0,0); ctx.restore(); }
          }
          ctx.restore();
        });
        ctx.restore();
      }
    };

    /* Preview */
    const preview={
      c:dom.previewCanvas, ctx:dom.previewCanvas.getContext('2d'),
      layout(){
        if(!state.image) return;
        const rect=dom.previewContainer.getBoundingClientRect();
        const availW=Math.max(0,rect.width), availH=Math.max(0,rect.height);
        const aspect=state.image.width/state.image.height;
        let w=availW,h=w/aspect; if(h>availH){ h=availH; w=h*aspect; }
        this.c.width=Math.max(1,Math.round(w)); this.c.height=Math.max(1,Math.round(h));
        dom.previewCanvas.style.left=((availW-this.c.width)/2)+'px';
        dom.previewCanvas.style.top =((availH-this.c.height)/2)+'px';
      },
      render(){
        if(!state.image) return;
        const fullMask=buildFullMaskCanvas();
        const ctx=this.ctx; ctx.clearRect(0,0,this.c.width,this.c.height);
        const cssFilter=state.filters[state.activePreset].css(state.filtStrength);
        ctx.save(); ctx.filter=cssFilter; ctx.drawImage(state.image,0,0,this.c.width,this.c.height); ctx.restore();
        const colored=document.createElement('canvas'); colored.width=state.image.width; colored.height=state.image.height;
        const cctx=colored.getContext('2d'); cctx.drawImage(state.image,0,0); cctx.globalCompositeOperation='destination-in'; cctx.drawImage(fullMask,0,0);
        ctx.drawImage(colored,0,0,this.c.width,this.c.height);
      }
    };

    function buildFullMaskCanvas(){
      const m=document.createElement('canvas'); const W=state.image.width,H=state.image.height; m.width=W; m.height=H; const mctx=m.getContext('2d');
      mctx.fillStyle='#fff';
      state.selections.forEach(sel=>{
        if(sel.type==='box'){ mctx.fillRect(sel.x,sel.y,sel.w,sel.h); }
        else if(sel.type==='lasso'){ mctx.beginPath(); sel.points.forEach((p,i)=> i?mctx.lineTo(p.x,p.y):mctx.moveTo(p.x,p.y)); mctx.closePath(); mctx.fill(); }
        else if(sel.type==='mask'&&sel.maskCanvas){ mctx.drawImage(sel.maskCanvas,0,0); }
      });
      // subtract protects
      state.selections.forEach(sel=>{
        if(sel.type==='protect'&&sel.maskCanvas){ mctx.globalCompositeOperation='destination-out'; mctx.drawImage(sel.maskCanvas,0,0); mctx.globalCompositeOperation='source-over'; }
      });
      // AI final mask (if AI active)
      if(state.ai.active && state.ai.outputs.finalMask){ mctx.drawImage(state.ai.outputs.finalMask,0,0); }
      const blurPx=Math.round(clamp(state.aggr,0,100)*0.22);
      if(blurPx>0){ const t=document.createElement('canvas'); t.width=W; t.height=H; const tx=t.getContext('2d'); tx.filter=`blur(${blurPx}px)`; tx.drawImage(m,0,0); mctx.clearRect(0,0,W,H); mctx.drawImage(t,0,0); }
      return m;
    }

    /* Presets */
    function renderPresets(lazy=false){
      if(!state.image){
        dom.presets.innerHTML=''; for(let i=0;i<state.filters.length;i++){ const item=document.createElement('div'); item.className='preset'; item.innerHTML= `<canvas width="84" height="60"></canvas><label>${state.filters[i].name}</label>`; dom.presets.appendChild(item); }
        return;
      }
      const doRender=()=>{
        dom.presets.innerHTML='';
        state.filters.forEach((flt,idx)=>{
          const item=document.createElement('div'); item.className='preset'+(idx===state.activePreset?' active':''); item.innerHTML=`<canvas></canvas><label>${flt.name}</label>`;
          const c=item.querySelector('canvas'), cx=c.getContext('2d'); const aspect=state.image.width/state.image.height;
          c.width=84; c.height=Math.max(56,Math.round(84/aspect));
          cx.save(); cx.filter=flt.css(100); cx.drawImage(state.image,0,0,c.width,c.height); cx.restore();
          item.addEventListener('click',()=>{ state.activePreset=idx; state.aggr=state.filters[idx].aggr; updateSettingsUI(); document.querySelectorAll('.preset').forEach(el=>el.classList.remove('active')); item.classList.add('active'); schedulePreviewRender(true); log('Preset:', flt.name,'Feather:',state.aggr); });
          dom.presets.appendChild(item);
        });
        state.thumbnailsReady=true;
      };
      if(lazy){ state.thumbnailsReady=false; setTimeout(doRender,500); } else { doRender(); }
    }

    /* History */
    const history={
      save(){
        const snapshot={
          selections: JSON.parse(JSON.stringify(state.selections,(k,v)=> (k==='maskCanvas'&&v&&v.toDataURL)?v.toDataURL():v)),
          activeIndex:state.activeIndex, transform:{...state.transform},
          activePreset:state.activePreset, aggr:state.aggr, tol:state.tol, filtStrength:state.filtStrength,
          ai:{
            active:state.ai.active, segModel:state.ai.segModel, depthModel:state.ai.depthModel, refine:state.ai.refine,
            prompt:state.ai.prompt, lastClick:state.ai.lastClick
          }
        };
        if(state.histIndex<state.history.length-1) state.history=state.history.slice(0,state.histIndex+1);
        state.history.push(JSON.stringify(snapshot)); state.histIndex++; refreshButtons();
      },
      load(i){
        const snap=JSON.parse(state.history[i]);
        state.selections=(snap.selections||[]).map(s=>{
          if((s.type==='mask'||s.type==='protect')&&s.maskCanvas&&typeof s.maskCanvas==='string'){ const cnv=dataURLToCanvas(s.maskCanvas); return {...s, maskCanvas:cnv}; }
          return s;
        });
        state.activeIndex=snap.activeIndex; state.transform=snap.transform;
        state.activePreset=snap.activePreset??state.activePreset; state.aggr=snap.aggr??state.aggr; state.tol=snap.tol??state.tol; state.filtStrength=snap.filtStrength??state.filtStrength;
        if(snap.ai){ state.ai.active=!!snap.ai.active; state.ai.segModel=snap.ai.segModel||state.ai.segModel; state.ai.depthModel=snap.ai.depthModel||state.ai.depthModel; state.ai.refine=!!snap.ai.refine; state.ai.prompt=snap.ai.prompt||''; state.ai.lastClick=snap.ai.lastClick||null; setAIModeUI(); }
        editor.draw(); schedulePreviewRender(true); renderPresets(true); updateSettingsUI(); refreshButtons();
      },
      undo(){ if(state.histIndex>0){ state.histIndex--; history.load(state.histIndex); log('Undo'); } },
      redo(){ if(state.histIndex<state.history.length-1){ state.histIndex++; history.load(state.histIndex); log('Redo'); } }
    };

    /* Box/Lasso helpers */
    function drawBoxHandles(ctx,sel){
      const r=5/state.transform.scale;
      const pts=[[sel.x,sel.y],[ sel.x+sel.w/2, sel.y],[ sel.x+sel.w, sel.y],[ sel.x+sel.w, sel.y+sel.h/2],[ sel.x+sel.w, sel.y+sel.h],[ sel.x+sel.w/2, sel.y+sel.h],[ sel.x, sel.y+sel.h],[ sel.x, sel.y+sel.h/2]];
      ctx.fillStyle='#1877f2'; ctx.strokeStyle='#fff'; ctx.lineWidth=1.5/state.transform.scale;
      pts.forEach(([px,py])=>{ ctx.beginPath(); ctx.rect(px-r,py-r,r*2,r*2); ctx.fill(); ctx.stroke(); });
    }
    const pointInBox=(sel,x,y)=> x>=sel.x&&y>=sel.y&&x<=sel.x+sel.w&&y<=sel.y+sel.h;
    function pointInLasso(sel,x,y){
      let inside=false; const pts=sel.points;
      for(let i=0,j=pts.length-1;i<pts.length;j=i++){
        const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
        const intersect=((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }

    /* Render flow */
    const renderPreviewDebounced=debounce(()=>{ if(!state.image) return; state.rendering=true; preview.layout(); preview.render(); state.rendering=false; finishProgress(); renderPresets(true); log('Preview rendered.'); },360);
    function schedulePreviewRender(start=true){ if(!state.image) return; if(start) startProgress(); renderPreviewDebounced(); }

    /* File I/O */
    dom.uploadBtn.addEventListener('click',()=>dom.fileInput.click());
    dom.fileInput.addEventListener('change',onFileInput);
    function onFileInput(e){ const f=e.target.files[0]; if(f) readImageFile(f); }
    dom.editorWrap.addEventListener('dragover',(e)=>{e.preventDefault(); dom.editorWrap.classList.add('drop-hover');});
    dom.editorWrap.addEventListener('dragenter',(e)=>{e.preventDefault(); dom.editorWrap.classList.add('drop-hover');});
    dom.editorWrap.addEventListener('dragleave',(e)=>{e.preventDefault(); dom.editorWrap.classList.remove('drop-hover');});
    dom.editorWrap.addEventListener('drop',(e)=>{e.preventDefault(); dom.editorWrap.classList.remove('drop-hover'); const f=e.dataTransfer?.files?.[0]; if(f&&f.type.startsWith('image/')) readImageFile(f); });

    function readImageFile(file){
      const r=new FileReader();
      r.onload=()=>{ const img=new Image(); img.onload=()=>{ state.image=img; state.selections=[]; state.activeIndex=-1;
          resetAIBuffers();
          dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
          editor.updateSize(); focal.fit(); editor.draw(); renderPresets(true); history.save(); refreshButtons(); schedulePreviewRender(true); initSegWorker(); log('Image loaded:', file.name, `${img.width}x${img.height}`); };
        img.src=r.result; };
      r.readAsDataURL(file);
    }

    /* Fit / reset view */
    const focal={ fit(){ if(!state.image) return; const iW=state.image.width,iH=state.image.height; const cW=dom.editorWrap.clientWidth,cH=dom.editorWrap.clientHeight; const s=Math.min(cW/iW,cH/iH)*0.97; const x=(cW-iW*s)/2, y=(cH-iH*s)/2; state.transform={x,y,scale:s}; } };
    const refitDebounced=debounce(()=>{ if(state.image){ focal.fit(); editor.draw(); preview.layout(); } },140);
    window.addEventListener('resize',()=>{ editor.updateSize(); preview.layout(); refitDebounced(); });

    /* Interactions */
    let painting=false;
    dom.editorWrap.addEventListener('mousedown', async (e)=>{
      if(!state.image) return;

      // AI group click: set seed & run (if AI active)
      if(state.ai.active){
        const p=editor.imgToCanvasSpace(e.clientX,e.clientY);
        const sx=Math.round(clamp(p.x,0,state.image.width-1));
        const sy=Math.round(clamp(p.y,0,state.image.height-1));
        state.ai.lastClick={x:sx,y:sy};
        log(`AI seed set @ (${sx}, ${sy}).`);
        runAIPipeline({trigger:'click'}).catch(err=>log('AI error:', err?.message||err));
        return;
      }

      if(state.isPanning){
        state.drag={active:true,kind:'pan',startX:e.clientX,startY:e.clientY,tx:state.transform.x,ty:state.transform.y,moved:false};
        dom.editorWrap.classList.add('panning'); return;
      }

      const p=editor.imgToCanvasSpace(e.clientX,e.clientY);

      if(state.mode==='autoSmart'||state.mode==='autoUltra'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        if(segReady){ startProgress(); await requestSegMask(state.mode,sx,sy,state.tol,state.aggr); }
        else{
          const mask=(state.mode==='autoUltra')? ultraMask(state.image,sx,sy,state.tol/100,state.aggr) : magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
          if(mask){
            state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:(state.mode==='autoUltra'?'grabcutLite':'edgeGrow'), seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}});
            state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save();
          }
        }
        return;
      }
      if(state.mode==='autoWand'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
        if(mask){
          state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}});
          state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Auto Wand added.');
        }
        return;
      }
      if(state.mode==='protectEraser'||state.mode==='removeEraser'){
        painting=true; ensureBrushLayer(state.mode==='protectEraser'?'protect':'mask'); paintOnActiveMask(p.x,p.y,true); editor.draw(); schedulePreviewRender(); return;
      }

      // hit-testing for move/resize
      let hitIndex=-1, hitHandle=null, hitKind='none';
      for(let i=state.selections.length-1;i>=0;i--){
        const sel=state.selections[i];
        if(sel.type==='box'){
          const h=hitBoxHandle(sel,p.x,p.y); if(h){ hitIndex=i; hitHandle=h; hitKind='box-resize'; break; }
          if(pointInBox(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='lasso'){ if(pointInLasso(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='mask'||sel.type==='protect'){ if(maskHit(sel.maskCanvas,p.x,p.y)){ hitIndex=i; hitKind='move'; break; } }
      }
      if(hitIndex>=0){
        state.activeIndex=hitIndex;
        state.drag={active:true,kind:hitKind,handle:hitHandle,startX:p.x,startY:p.y,moved:false,
          snapshot: JSON.parse(JSON.stringify(state.selections[hitIndex],(k,v)=> (k==='maskCanvas'&&v&&v.toDataURL)?v.toDataURL():v))
        };
        editor.draw(); return;
      }

      // start new selection
      state.activeIndex=-1;
      if(state.mode==='box'){
        const seed={type:'box', x:p.x, y:p.y, w:0, h:0}; state.selections.push(seed); state.activeIndex=state.selections.length-1; state.drag={active:true,kind:'box-make',startX:p.x,startY:p.y,moved:false};
      }else if(state.mode==='lasso'){
        state.activeIndex=state.selections.length; const sel={type:'lasso', points:[p]}; state.selections.push(sel); state.drag={active:true,kind:'lasso-make',last:p,moved:false};
      }
      editor.draw();
    });

    dom.editorWrap.addEventListener('mousemove',(e)=>{
      if(!state.image) return;
      updateMonocle(e,'editor');

      if(painting && (state.mode==='protectEraser'||state.mode==='removeEraser')){
        const p=editor.imgToCanvasSpace(e.clientX,e.clientY); paintOnActiveMask(p.x,p.y,false); editor.draw(); schedulePreviewRender(); return;
      }
      if(!state.drag.active) return;
      const p=editor.imgToCanvasSpace(e.clientX,e.clientY);
      if(!state.drag.moved && (Math.abs(e.clientX-state.drag.startX)>3 || Math.abs(e.clientY-state.drag.startY)>3)) state.drag.moved=true;

      switch(state.drag.kind){
        case 'pan':{
          state.transform.x=state.drag.tx + (e.clientX-state.drag.startX);
          state.transform.y=state.drag.ty + (e.clientY-state.drag.startY);
          editor.draw(); break;
        }
        case 'box-resize':{
          const sel=state.selections[state.activeIndex]; const snap=reviveMaskInSnapshot(state.drag.snapshot); const handle=state.drag.handle; const minSize=10; const right=snap.x+snap.w, bottom=snap.y+snap.h;
          let nx=snap.x, ny=snap.y, nw=snap.w, nh=snap.h;
          if(handle.includes('n')){ ny=Math.min(bottom-minSize,p.y); nh=bottom-ny; }
          if(handle.includes('s')){ nh=Math.max(minSize,p.y-snap.y); }
          if(handle.includes('w')){ nx=Math.min(right-minSize,p.x); nw=right-nx; }
          if(handle.includes('e')){ nw=Math.max(minSize,p.x-snap.x); }
          Object.assign(sel,{x:nx,y:ny,w:nw,h:nh}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'move':{
          const sel=state.selections[state.activeIndex]; const snap=reviveMaskInSnapshot(state.drag.snapshot); const dx=p.x-state.drag.startX, dy=p.y-state.drag.startY;
          if(sel.type==='box'){ sel.x=snap.x+dx; sel.y=snap.y+dy; }
          else if(sel.type==='lasso'){ sel.points=snap.points.map(pt=>({x:pt.x+dx,y:pt.y+dy})); }
          else if(sel.type==='mask'||sel.type==='protect'){ const moved=document.createElement('canvas'); moved.width=snap.maskCanvas.width; moved.height=snap.maskCanvas.height; moved.getContext('2d').drawImage(snap.maskCanvas,dx,dy); sel.maskCanvas=moved; }
          editor.draw(); schedulePreviewRender(); break;
        }
        case 'box-make':{
          const sx=state.drag.startX, sy=state.drag.startY; const x=Math.min(sx,p.x), y=Math.min(sy,p.y); const w=Math.abs(p.x-sx), h=Math.abs(p.y-sy);
          const sel=state.selections[state.activeIndex]; Object.assign(sel,{x,y,w,h}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'lasso-make':{
          const sel=state.selections[state.activeIndex]; const last=state.drag.last; const dist2=(p.x-last.x)**2 + (p.y-last.y)**2;
          if(dist2>(4/state.transform.scale)**2){ sel.points.push(p); state.drag.last=p; editor.draw(); }
          break;
        }
      }
    });

    window.addEventListener('mouseup',()=>{
      if(!state.image) return;
      if(painting){ painting=false; history.save(); return; }
      if(!state.drag.active) return;
      const wasMake=/-make$/.test(state.drag.kind);
      if(state.drag.kind==='lasso-make'){
        const sel=state.selections[state.activeIndex];
        if(sel&&sel.points.length>2){ const a=sel.points[0], b=sel.points[sel.points.length-1]; if(a.x!==b.x||a.y!==b.y) sel.points.push({x:a.x,y:a.y}); }
        if(sel && sel.points.length<3){ state.selections.splice(state.activeIndex,1); state.activeIndex=-1; }
      }
      if(state.drag.kind==='box-make'){
        const sel=state.selections[state.activeIndex];
        if(!state.drag.moved){ const s=Math.max(40,Math.min(state.image.width,state.image.height)*0.12); state.selections[state.activeIndex]={type:'box',x:clamp(state.drag.startX - s/2,0,state.image.width - s), y:clamp(state.drag.startY - s/2,0,state.image.height - s), w:s,h:s}; }
        if(sel && (sel.w<5||sel.h<5)){ state.selections.splice(state.activeIndex,1); state.activeIndex=-1; }
      }
      state.drag.active=false; dom.editorWrap.classList.remove('panning'); editor.draw(); schedulePreviewRender(true); history.save(); if(wasMake) log('Selection added.');
    });

    dom.editorWrap.addEventListener('wheel',(e)=>{
      if(!state.image) return; e.preventDefault();
      const r=dom.editorCanvas.getBoundingClientRect(); const mx=e.clientX - r.left, my=e.clientY - r.top;
      const zf=1.1; const zoom=e.deltaY<0?zf:1/zf; const newScale=clamp(state.transform.scale*zoom,0.1,20);
      state.transform.x = mx - (mx - state.transform.x)*zoom; state.transform.y = my - (my - state.transform.y)*zoom; state.transform.scale=newScale;
      editor.draw(); updateMonocle(e,'editor');
    },{passive:false});

    dom.previewWrap.addEventListener('mousemove',(e)=>{ if(!state.image) return; updateMonocle(e,'preview'); });
    dom.editorWrap.addEventListener('mouseenter',()=> dom.monoLeft.style.display='block');
    dom.previewWrap.addEventListener('mouseenter',()=> dom.monoRight.style.display='block');

    /* Buttons */
    dom.modeLassoBtn.addEventListener('click',()=>{ setAIMode(false); setMode('lasso'); });
    dom.newLassoBtn.addEventListener('click',()=>{ setAIMode(false); setMode('lasso'); state.activeIndex=-1; editor.draw(); log('Ready: draw new lasso.'); });
    dom.modeBoxBtn.addEventListener('click',()=>{ setAIMode(false); setMode('box'); });
    dom.deleteSelectionBtn.addEventListener('click',()=>{ if(state.activeIndex!==-1){ const t=state.selections[state.activeIndex]?.type; state.selections.splice(state.activeIndex,1); state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted:',t||''); }});
    dom.autoWandBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoWand'); });
    dom.autoSmartBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoSmart'); });
    dom.autoUltraBtn.addEventListener('click',()=>{ setAIMode(false); setMode('autoUltra'); });
    dom.autoObjectsBtn.addEventListener('click',async()=>{
      setAIMode(false);
      if(!state.image){ alert('Load an image first.'); return; }
      const sx=Math.round(state.image.width/2), sy=Math.round(state.image.height/2);
      if(segReady){ startProgress(); await requestSegMask('autoSmart',sx,sy,state.tol,state.aggr); }
      else{
        const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
        if(mask){ state.selections.push({type:'mask', maskCanvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol,aggr:state.aggr}, origin:'manual'}}); state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); }
      }
    });
    dom.protectEraserBtn.addEventListener('click',()=>{ setAIMode(false); setMode('protectEraser'); });
    dom.removeEraserBtn.addEventListener('click',()=>{ setAIMode(false); setMode('removeEraser'); });
    dom.undoBtn.addEventListener('click',()=>history.undo());
    dom.redoBtn.addEventListener('click',()=>history.redo());
    dom.renderNowBtn.addEventListener('click',()=>{ startProgress(); preview.layout(); preview.render(); finishProgress(); renderPresets(true); log('Manual render complete.'); });
    dom.resetViewBtn.addEventListener('click',()=>{ if(!state.image) return; focal.fit(); editor.draw(); log('View reset.'); });

    dom.downloadBtn.addEventListener('click',()=>{
      if(!state.image){ alert('Load an image first.'); return; }
      const out=document.createElement('canvas'); out.width=state.image.width; out.height=state.image.height; const octx=out.getContext('2d');
      // grayscale BG
      const tmpC=document.createElement('canvas'); tmpC.width=out.width; tmpC.height=out.height; const tmpX=tmpC.getContext('2d'); tmpX.drawImage(state.image,0,0);
      const src=tmpX.getImageData(0,0,out.width,out.height); const data=src.data;
      for(let i=0;i<data.length;i+=4){ const y=Math.round(0.2126*data[i]+0.7152*data[i+1]+0.0722*data[i+2]); data[i]=y; data[i+1]=y; data[i+2]=y; data[i+3]=255; }
      tmpX.putImageData(src,0,0); octx.drawImage(tmpC,0,0);
      // Foreground
      const fullMask=buildFullMaskCanvas(); const fg=document.createElement('canvas'); fg.width=out.width; fg.height=out.height; const fgx=fg.getContext('2d'); fgx.drawImage(state.image,0,0); fgx.globalCompositeOperation='destination-in'; fgx.drawImage(fullMask,0,0); octx.drawImage(fg,0,0);
      const url=out.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=`colorsplash-result-${Date.now()}.png`; a.click();
    });

    dom.startOverBtn.addEventListener('click',()=>{
      if(!state.image) return;
      if(confirm('Clear image and selections?')){
        state.image=null; state.selections=[]; state.activeIndex=-1; state.history=[]; state.histIndex=-1; resetAIBuffers();
        dom.editorEmpty.classList.remove('hidden'); dom.previewEmpty.classList.remove('hidden');
        editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width,editor.c.height); preview.ctx.clearRect(0,0,preview.c.width,preview.c.height);
        dom.aiVariants.innerHTML=''; dom.aiMaskThumb.getContext('2d').clearRect(0,0,dom.aiMaskThumb.width,dom.aiMaskThumb.height); dom.aiDepthThumb.getContext('2d').clearRect(0,0,dom.aiDepthThumb.width,dom.aiDepthThumb.height);
        renderPresets(); refreshButtons(); log('Project cleared.');
      }
    });

    dom.saveBtn.addEventListener('click',()=>{
      if(!state.image) return;
      const payload={
        app:'Color Splash Pro X', version:APP_VERSION,
        imageDataURL:getCurrentImageDataURL(),
        selections: state.selections.map(s=>{ const base={...s}; if((s.type==='mask'||s.type==='protect')&&s.maskCanvas) base.maskCanvas=s.maskCanvas.toDataURL(); return base; }),
        activePreset:state.activePreset, aggr:state.aggr, tol:state.tol, filtStrength:state.filtStrength,
        ai:{ active:state.ai.active, segModel:state.ai.segModel, depthModel:state.ai.depthModel, refine:state.ai.refine, prompt:state.ai.prompt, lastClick:state.ai.lastClick }
      };
      const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`colorsplash-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href); log('Saved project JSON.');
    });

    dom.loadBtn.addEventListener('click',()=>dom.loadInput.click());
    dom.loadInput.addEventListener('change',(e)=>{
      const f=e.target.files[0]; if(!f) return; const r=new FileReader();
      r.onload=()=>{ try{ const obj=JSON.parse(r.result); loadFromObject(obj); log('Loaded project JSON.'); } catch(err){ alert('Invalid JSON'); }};
      r.readAsText(f);
    });

    function loadFromObject(obj){
      const img=new Image();
      img.onload=()=>{
        state.image=img;
        state.selections=(obj.selections||[]).map(s=>{
          if((s.type==='mask'||s.type==='protect')&&s.maskCanvas&&typeof s.maskCanvas==='string'){ const cnv=dataURLToCanvas(s.maskCanvas); return {...s, maskCanvas:cnv}; }
          return s;
        });
        state.activeIndex=-1; state.activePreset=obj.activePreset??0; state.aggr=obj.aggr??35; state.tol=obj.tol??25; state.filtStrength=obj.filtStrength??100;
        if(obj.ai){ state.ai.active=!!obj.ai.active; state.ai.segModel=obj.ai.segModel||state.ai.segModel; state.ai.depthModel=obj.ai.depthModel||state.ai.depthModel; state.ai.refine=!!obj.ai.refine; state.ai.prompt=obj.ai.prompt||''; state.ai.lastClick=obj.ai.lastClick||null; }
        dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
        editor.updateSize(); focal.fit(); editor.draw(); renderPresets(true); updateSettingsUI(); state.history=[]; state.histIndex=-1; history.save(); refreshButtons(); schedulePreviewRender(true); initSegWorker(); setAIModeUI();
      };
      img.src=obj.imageDataURL;
    }

    /* Settings (in pinned panel) */
    function updateSettingsUI(){
      dom.aggrRange.value=state.aggr; dom.aggrVal.textContent=state.aggr;
      dom.tolRange.value=state.tol; dom.tolVal.textContent=state.tol;
      dom.fltRange.value=state.filtStrength; dom.fltVal.textContent=state.filtStrength+'%';
      dom.aiActiveSwitch.checked=state.ai.active;
      dom.aiSegModel.value=state.ai.segModel; dom.aiDepthModel.value=state.ai.depthModel; dom.aiRefine.checked=state.ai.refine; dom.aiPreload.checked=state.ai.preload; dom.aiPrompt.value=state.ai.prompt||'';
      showPromptIfNeeded();
    }

    dom.aggrRange.addEventListener('input',()=>{ state.aggr=parseInt(dom.aggrRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });
    dom.tolRange.addEventListener('input',()=>{ state.tol=parseInt(dom.tolRange.value,10); updateSettingsUI(); if(state.modeGroup==='manual'){ recomputeGeneratedMasks(); } });
    dom.fltRange.addEventListener('input',()=>{ state.filtStrength=parseInt(dom.fltRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });
    dom.clearLogsBtn.addEventListener('click',()=>{ dom.aiLogBody.innerHTML=''; });

    /* Pinned panel open */
    dom.pinFab.addEventListener('click',()=> dom.pinPanel.classList.toggle('visible'));
    dom.toggleLogsBtn.addEventListener('click',()=> dom.pinPanel.classList.add('visible'));

    /* Modes */
    function setMode(m){
      state.mode=m;
      dom.modeLassoBtn.classList.toggle('active',m==='lasso');
      dom.modeBoxBtn.classList.toggle('active',m==='box');
      dom.autoWandBtn.classList.toggle('active',m==='autoWand');
      dom.autoSmartBtn.classList.toggle('active',m==='autoSmart');
      dom.autoUltraBtn.classList.toggle('active',m==='autoUltra');
      dom.protectEraserBtn.classList.toggle('active',m==='protectEraser');
      dom.removeEraserBtn.classList.toggle('active',m==='removeEraser');
      log('Mode:',m);
    }
    function refreshButtons(){
      dom.undoBtn.disabled=state.histIndex<=0;
      dom.redoBtn.disabled=state.histIndex>=state.history.length-1||state.history.length===0;
      dom.deleteSelectionBtn.disabled=state.activeIndex===-1;
      dom.saveBtn.disabled=!state.image;
      dom.startOverBtn.disabled=!state.image;
    }

    /* Init */
    function init(){
      editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width,editor.c.height);
      preview.ctx.clearRect(0,0,preview.c.width,preview.c.height);
      renderPresets(); updateSettingsUI(); refreshButtons();
      log(`App ready. Version ${APP_VERSION}`);
      log('Shortcuts: S=Lasso, B=Box, W=Auto Wand, G=Auto Smart, U=Auto Ultra, E=Protect, R=Remove. Space-drag Pan. Wheel Zoom.');
      setAIModeUI(); detectRuntime();
    }
    init();

    /* Smart recompute (manual) */
    async function recomputeGeneratedMasks(){
      if(!state.image) return;
      const targets=[];
      state.selections.forEach((s,idx)=>{ if(s && s.type==='mask' && s.generator && s.generator.tool && s.generator.origin!=='ai'){ const t=s.generator.tool; if(t==='edgeGrow'||t==='grabcutLite'||t==='magicWand'){ targets.push(idx); } }});
      if(targets.length===0){ schedulePreviewRender(true); return; }
      startProgress();
      const newMasks=[];
      for(const idx of targets){
        const s=state.selections[idx], g=s.generator||{}; const sx=Math.round(g.seedX??(state.image.width/2)), sy=Math.round(g.seedY??(state.image.height/2));
        const tool=(g.tool==='edgeGrow')?'autoSmart':(g.tool==='grabcutLite')?'autoUltra':(g.tool==='magicWand')?'autoWand':'autoSmart';
        if(tool==='autoWand'){ const mask=magicWandMask(state.image,sx,sy,state.tol/100,state.aggr); if(mask) newMasks.push({i:idx,canvas:mask,generator:{tool:'magicWand',seedX:sx,seedY:sy,params:{tol:state.tol,aggr:state.aggr},origin:'manual'}}); }
        else if(segReady){ await requestSegMask(tool,sx,sy,state.tol,state.aggr); newMasks.push({i:idx,replace:true}); }
        else{
          const fb=(tool==='autoUltra')? ultraMask(state.image,sx,sy,state.tol/100,state.aggr) : magicWandMask(state.image,sx,sy,state.tol/100,state.aggr);
          if(fb) newMasks.push({i:idx,canvas:fb,generator:{tool:(tool==='autoUltra'?'grabcutLite':'edgeGrow'),seedX:sx,seedY:sy,params:{tol:state.tol,aggr:state.aggr, fallback:true},origin:'manual'}});
        }
      }
      const toDelete=[]; for(const nm of newMasks){ if(nm.replace){ toDelete.push(nm.i);} else { state.selections[nm.i]={type:'mask',maskCanvas:nm.canvas,generator:nm.generator}; } }
      toDelete.sort((a,b)=>b-a).forEach(i=> state.selections.splice(i,1));
      editor.draw(); schedulePreviewRender(false); history.save(); finishProgress(); log('Recomputed',targets.length,'mask(s).');
    }

    /* Built-in magic wand/ultra */
    function magicWandMask(img, sx, sy, tol01, grow){
      const w=img.width,h=img.height, maxSide=1024, scale=Math.min(1,maxSide/Math.max(w,h));
      const sw=Math.max(1,Math.round(w*scale)), sh=Math.max(1,Math.round(h*scale));
      const sC=document.createElement('canvas'); sC.width=sw; sC.height=sh; const sX=sC.getContext('2d'); sX.drawImage(img,0,0,sw,sh);
      const x=clamp(Math.round(sx*scale),0,sw-1), y=clamp(Math.round(sy*scale),0,sh-1);
      const src=sX.getImageData(0,0,sw,sh); const data=src.data; const mask=new Uint8Array(sw*sh);
      const idx=(x,y)=> y*sw+x, pIdx=(x,y)=> idx(x,y)*4;
      const r0=data[pIdx(x,y)], g0=data[pIdx(x,y)+1], b0=data[pIdx(x,y)+2]; const thr=8 + tol01*132;
      const st=[[x,y]]; mask[idx(x,y)]=1;
      while(st.length){ const [cx,cy]=st.pop(); for(const [nx,ny] of [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]]){ if(nx<0||ny<0||nx>=sw||ny>=sh) continue; const id=idx(nx,ny); if(mask[id]) continue; const p=pIdx(nx,ny); const dr=data[p]-r0,dg=data[p+1]-g0,db=data[p+2]-b0; const dist=Math.sqrt(dr*dr+dg*dg+db*db); if(dist<=thr){ mask[id]=1; st.push([nx,ny]); } } }
      if(grow>0){ const it=Math.round(clamp(grow,0,100)*0.08), nb=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        for(let k=0;k<it;k++){ const copy=mask.slice(0); for(let yy=0;yy<sh;yy++){ for(let xx=0;xx<sw;xx++){ if(copy[idx(xx,yy)]) continue; let on=0; for(const [dx,dy] of nb){ const xx2=xx+dx, yy2=yy+dy; if(xx2>=0&&yy2>=0&&xx2<sw&&yy2<sh && copy[idx(xx2,yy2)]){ on=1; break; } } if(on) mask[idx(xx,yy)]=1; } } }
      }
      const mC=document.createElement('canvas'); mC.width=w; mC.height=h; const mX=mC.getContext('2d');
      const mSmall=document.createElement('canvas'); mSmall.width=sw; mSmall.height=sh; const msx=mSmall.getContext('2d'); const id=msx.createImageData(sw,sh);
      for(let i=0;i<sw*sh;i++){ const v=mask[i]?255:0; id.data[i*4]=255; id.data[i*4+1]=255; id.data[i*4+2]=255; id.data[i*4+3]=v; }
      msx.putImageData(id,0,0); mX.imageSmoothingEnabled=false; mX.drawImage(mSmall,0,0,sw,sh,0,0,w,h);
      return mC;
    }
    function ultraMask(img,sx,sy,tol01,aggr){ return magicWandMask(img,sx,sy,Math.min(1,tol01*1.2+0.05),aggr+8); }
    function maskHit(maskCanvas,x,y){ if(x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return false; const ctx=maskCanvas.getContext('2d'); const d=ctx.getImageData(Math.floor(x),Math.floor(y),1,1).data; return d[3]>10; }
    function edgeFromMask(maskCanvas,r){
      const w=maskCanvas.width,h=maskCanvas.height; if(!w||!h) return null;
      const srcCtx=maskCanvas.getContext('2d'); const src=srcCtx.getImageData(0,0,w,h);
      const er=document.createElement('canvas'); er.width=w; er.height=h; const ex=er.getContext('2d'); ex.filter=`blur(${Math.max(0.5,r)}px)`; ex.drawImage(maskCanvas,0,0); ex.filter='none'; const eData=ex.getImageData(0,0,w,h);
      const out=document.createElement('canvas'); out.width=w; out.height=h; const ox=out.getContext('2d'); const oData=ox.createImageData(w,h);
      for(let i=0;i<oData.data.length;i+=4){ const a=src.data[i+3], b=eData.data[i+3]; const v=Math.max(0,a-b); oData.data[i]=0; oData.data[i+1]=0; oData.data[i+2]=0; oData.data[i+3]=v>8?220:0; } ox.putImageData(oData,0,0); return out;
    }
    function reviveMaskInSnapshot(snap){ if(snap && (snap.type==='mask'||snap.type==='protect') && snap.maskCanvas && typeof snap.maskCanvas==='string'){ snap.maskCanvas=dataURLToCanvas(snap.maskCanvas);} return snap; }
    function dataURLToCanvas(url){ const img=new Image(); const cnv=document.createElement('canvas'); img.onload=()=>{ cnv.width=img.width; cnv.height=img.height; cnv.getContext('2d').drawImage(img,0,0); }; img.src=url; return cnv; }
    function getCurrentImageDataURL(){ if(!state.image) return ''; if(typeof state.image.src==='string' && state.image.src.startsWith('data:')) return state.image.src; const c=document.createElement('canvas'); c.width=state.image.width; c.height=state.image.height; c.getContext('2d').drawImage(state.image,0,0); return c.toDataURL('image/png'); }

    /* Erasers */
    function ensureBrushLayer(kind){ const idx=state.selections.findIndex(s=>s.type === (kind==='protect'?'protect':'mask')); if(idx>=0){ state.activeIndex=idx; return; } const cnv=document.createElement('canvas'); cnv.width=state.image.width; cnv.height=state.image.height; state.selections.push({type:(kind==='protect'?'protect':'mask'), maskCanvas:cnv}); state.activeIndex=state.selections.length-1; }
    let lastPaint=null;
    function paintOnActiveMask(x,y,fresh){
      const sel=state.selections[state.activeIndex]; if(!sel||!sel.maskCanvas) return; const ctx=sel.maskCanvas.getContext('2d'); const size=state.brush.size, hard=state.brush.hard, r=size/2;
      ctx.save(); ctx.globalCompositeOperation='source-over'; const gx=ctx.createRadialGradient(x,y,r*hard,x,y,r); const color=(sel.type==='protect')?'rgba(255,0,0,1)':'rgba(255,255,255,1)'; gx.addColorStop(0,color); gx.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gx;
      if(fresh||!lastPaint){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } else { const dx=x-lastPaint.x, dy=y-lastPaint.y; const steps=Math.max(1,Math.ceil(Math.hypot(dx,dy)/(r*0.5))); for(let i=1;i<=steps;i++){ const t=i/steps; const px=lastPaint.x+dx*t, py=lastPaint.y+dy*t; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); } }
      ctx.restore(); lastPaint={x,y};
    }

    /* Dual monocles with hop + correct preview sampling */
    function updateMonocle(e,where){
      if(!state.image) return;
      const hopIfNear=(el,panelRect,side)=>{
        const pad=10; const rect=el.getBoundingClientRect();
        const dx = (rect.left>e.clientX)? rect.left-e.clientX : (e.clientX>rect.right? e.clientX-rect.right : 0);
        const dy = (rect.top>e.clientY)? rect.top-e.clientY : (e.clientY>rect.bottom? e.clientY-rect.bottom : 0);
        const dist=Math.hypot(dx,dy);
        if(dist<18){ if(side==='left'){ el.style.left=(panelRect.width-rect.width-pad)+'px'; el.style.right='auto'; }else{ el.style.right=(panelRect.width-rect.width-pad)+'px'; el.style.left='auto'; } }
        else{ if(side==='left'){ el.style.left=pad+'px'; el.style.right='auto'; } else { el.style.right=pad+'px'; el.style.left='auto'; } }
      };

      if(where==='editor'){
        const mctx=dom.monoLeftCanvas.getContext('2d'); if(dom.monoLeftCanvas.width===0){ dom.monoLeftCanvas.width=148; dom.monoLeftCanvas.height=148; }
        const rect=dom.editorCanvas.getBoundingClientRect();
        const cx=(e.clientX-rect.left - state.transform.x)/state.transform.scale;
        const cy=(e.clientY-rect.top  - state.transform.y)/state.transform.scale;
        const box=64; const sx=Math.floor(clamp(cx-box/2,0,state.image.width-box)); const sy=Math.floor(clamp(cy-box/2,0,state.image.height-box));
        mctx.imageSmoothingEnabled=false; mctx.clearRect(0,0,dom.monoLeftCanvas.width,dom.monoLeftCanvas.height);
        mctx.drawImage(state.image,sx,sy,box,box,0,0,dom.monoLeftCanvas.width,dom.monoLeftCanvas.height);
        const fx=((cx-sx)/box)*dom.monoLeftCanvas.width, fy=((cy-sy)/box)*dom.monoLeftCanvas.height; mctx.strokeStyle='#0a46ff'; mctx.lineWidth=1; mctx.beginPath(); mctx.moveTo(fx,0); mctx.lineTo(fx,dom.monoLeftCanvas.height); mctx.moveTo(0,fy); mctx.lineTo(dom.monoLeftCanvas.width,fy); mctx.stroke();
        dom.monoLeft.style.display='block'; hopIfNear(dom.monoLeft, dom.editorWrap.getBoundingClientRect(),'left');
      }else{
        const mctx=dom.monoRightCanvas.getContext('2d'); if(dom.monoRightCanvas.width===0){ dom.monoRightCanvas.width=148; dom.monoRightCanvas.height=148; }
        const rect=dom.previewCanvas.getBoundingClientRect();
        const scaleX=state.image.width/Math.max(1,dom.previewCanvas.width), scaleY=state.image.height/Math.max(1,dom.previewCanvas.height);
        const cx=(e.clientX-rect.left)*scaleX, cy=(e.clientY-rect.top)*scaleY;
        const box=64; const sx=Math.floor(clamp(cx-box/2,0,state.image.width-box)); const sy=Math.floor(clamp(cy-box/2,0,state.image.height-box));
        // sample directly from preview canvas using mapped rectangle
        const sxPrev = sx/scaleX, syPrev = sy/scaleY, swPrev = box/scaleX, shPrev = box/scaleY;
        mctx.imageSmoothingEnabled=false; mctx.clearRect(0,0,dom.monoRightCanvas.width,dom.monoRightCanvas.height);
        mctx.drawImage(dom.previewCanvas, sxPrev, syPrev, swPrev, shPrev, 0,0, dom.monoRightCanvas.width, dom.monoRightCanvas.height);
        const fx=((cx-sx)/box)*dom.monoRightCanvas.width, fy=((cy-sy)/box)*dom.monoRightCanvas.height; mctx.strokeStyle='#0a46ff'; mctx.lineWidth=1; mctx.beginPath(); mctx.moveTo(fx,0); mctx.lineTo(fx,dom.monoRightCanvas.height); mctx.moveTo(0,fy); mctx.lineTo(dom.monoRightCanvas.width,fy); mctx.stroke();
        dom.monoRight.style.display='block'; hopIfNear(dom.monoRight, dom.previewWrap.getBoundingClientRect(),'right');
      }
    }

    /* AI bar & toggles */
    dom.aiModeBtn.addEventListener('click',()=> setAIMode(!state.ai.active));
    dom.aiActiveSwitch.addEventListener('change',()=> setAIMode(dom.aiActiveSwitch.checked));
    dom.aiSegModel.addEventListener('change',()=>{ state.ai.segModel=dom.aiSegModel.value; showPromptIfNeeded(); if(state.ai.preload) backgroundPreload(state.ai.segModel); log('AI seg model:',state.ai.segModel); maybeAutoRunIfSeed(); });
    dom.aiDepthModel.addEventListener('change',()=>{ state.ai.depthModel=dom.aiDepthModel.value; if(state.ai.preload) backgroundPreload(state.ai.depthModel); log('AI depth model:',state.ai.depthModel); maybeAutoRunIfSeed(); });
    dom.aiRefine.addEventListener('change',()=>{ state.ai.refine=dom.aiRefine.checked; dom.aiStatus.textContent = state.ai.refine?'refine: on':'refine: off'; if(state.ai.active && state.ai.outputs.baseMask){ // regenerate variants fast
        generateVariantsAndShow(); schedulePreviewRender(true);
      }});
    dom.aiPreload.addEventListener('change',()=>{ state.ai.preload=dom.aiPreload.checked; log('Preload', state.ai.preload?'ON':'OFF'); });
    dom.aiPrompt.addEventListener('input',()=>{ state.ai.prompt=dom.aiPrompt.value; });

    dom.aiUseBtn.addEventListener('click',()=>{ if(!state.image){ alert('Load an image first.'); return; } runAIPipeline({trigger:'use'}).catch(err=>log('AI error:', err?.message||err)); });

    function setAIMode(flag){
      state.ai.active=!!flag; state.modeGroup = flag?'ai':'manual'; setAIModeUI();
      if(flag){
        if(state.ai.preload){ backgroundPreload(state.ai.segModel); backgroundPreload(state.ai.depthModel); }
        log('AI Mode ON. Select models, click Original to set seed, or press Use.');
      } else { log('AI Mode OFF. Manual tools active.'); }
      history.save();
    }
    function setAIModeUI(){
      dom.aiModeBtn.classList.toggle('active',state.ai.active);
      dom.aiBar.classList.toggle('visible',state.ai.active);
      dom.aiActiveSwitch.checked=state.ai.active;
      dom.aiSegModel.value=state.ai.segModel; dom.aiDepthModel.value=state.ai.depthModel; dom.aiRefine.checked=state.ai.refine; dom.aiPreload.checked=state.ai.preload; dom.aiPrompt.value=state.ai.prompt||'';
      dom.aiStatus.textContent = state.ai.active? 'AI mode: ready' : 'AI mode: off';
      showPromptIfNeeded();
    }
    function showPromptIfNeeded(){ const needsPrompt = (dom.aiSegModel.value==='clipseg'); dom.aiPrompt.classList.toggle('hidden', !needsPrompt); }

    function maybeAutoRunIfSeed(){ if(state.ai.active && state.ai.lastClick){ runAIPipeline({trigger:'model-change'}).catch(e=>log('AI error:', e?.message||e)); } }

    /* Runtime detect */
    async function detectRuntime(){
      try{ const gpuAvail = !!ort.env.webgpu && (await navigator.gpu?.requestAdapter())!=null; dom.runtimeChip.textContent = gpuAvail? 'WebGPU + WASM':'WASM only'; log('Runtime:',dom.runtimeChip.textContent); }
      catch{ dom.runtimeChip.textContent='WASM only'; }
    }

    /* ORT sessions with download progress (ArrayBuffer path) */
    const downloadCache={}; // key -> ArrayBuffer
    async function ensureORTSession(key, {withProgress=true}={}){
      if(state.ai.sessions[key]) return state.ai.sessions[key];
      const entry=MODEL_URLS[key]; if(!entry) throw new Error('Unknown model '+key);
      // fetch with progress unless cached
      let modelBuf=downloadCache[key];
      if(!modelBuf){
        if(!withProgress){ // simple fetch
          const res=await fetch(entry.url,{mode:'cors'}); if(!res.ok) throw new Error('HTTP '+res.status);
          modelBuf=await res.arrayBuffer();
        }else{
          modelBuf=await fetchWithProgress(entry.url, key, entry.sizeHintMB);
        }
        downloadCache[key]=modelBuf;
      }
      // pick providers
      let providers=['wasm'];
      try{ if(ort.env.webgpu){ const ad=await navigator.gpu?.requestAdapter(); if(ad) providers=['webgpu','wasm']; } }catch{}
      dom.aiStatus.textContent = `initializing ${key}‚Ä¶`;
      const t0=performance.now();
      const session=await ort.InferenceSession.create(modelBuf,{executionProviders:providers, graphOptimizationLevel:'all'});
      const ms=Math.round(performance.now()-t0);
      log(`AI: ${key} initialized in ${ms} ms via ${providers[0]}.`);
      dom.aiStatus.textContent = `loaded ${key}`;
      state.ai.sessions[key]=session;
      return session;
    }
    async function fetchWithProgress(url, key, sizeHintMB){
      log(`Downloading ${key} (~${sizeHintMB}MB)‚Ä¶`);
      dom.aiStatus.textContent=`downloading ${key}‚Ä¶`;
      startProgress();
      const res=await fetch(url,{mode:'cors'}); if(!res.ok) throw new Error('HTTP '+res.status);
      const reader=res.body.getReader(); const chunks=[]; let rec=0; const contentLength=Number(res.headers.get('content-length'))||0;
      while(true){ const {done,value}=await reader.read(); if(done) break; chunks.push(value); rec+=value.byteLength; const ratio=contentLength? rec/contentLength : Math.min(1, rec/(sizeHintMB*1024*1024)); dom.progressBar.style.width = Math.round(100*ratio)+'%'; }
      const buf=mergeChunks(chunks, rec); finishProgress(); log(`Downloaded ${key} (${(rec/1024/1024).toFixed(1)}MB).`); return buf;
    }
    function mergeChunks(chunks,total){ const out=new Uint8Array(total); let off=0; for(const ch of chunks){ out.set(ch,off); off+=ch.length; } return out.buffer; }

    /* AI pipeline */
    function resetAIBuffers(){
      state.ai.outputs={baseMask:null, depthCanvas:null, depthMap:null, finalMask:null, variants:[]};
      dom.aiVariants.innerHTML='';
      const c1=dom.aiMaskThumb.getContext('2d'); c1.clearRect(0,0,dom.aiMaskThumb.width,dom.aiMaskThumb.height);
      const c2=dom.aiDepthThumb.getContext('2d'); c2.clearRect(0,0,dom.aiDepthThumb.width,dom.aiDepthThumb.height);
    }

    async function runAIPipeline({trigger}={}){
      if(!state.image) return;
      state.modeGroup='ai';
      startProgress(); dom.aiStatus.textContent='running‚Ä¶';

      // Load models as needed
      let segSess=null, depthSess=null;
      try{ segSess = await ensureORTSession(state.ai.segModel); }catch(err){ log('Seg model failed:', err?.message||err); }
      try{ depthSess = await ensureORTSession(state.ai.depthModel); }catch(err){ log('Depth model failed:', err?.message||err); }

      const img=state.image;
      const seed=state.ai.lastClick || {x:Math.round(img.width/2), y:Math.round(img.height/2)};

      // SEGMENT
      let baseMask=null;
      try{
        const segKey=state.ai.segModel, info=MODEL_URLS[segKey];
        if(segKey==='yolov8n-seg' || segKey==='yolo11n-seg'){
          baseMask = await segWithYOLO(segSess, img, info.inputSize, seed);
        }else if(segKey==='mobile-sam'){
          if(!state.ai.lastClick) throw new Error('MobileSAM needs a seed point; click the object.');
          baseMask = await segWithMobileSAM(segSess, img, info.inputSize, seed);
        }else if(segKey==='clipseg'){
          if(!state.ai.prompt){ log('CLIPSeg: empty prompt ‚Üí defaulting to click seed fallback.'); baseMask = null; }
          else baseMask = await segWithCLIPSeg(segSess, img, info.inputSize, state.ai.prompt);
        }
        if(!baseMask) throw new Error('No mask from model');
        state.ai.outputs.baseMask=baseMask;
      }catch(err){
        log('Segmentation failed ‚Üí fallback:', err?.message||err);
        // Fallback to worker edgeGrow around seed
        if(segReady){ await requestSegMask('autoSmart', seed.x, seed.y, state.tol, state.aggr); }
        else{
          const m = magicWandMask(img, seed.x, seed.y, state.tol/100, state.aggr);
          if(m){ state.selections.push({type:'mask',maskCanvas:m,generator:{tool:'edgeGrow',seedX:seed.x,seedY:seed.y,params:{tol:state.tol,aggr:state.aggr},origin:'ai-fallback'}}); }
        }
      }

      // DEPTH
      let depthRes=null;
      try{
        if(depthSess){ depthRes = await depthPredict(depthSess, img, MODEL_URLS[state.ai.depthModel].inputSize); }
        else throw new Error('depth session missing');
      }catch(err){
        log('Depth failed ‚Üí synthetic luminance depth:', err?.message||err);
        depthRes = syntheticDepth(img);
      }
      state.ai.outputs.depthCanvas = depthRes.canvas; state.ai.outputs.depthMap = depthRes.map;

      // Show thumbs BEFORE refine/math
      drawThumb(dom.aiMaskThumb, state.ai.outputs.baseMask || lastMaskFromSelections(), img);
      drawThumb(dom.aiDepthThumb, state.ai.outputs.depthCanvas, img);

      // VARIANTS (generate 5 and display)
      await generateVariantsAndShow();

      // Pick best default (variant #3) as final
      selectVariant(2); // middle one often balanced
      schedulePreviewRender(true);
      history.save();
      dom.aiStatus.textContent='done';
      finishProgress();
    }

    function drawThumb(canvas, sourceCanvas, img){
      if(!canvas) return;
      const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
      if(!sourceCanvas){ return; }
      const aspect=img.height/img.width; const th=Math.round(canvas.width*aspect); canvas.height=th;
      ctx.imageSmoothingEnabled=false; ctx.drawImage(sourceCanvas,0,0,canvas.width,canvas.height);
    }

    function lastMaskFromSelections(){ for(let i=state.selections.length-1;i>=0;i--){ const s=state.selections[i]; if(s.type==='mask'&&s.maskCanvas) return s.maskCanvas; } return null; }

    /* YOLO seg (decoding similar to previous attempt, but guarded) */
    async function segWithYOLO(session,img,inputSize,seed){
      const {tensor, scale, dx, dy} = makeLetterboxInput(img,inputSize);
      const feeds={}; feeds[session.inputNames?.[0]||'images']=tensor;
      const outputs = await session.run(feeds);
      const names = Object.keys(outputs);
      if(names.length<2) throw new Error('unexpected outputs');
      const det=outputs[names[0]], proto=outputs[names[1]];
      return decodeYOLO(det,proto,inputSize,scale,dx,dy,img.width,img.height,seed);
    }
    function decodeYOLO(det,proto,inputSize,scale,dx,dy,outW,outH,seed){
      const detData=det.data, detShape=det.dims; const protoData=proto.data, protoShape=proto.dims; // [1,N,C], [1,maskDim,mh,mw]
      const N=detShape[1], C=detShape[2], maskDim=protoShape[1]; const clsCount=C-4-1-maskDim;
      const candidates=[];
      for(let i=0;i<N;i++){
        const off=i*C; const cx=detData[off+0], cy=detData[off+1], bw=detData[off+2], bh=detData[off+3]; const conf=detData[off+4];
        if(conf<0.2) continue;
        let best=-1,score=-1; for(let c=0;c<clsCount;c++){ const sc=detData[off+5+c]; if(sc>best){best=sc; score=sc;} }
        const final=conf*score; if(final<0.25) continue;
        const coeff=detData.slice(off+5+clsCount,off+5+clsCount+maskDim);
        const x1=cx-bw/2, y1=cy-bh/2, x2=cx+bw/2, y2=cy+bh/2;
        candidates.push({x1,y1,x2,y2,score:final,coeff});
      }
      candidates.sort((a,b)=>b.score-a.score);
      const kept=[]; const iouThr=0.5;
      for(const a of candidates){
        let ok=true; for(const b of kept){ if(IOU(a,b)>iouThr){ ok=false; break; } }
        if(ok) kept.push(a); if(kept.length>20) break;
      }
      if(kept.length===0) return null;

      const mw=protoShape[3], mh=protoShape[2]; const maskDim=protoShape[1];
      // build proto matrix transposed: we‚Äôll compute on the fly
      let chosen=null, bestScore=-1;
      for(const det of kept){
        const mSmall=document.createElement('canvas'); mSmall.width=mw; mSmall.height=mh; const sctx=mSmall.getContext('2d'); const id=sctx.createImageData(mw,mh);
        for(let i=0;i<mw*mh;i++){
          let s=0; for(let k=0;k<maskDim;k++) s += protoData[k*mw*mh + i] * det.coeff[k];
          const v=1/(1+Math.exp(-s)); const a=Math.round(255*clamp(v,0,1)); const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=a;
        }
        sctx.putImageData(id,0,0);

        // place into image coords: invert letterbox
        const maskCanvas=document.createElement('canvas'); maskCanvas.width=outW; maskCanvas.height=outH; const mctx=maskCanvas.getContext('2d');
        mctx.drawImage(mSmall,0,0,inputSize,inputSize, -dx, -dy, inputSize/scale, inputSize/scale);

        if(seed){
          if(maskHit(maskCanvas,seed.x,seed.y)) return maskCanvas;
          // else keep best by score and proximity
          const cx=(det.x1+det.x2)/2, cy=(det.y1+det.y2)/2; const dxs=seed.x - (cx-dx)/scale, dys=seed.y - (cy-dy)/scale;
          const prox=Math.hypot(dxs,dys); const score=det.score/(1+0.001*prox); if(score>bestScore){ bestScore=score; chosen=maskCanvas; }
        }else{
          if(det.score>bestScore){ bestScore=det.score; chosen=maskCanvas; }
        }
      }
      return chosen;
    }
    function IOU(a,b){ const xx1=Math.max(a.x1,b.x1),yy1=Math.max(a.y1,b.y1),xx2=Math.min(a.x2,b.x2),yy2=Math.min(a.y2,b.y2); const w=Math.max(0,xx2-xx1),h=Math.max(0,yy2-yy1); const inter=w*h; const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1); return inter/Math.max(1e-6, areaA+areaB-inter); }
    function makeLetterboxInput(img,size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d'); x.fillStyle='#000'; x.fillRect(0,0,size,size);
      const r=Math.min(size/img.width,size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r); const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
      x.drawImage(img,dx,dy,nw,nh); const d=x.getImageData(0,0,size,size).data; const arr=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ arr[j++]=d[i]/255; arr[j++]=d[i+1]/255; arr[j++]=d[i+2]/255; }
      const tensor=new ort.Tensor('float32',arr,[1,size,size,3]); return {tensor,scale:r,dx,dy};
    }

    /* MobileSAM best-effort (point) */
    async function segWithMobileSAM(session,img,inputSize,seed){
      if(!seed) throw new Error('MobileSAM needs a click point');
      // Simplified preprocessing + feeds; many MobileSAM ONNX exports vary; we guard failures.
      try{
        const c=document.createElement('canvas'); c.width=inputSize; c.height=inputSize; const cx=c.getContext('2d'); cx.drawImage(img,0,0,inputSize,inputSize);
        const d=cx.getImageData(0,0,inputSize,inputSize).data; const a=new Float32Array(inputSize*inputSize*3);
        for(let i=0,j=0;i<d.length;i+=4){ a[j++]=(d[i]/255 - 0.5)/0.5; a[j++]=(d[i+1]/255 - 0.5)/0.5; a[j++]=(d[i+2]/255 - 0.5)/0.5; }
        const tImg=new ort.Tensor('float32',a,[1,inputSize,inputSize,3]);
        const pn = session.inputNames?.find(n=>/point/i.test(n)) || 'point_coords';
        const imgName = session.inputNames?.find(n=>/image|input/i.test(n)) || 'input_image';
        const feeds={}; feeds[imgName]=tImg; feeds[pn]= new ort.Tensor('float32', new Float32Array([seed.x/img.width, seed.y/img.height]), [1,2]);
        const outs=await session.run(feeds); const out = outs[Object.keys(outs)[0]];
        return tensorToMaskCanvas(out, img.width, img.height);
      }catch(e){ throw new Error('MobileSAM signature mismatch'); }
    }
    function tensorToMaskCanvas(tensor,outW,outH){
      const data=tensor.data, dims=tensor.dims;
      let H=0,W=0; if(dims.length===4){ H=dims[dims.length-2]; W=dims[dims.length-1]; } else if(dims.length===3){ H=dims[1]; W=dims[2]; } else throw new Error('bad dims');
      const s=document.createElement('canvas'); s.width=W; s.height=H; const sx=s.getContext('2d'); const id=sx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=1/(1+Math.exp(-(data[i]||0))); const a=Math.round(255*clamp(v,0,1)); const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=a; }
      sx.putImageData(id,0,0);
      const c=document.createElement('canvas'); c.width=outW; c.height=outH; const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(s,0,0,outW,outH);
      return c;
    }

    /* CLIPSeg (prompt) ‚Äì best-effort; if shape/signature mismatches, we fallback */
    async function segWithCLIPSeg(session,img,inputSize,prompt){
      try{
        // Simple image resize NHWC [1,H,W,3] in [0,1]; text embedding handling varies; some ONNX bundles include text encoder.
        const c=document.createElement('canvas'); c.width=inputSize; c.height=inputSize; const x=c.getContext('2d'); x.drawImage(img,0,0,inputSize,inputSize);
        const d=x.getImageData(0,0,inputSize,inputSize).data; const a=new Float32Array(inputSize*inputSize*3);
        for(let i=0,j=0;i<d.length;i+=4){ a[j++]=d[i]/255; a[j++]=d[i+1]/255; a[j++]=d[i+2]/255; }
        const tImg=new ort.Tensor('float32',a,[1,inputSize,inputSize,3]);
        // Text: very model-specific; we try feeding a naive [1,77,512] zeros which some refined exporters ignore (class-agnostic)
        const txt = new Float32Array(77*512); // zeros
        const feeds={}; const names=session.inputNames||[];
        const imgName=names.find(n=>/image|input/i.test(n)) || names[0]; feeds[imgName]=tImg;
        const textName=names.find(n=>/text|prompt/i.test(n)); if(textName) feeds[textName]= new ort.Tensor('float32', txt, [1,77,512]);
        const outs=await session.run(feeds); const out=outs[Object.keys(outs)[0]];
        return tensorToMaskCanvas(out, img.width, img.height);
      }catch(e){ log('CLIPSeg failed:', e?.message||e); return null; }
    }

    /* Depth prediction */
    async function depthPredict(session,img,inputSize){
      const {tensor} = prepareDepthInput(img,inputSize);
      const inputName = session.inputNames?.[0]||'input';
      const outs = await session.run({[inputName]:tensor});
      const out = outs[Object.keys(outs)[0]];
      return toDepthCanvasAndMap(out,img.width,img.height);
    }
    function prepareDepthInput(img,size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d');
      const r=Math.min(size/img.width,size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r); const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
      x.fillStyle='#000'; x.fillRect(0,0,size,size); x.drawImage(img,dx,dy,nw,nh);
      const d=x.getImageData(0,0,size,size).data; const a=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ a[j++]=d[i]/255; a[j++]=d[i+1]/255; a[j++]=d[i+2]/255; }
      const t=new ort.Tensor('float32',a,[1,size,size,3]); return {tensor:t};
    }
    function toDepthCanvasAndMap(out,outW,outH){
      const dims=out.dims, data=out.data; let H=dims[dims.length-2], W=dims[dims.length-1]; if(!H||!W){ H=outW; W=outH; }
      let mn=Infinity,mx=-Infinity; for(let i=0;i<data.length;i++){ const v=data[i]; if(v<mn) mn=v; if(v>mx) mx=v; } const range=mx-mn||1;
      const s=document.createElement('canvas'); s.width=W; s.height=H; const sx=s.getContext('2d'); const id=sx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=(data[i]-mn)/range; const g=Math.round(255*v); const p=i*4; id.data[p]=g; id.data[p+1]=g; id.data[p+2]=g; id.data[p+3]=255; }
      sx.putImageData(id,0,0);
      const big=document.createElement('canvas'); big.width=outW; big.height=outH; big.getContext('2d').drawImage(s,0,0,outW,outH);
      // map
      const map=new Float32Array(outW*outH); const bd=big.getContext('2d').getImageData(0,0,outW,outH).data;
      for(let i=0,j=0;i<map.length;i++,j+=4) map[i]=bd[j]/255;
      return {canvas:big, map};
    }
    function syntheticDepth(img){
      const c=document.createElement('canvas'); c.width=img.width; c.height=img.height; const x=c.getContext('2d'); x.drawImage(img,0,0); const d=x.getImageData(0,0,c.width,c.height); const data=d.data;
      for(let i=0;i<data.length;i+=4){ const y=0.2126*data[i]+0.7152*data[i+1]+0.0722*data[i+2]; data[i]=data[i+1]=data[i+2]=y; data[i+3]=255; }
      x.putImageData(d,0,0);
      const map=new Float32Array(img.width*img.height); for(let i=0,j=0;i<map.length;i++,j+=4) map[i]=d.data[j]/255;
      return {canvas:c, map};
    }

    /* Variants: create 5 alternatives using depth band & morph tweaks */
    async function generateVariantsAndShow(){
      const base = state.ai.outputs.baseMask || lastMaskFromSelections();
      const depth = state.ai.outputs.depthMap;
      const W=state.image.width,H=state.image.height;
      const seed = state.ai.lastClick || {x:Math.round(W/2),y:Math.round(H/2)};

      const variants=[];
      if(!base){ // fallback: make one from worker seed to still show suggestions
        const fb = magicWandMask(state.image, seed.x, seed.y, state.tol/100, state.aggr);
        if(fb) variants.push({canvas:fb,label:'Auto'});
      }else{
        // produce 5 bands
        const bands=[0.04,0.06,0.08,0.10,0.13];
        for(let i=0;i<5;i++){
          const vMask = state.ai.refine? refineWithDepth(base, depth, W,H, seed, bands[i]) : depthBandMask(base, depth, W,H, seed, bands[i]);
          variants.push({canvas:vMask,label:`Band ${Math.round(bands[i]*100)}%`});
        }
      }
      state.ai.outputs.variants = variants;
      // render into UI
      dom.aiVariants.innerHTML='';
      variants.forEach((v,idx)=>{
        const cell=document.createElement('div'); cell.className='variant';
        const c=document.createElement('canvas'); c.width=152; c.height=Math.round(152*(H/W)); const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(v.canvas,0,0,c.width,c.height);
        const lab=document.createElement('label'); lab.textContent = v.label;
        cell.appendChild(c); cell.appendChild(lab);
        cell.addEventListener('click',()=> selectVariant(idx));
        dom.aiVariants.appendChild(cell);
      });
    }
    function selectVariant(idx){
      const items=[...dom.aiVariants.querySelectorAll('.variant')]; items.forEach(el=>el.classList.remove('active'));
      if(items[idx]) items[idx].classList.add('active');
      const chosen=state.ai.outputs.variants[idx]; if(chosen){ state.ai.outputs.finalMask = chosen.canvas; schedulePreviewRender(true); }
    }

    function depthBandMask(baseMaskCanvas, depthMap, W,H, seed, band){
      if(!depthMap) return baseMaskCanvas;
      // compute seed depth
      const sd = depthMap[seed.y*W + seed.x];
      const lo=Math.max(0, sd-band), hi=Math.min(1, sd+band);
      // intersect base with band
      const out=document.createElement('canvas'); out.width=W; out.height=H; const ox=out.getContext('2d');
      // band canvas
      const bandC=document.createElement('canvas'); bandC.width=W; bandC.height=H; const bx=bandC.getContext('2d'); const id=bx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=depthMap[i]; const ok=(v>=lo&&v<=hi)?255:0; const p=i*4; id.data[p]=255; id.data[p+1]=255; id.data[p+2]=255; id.data[p+3]=ok; } bx.putImageData(id,0,0);
      ox.drawImage(baseMaskCanvas,0,0); ox.globalCompositeOperation='destination-in'; ox.drawImage(bandC,0,0); ox.globalCompositeOperation='source-over';
      // slight blur to soften
      const soft = blurMask(out, 1.2); return soft;
    }

    function refineWithDepth(baseMaskCanvas, depthMap, W,H, seed, band){
      // depth band + slight dilation + intersection to tighten edges
      const banded = depthBandMask(baseMaskCanvas, depthMap, W,H, seed, band);
      const refined = blurMask(banded, 0.8);
      return refined;
    }

    function blurMask(maskCanvas, r){
      const W=maskCanvas.width,H=maskCanvas.height; const out=document.createElement('canvas'); out.width=W; out.height=H; const x=out.getContext('2d'); x.filter=`blur(${r}px)`; x.drawImage(maskCanvas,0,0); x.filter='none'; return out;
    }

    /* AI helpers */
    function setStatus(t){ dom.aiStatus.textContent=t; }

    /* Hotkeys */
    window.addEventListener('keydown',(e)=>{
      if(e.code==='Space' && !state.isPanning){ state.isPanning=true; dom.editorWrap.classList.add('panning'); }
      if((e.key==='Delete'||e.key==='Backspace') && state.activeIndex!==-1){ const removed=state.selections.splice(state.activeIndex,1)[0]; state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted selection:', removed?.type||''); }
      if(e.ctrlKey||e.metaKey){ if(e.key.toLowerCase()==='z'){ e.preventDefault(); history.undo(); } if(e.key.toLowerCase()==='y'){ e.preventDefault(); history.redo(); } }
      if(e.key.toLowerCase()==='s'){ setAIMode(false); setMode('lasso'); }
      if(e.key.toLowerCase()==='b'){ setAIMode(false); setMode('box'); }
      if(e.key.toLowerCase()==='w'){ setAIMode(false); setMode('autoWand'); }
      if(e.key.toLowerCase()==='g'){ setAIMode(false); setMode('autoSmart'); }
      if(e.key.toLowerCase()==='u'){ setAIMode(false); setMode('autoUltra'); }
      if(e.key.toLowerCase()==='e'){ setAIMode(false); setMode('protectEraser'); }
      if(e.key.toLowerCase()==='r'){ setAIMode(false); setMode('removeEraser'); }
    });
    window.addEventListener('keyup',(e)=>{ if(e.code==='Space'){ state.isPanning=false; dom.editorWrap.classList.remove('panning'); } });

    /* Small helpers */
    function hitBoxHandle(sel,x,y){
      const pad=8/state.transform.scale;
      const pts=[ ['nw',sel.x,sel.y], ['n',sel.x+sel.w/2,sel.y], ['ne',sel.x+sel.w,sel.y], ['e',sel.x+sel.w,sel.y+sel.h/2], ['se',sel.x+sel.w,sel.y+sel.h], ['s',sel.x+sel.w/2,sel.y+sel.h], ['sw',sel.x,sel.y+sel.h], ['w',sel.x,sel.y+sel.h/2] ];
      for(const [name,px,py] of pts){ if(Math.abs(x-px)<=pad && Math.abs(y-py)<=pad) return name; } return null;
    }

  })();
  </script>
</body>
</html>
