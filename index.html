<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Color Splash Pro X ‚Äî v5.0.0 (Stable UI ‚Ä¢ Auto-layout ONNX ‚Ä¢ Live Progress)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
  :root{
    --bg:#eef2f7;--panel:#fff;--ink:#0f172a;--border:#e5e7eb;
    --p:#2563eb;--p2:#1e40af;--ok:#065f46;--warn:#92400e;--err:#7f1d1d
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink);display:flex;flex-direction:column;overflow:hidden}
  header{display:flex;align-items:center;gap:.6rem;padding:.55rem .75rem;background:var(--panel);border-bottom:1px solid var(--border);box-shadow:0 1px 8px rgba(0,0,0,.06);z-index:5}
  .brand{font-weight:800;color:var(--p)}
  .toolbar{display:flex;gap:.4rem;align-items:center;flex-wrap:wrap}
  button,select,input[type="number"],input[type="text"],input[type="range"]{
    background:#fff;border:1px solid var(--border);border-radius:8px;padding:.38rem .58rem;font-weight:600
  }
  button{cursor:pointer}
  button.primary{background:var(--p);color:#fff;border-color:var(--p)}
  button.primary:hover{background:var(--p2)}
  .chip{background:#f1f5f9;border:1px solid var(--border);font-size:.8rem;padding:.18rem .5rem;border-radius:999px}
  .kv{font-size:.75rem;color:#334155;background:#f8fafc;border:1px dashed #d1e3ff;padding:.1rem .35rem;border-radius:6px}
  .root{flex:1;min-height:0;padding:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;height:100%;min-height:0}
  .panel{display:flex;flex-direction:column;min-height:0;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,.06);position:relative}
  .ph{padding:.5rem .75rem;border-bottom:1px solid var(--border);font-weight:700;color:#334155;display:flex;align-items:center;justify-content:space-between}
  .pc{position:relative;flex:1;min-height:0;overflow:hidden;background:#e9eef6}
  .wrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{background:#fff;border:1px solid #0000000a;max-width:100%;max-height:100%}
  .hint{position:absolute;pointer-events:none;color:#334155;background:#fff;border:1px solid var(--border);border-radius:999px;padding:.25rem .65rem}
  .thumbs{border-top:1px solid var(--border);background:#fff;display:grid;grid-template-columns:repeat(3,1fr);gap:8px;padding:8px}
  .thumb{display:flex;flex-direction:column;align-items:center;gap:4px}
  .thumb canvas{width:100%;max-width:220px;height:auto;border:1px solid var(--border);border-radius:8px;background:#fff}
  .cap{font-size:.78rem;color:#475569}
  .thumbs.float{position:absolute;z-index:4;top:8px;right:8px;width:420px;grid-template-columns:1fr;background:#ffffffef;border:1px solid var(--border);border-radius:10px;padding:8px;box-shadow:0 10px 28px rgba(0,0,0,.25)}
  .thumbs.float.left{left:8px;right:auto}
  #logBtn{position:fixed;right:12px;bottom:12px;z-index:50;background:var(--p);color:#fff;border:none;border-radius:999px;padding:.6rem .85rem;font-weight:800;box-shadow:0 10px 26px rgba(0,0,0,.25)}
  #logs{position:fixed;right:12px;bottom:64px;width:620px;height:68vh;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 16px 38px rgba(0,0,0,.28);display:none;grid-template-rows:auto auto 1fr auto;z-index:60}
  #logs.visible{display:grid}
  #logs h3{margin:.6rem .75rem}
  #logs .help{margin:0 .75rem .6rem;color:#334155;font-size:.86rem;background:#fafbff;border-top:1px solid var(--border);border-bottom:1px solid var(--border);padding:.5rem}
  #logs pre{margin:0;padding:.5rem .6rem;font-family:ui-monospace,Consolas,Menlo,monospace;font-size:.83rem;overflow:auto;white-space:pre-wrap;word-break:break-word}
  #logs .foot{border-top:1px solid var(--border);display:grid;grid-template-columns:1fr 1fr 1fr;gap:.4rem;padding:.5rem .6rem}
  .progress{position:absolute;left:12px;right:12px;bottom:12px;height:10px;border-radius:6px;background:#eef2ff;border:1px solid #dde6ff;overflow:hidden;box-shadow:inset 0 1px 0 rgba(0,0,0,.03);display:none}
  .barp{height:100%;width:0%;background:linear-gradient(90deg,#7aa2ff,#2563eb)}
  .status{position:absolute;left:12px;bottom:28px;background:#111827;color:#fff;padding:.18rem .45rem;border-radius:6px;font-size:.72rem;opacity:.95}
  .hidden{display:none!important}
  .ver{position:fixed;top:8px;right:8px;background:#111827;color:#fff;font-size:.72rem;padding:.22rem .45rem;border-radius:6px;opacity:.9;z-index:70}
  /* Stepper */
  .stepper{display:flex;gap:6px;align-items:center}
  .step{font-size:.72rem;padding:.2rem .45rem;border-radius:6px;border:1px solid var(--border);background:#f8fafc}
  .step.active{background:#e0ecff;border-color:#bcd2ff;color:#153e75}
  .step.ok{background:#dcfce7;border-color:#86efac;color:#065f46}
  .step.err{background:#fee2e2;border-color:#fecaca;color:#7f1d1d}
  /* Overlay blocking while running */
  .blocker{position:absolute;inset:0;background:rgba(255,255,255,.0);pointer-events:none}
  .toast{position:absolute;top:8px;left:8px;background:#111827;color:#fff;padding:.25rem .5rem;border-radius:6px;font-size:.75rem;opacity:.92}
</style>
</head>
<body>
<div class="ver">v5.0.0</div>

<header>
  <div class="brand">Color Splash Pro X</div>
  <div class="toolbar">
    <button id="btnImage" class="primary">üì§ Image</button>
    <button id="btnReset">üßπ Reset</button>
    <button id="btnSave">‚¨áÔ∏è Download</button>
    <span class="chip" id="aiBadge">ü§ñ AI: ON</span>
  </div>
  <div style="flex:1"></div>

  <div class="toolbar" id="aiBar">
    <div class="stepper" id="stepper">
      <div class="step" id="st1">1 Download</div>
      <div class="step" id="st2">2 Segment</div>
      <div class="step" id="st3">3 Depth</div>
      <div class="step" id="st4">4 Compose</div>
    </div>
  </div>
</header>

<div class="root">
  <div class="grid">
    <section class="panel" id="leftPanel">
      <div class="ph">ORIGINAL ‚Äî Editor (click seed ¬∑ drag-drop ¬∑ wheel zoom)
        <div class="toolbar">
          <span class="kv">Seg:</span>
          <select id="selSeg"></select>
          <span class="kv">Depth:</span>
          <select id="selDepth"></select>
          <span class="kv">Effect:</span>
          <select id="selEffect">
            <option value="seg">Segmentation only</option>
            <option value="depth-band">Depth: seed band</option>
            <option value="depth-thresh">Depth: global threshold</option>
            <option value="edges">Edges (RGB): Sobel+Laplace</option>
            <option value="depth-canny">Depth Canny (no seed)</option>
            <option value="depth-canny-seed">Depth Canny (seed)</option>
            <option value="seg-and-depth">Seg ‚à© Depth</option>
            <option value="seg-and-edges">Seg ‚à© RGB-Edges</option>
            <option value="seg-and-depth-and-edges">Seg ‚à© Depth ‚à© RGB-Edges</option>
            <option value="edge-bound-grow">RGB-Edge-Bound Grow (seed)</option>
          </select>
          <span class="kv">Band</span><input id="rngBand" type="range" min="0.01" max="0.25" step="0.005" value="0.07" title="Depth band around seed"/>
          <span class="kv">Depth T</span><input id="rngDepthT" type="range" min="0" max="1" step="0.01" value="0.5" title="Depth threshold"/>
          <span class="kv">Edge T</span><input id="rngEdgeT" type="range" min="0.02" max="0.6" step="0.01" value="0.18" title="Edge threshold"/>
          <span class="kv">Feather</span><input id="numFeather" type="number" min="0" max="12" step="1" value="2" style="width:64px"/>
          <button id="btnRun" class="primary">üöÄ Use</button>
          <span id="aiStatus" class="chip">ready</span>
        </div>
      </div>
      <div class="pc" id="edBox">
        <div class="wrap">
          <canvas id="edCanvas" aria-label="Editor image"></canvas>
          <div class="hint" id="edHint">Click or drop an image</div>
        </div>
        <div class="progress" id="dlProg"><div class="barp" id="dlBar"></div></div>
        <div class="status hidden" id="dlStatus"></div>
        <div class="blocker" id="blocker"><div class="toast" id="toast">Idle</div></div>
      </div>
    </section>

    <section class="panel" id="rightPanel">
      <div class="ph">PREVIEW ‚Äî Color Splash</div>
      <div class="pc" id="pvBox">
        <div class="wrap"><canvas id="pvCanvas" aria-label="Preview image"></canvas></div>
      </div>
      <div class="thumbs" id="thumbs">
        <div class="thumb"><canvas id="thSeg"></canvas><div class="cap">Segmentation Mask</div></div>
        <div class="thumb"><canvas id="thDepth"></canvas><div class="cap">Depth Map</div></div>
        <div class="thumb"><canvas id="thFinal"></canvas><div class="cap">Final Mask</div></div>
      </div>
    </section>
  </div>
</div>

<button id="logBtn" title="Open logs">üí¨ Logs</button>
<div id="logs" aria-modal="true">
  <h3>AI Logs & Model Manager</h3>
  <div class="help">
    GitHub Releases tried first (√ó3), then Dropbox DIRECT. Cached in IndexedDB (‚Äúonnx‚Äù store).  
    Use ‚ÄúSelf-Test‚Äù to HEAD-check endpoints. If a model is already cached, it won‚Äôt re-download.
  </div>
  <pre id="log"></pre>
  <div class="foot">
    <button id="btnClearLog">Clear Logs</button>
    <button id="btnClearCache">Clear Cache</button>
    <button id="btnSelfTest">Self-Test Links</button>
  </div>
</div>

<input id="fileImage" type="file" accept="image/*" hidden/>

<script>
(()=>{'use strict';

/* ===========================
   DOM & STATE
=========================== */
const $=id=>document.getElementById(id);
const dom={
  btnImage:$('btnImage'),btnReset:$('btnReset'),btnSave:$('btnSave'),aiBadge:$('aiBadge'),
  selSeg:$('selSeg'),selDepth:$('selDepth'),selEffect:$('selEffect'),
  rngBand:$('rngBand'),rngDepthT:$('rngDepthT'),rngEdgeT:$('rngEdgeT'),numFeather:$('numFeather'),btnRun:$('btnRun'),aiStatus:$('aiStatus'),
  edBox:$('edBox'),edCanvas:$('edCanvas'),edHint:$('edHint'),pvBox:$('pvBox'),pvCanvas:$('pvCanvas'),
  thumbs:$('thumbs'),thSeg:$('thSeg'),thDepth:$('thDepth'),thFinal:$('thFinal'),
  logBtn:$('logBtn'),logs:$('logs'),log:$('log'),btnClearLog:$('btnClearLog'),btnClearCache:$('btnClearCache'),btnSelfTest:$('btnSelfTest'),
  fileImage:$('fileImage'),dlProg:$('dlProg'),dlBar:$('dlBar'),dlStatus:$('dlStatus'),
  blocker:$('blocker'),toast:$('toast'),
  st1:$('st1'),st2:$('st2'),st3:$('st3'),st4:$('st4')
};
const ED={c:dom.edCanvas,ctx:dom.edCanvas.getContext('2d',{willReadFrequently:true})};
const PV={c:dom.pvCanvas,ctx:dom.pvCanvas.getContext('2d',{willReadFrequently:true})};

const S={
  aiOn:true,img:null,seed:null,ed:{x:0,y:0,s:1},
  segKey:'db-yolov8n-seg',depthKey:'db-da-v2-small',effect:'seg',
  sessions:Object.create(null),cache:Object.create(null),sessionLayout:Object.create(null),
  maskCanvas:null,depthCanvas:null,depthMap:null,jobId:0 // to cancel stale runs
};

/* ===========================
   MODEL SOURCES
=========================== */
const MODELS={
  // SEGMENTATION
  'edgegrow':{type:'seg',label:'No model (EdgeGrow)',size:640},
  'gh-yolov8n-seg':{type:'seg',label:'YOLOv8n-seg (GitHub‚ÜíDB)',size:640,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/yolov8n-seg.onnx',
    db:'https://dl.dropboxusercontent.com/scl/fi/g3hh1rpbn4es4pqbgypj8/yolov8n-seg.onnx?rlkey=0etbjr7tb8jsrctn2l3wv2amy&dl=1'},
  'db-yolov8n-seg':{type:'seg',label:'YOLOv8n-seg (Dropbox)',size:640,
    db:'https://dl.dropboxusercontent.com/scl/fi/g3hh1rpbn4es4pqbgypj8/yolov8n-seg.onnx?rlkey=0etbjr7tb8jsrctn2l3wv2amy&dl=1'},
  'gh-fastsam-s':{type:'seg',label:'FastSAM-s (GitHub‚ÜíDB)',size:640,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/FastSAM-s.onnx',
    db:'https://github.com/nomsams/imgsplash/releases/download/models/FastSAM-s.onnx'}, // keep GH for cache key; GH first still
  'gh-fastsam-x':{type:'seg',label:'FastSAM-X (GitHub‚ÜíDB)',size:640,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/FastSam-X.onnx',
    db:'https://dl.dropboxusercontent.com/scl/fi/hpwyjvgc9yl0mbf2ty9dr/FastSam-X.onnx?rlkey=i9kfkcucagp5tb4qm0m1fgwm5&dl=1'},
  'db-fastsam-x':{type:'seg',label:'FastSAM-X (Dropbox)',size:640,
    db:'https://dl.dropboxusercontent.com/scl/fi/hpwyjvgc9yl0mbf2ty9dr/FastSam-X.onnx?rlkey=i9kfkcucagp5tb4qm0m1fgwm5&dl=1'},

  // DEPTH
  'none':{type:'depth',label:'None',size:256},
  'gh-midas-small':{type:'depth',label:'MiDaS v2.1 Small (GitHub‚ÜíDB)',size:256,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/midas_small.onnx',
    db:'https://dl.dropboxusercontent.com/scl/fi/ljsrtwxbd5oscq6hgthrk/midas_small.onnx?rlkey=emtxd6xhxsjrpq8j2jbabqoxn&dl=1'},
  'db-midas-small':{type:'depth',label:'MiDaS v2.1 Small (Dropbox)',size:256,
    db:'https://dl.dropboxusercontent.com/scl/fi/ljsrtwxbd5oscq6hgthrk/midas_small.onnx?rlkey=emtxd6xhxsjrpq8j2jbabqoxn&dl=1'},
  'gh-da-v2-small':{type:'depth',label:'Depth Anything v2 Small FP32 (GitHub‚ÜíDB)',size:518,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small.onnx',
    db:'https://dl.dropboxusercontent.com/scl/fi/oif7z9iap5ua1wlef04e3/depth_anything_v2_small.onnx?rlkey=tfv2lz4xalrxp30fmoes006gy&dl=1'},
  'db-da-v2-small':{type:'depth',label:'Depth Anything v2 Small FP32 (Dropbox)',size:518,
    db:'https://dl.dropboxusercontent.com/scl/fi/oif7z9iap5ua1wlef04e3/depth_anything_v2_small.onnx?rlkey=tfv2lz4xalrxp30fmoes006gy&dl=1'},
  'gh-da-v2-small-int8':{type:'depth',label:'Depth Anything v2 Small INT8 (GitHub‚ÜíDB)',size:518,
    gh:'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small_int8.onnx',
    db:'https://www.dropbox.com/scl/fi/8brcbml22th9om9axdv5t/depth_anything_v2_small_int8.onnx?rlkey=rqkjeu0bd222xx9sr13qdywnz&dl=1'},
  'db-da-v2-small-int8':{type:'depth',label:'Depth Anything v2 Small INT8 (Dropbox)',size:518,
    db:'https://www.dropbox.com/scl/fi/8brcbml22th9om9axdv5t/depth_anything_v2_small_int8.onnx?rlkey=rqkjeu0bd222xx9sr13qdywnz&dl=1'}
};

/* ===========================
   UI BUILDERS
=========================== */
function buildOpts(sel, filter){ sel.innerHTML=''; for(const [k,m] of Object.entries(MODELS)){ if(m.type!==filter) continue; const o=document.createElement('option'); o.value=k; o.textContent=m.label; sel.appendChild(o); } }
buildOpts(dom.selSeg,'seg'); buildOpts(dom.selDepth,'depth');
dom.selSeg.value=S.segKey; dom.selDepth.value=S.depthKey;

/* ===========================
   LOGGING / FEEDBACK
=========================== */
function log(...args){
  const msg=`[${new Date().toLocaleTimeString()}] ${args.join(' ')}`;
  dom.log.textContent += msg + '\n';
  dom.log.scrollTop = dom.log.scrollHeight;
  console.debug(...args);
}
function toast(msg, color=null){
  dom.toast.textContent = msg;
  if(color==='ok'){ dom.toast.style.background='#065f46'; }
  else if(color==='err'){ dom.toast.style.background='#7f1d1d'; }
  else if(color==='warn'){ dom.toast.style.background='#92400e'; }
  else { dom.toast.style.background='#111827'; }
}
function setStep(activeIndex, state){ // state: 'active' | 'ok' | 'err' | ''
  const steps=[dom.st1,dom.st2,dom.st3,dom.st4];
  steps.forEach((s,i)=>{
    s.classList.remove('active','ok','err');
    if(i===activeIndex){
      if(state==='active') s.classList.add('active');
      else if(state==='ok') s.classList.add('ok');
      else if(state==='err') s.classList.add('err');
    }
  });
}
function showProg(){ dom.dlProg.style.display='block'; dom.dlBar.style.width='0%' }
function setProg(p){ dom.dlBar.style.width=Math.max(0,Math.min(100,p)).toFixed(1)+'%' }
function hideProg(){ dom.dlProg.style.display='none' }
function statusText(t, kind=null){
  dom.dlStatus.classList.remove('hidden');
  dom.dlStatus.textContent = t;
  dom.dlStatus.style.background = kind==='ok'?'#065f46' : kind==='err'?'#7f1d1d' : kind==='warn'?'#92400e' : '#111827';
}

/* ===========================
   INDEXEDDB CACHE
=========================== */
let idb=null;
async function idbOpen(){
  if(idb) return idb;
  idb = await new Promise((res,rej)=>{
    const req = indexedDB.open('cspx-models', 3);
    req.onupgradeneeded = () => {
      const db=req.result;
      if(!db.objectStoreNames.contains('onnx')) db.createObjectStore('onnx');
    };
    req.onsuccess = ()=>res(req.result);
    req.onerror = ()=>rej(req.error);
  });
  return idb;
}
async function idbGet(k){
  try{
    const db=await idbOpen();
    return await new Promise((res,rej)=>{
      const tx=db.transaction('onnx','readonly');
      const rq=tx.objectStore('onnx').get(k);
      rq.onsuccess=()=>res(rq.result||null);
      rq.onerror=()=>rej(rq.error);
    });
  }catch(e){ log('IDB get fail:', e.message||e); return null; }
}
async function idbSet(k,buf){
  try{
    const db=await idbOpen();
    return await new Promise((res,rej)=>{
      const tx=db.transaction('onnx','readwrite');
      tx.objectStore('onnx').put(buf,k);
      tx.oncomplete=()=>res();
      tx.onerror=()=>rej(tx.error);
    });
  }catch(e){ log('IDB set fail:',e.message||e); }
}
async function idbClear(){
  try{
    const db=await idbOpen();
    return await new Promise((res,rej)=>{
      const tx=db.transaction('onnx','readwrite');
      const rq=tx.objectStore('onnx').clear();
      rq.onsuccess=()=>res();
      rq.onerror=()=>rej(rq.error);
    });
  }catch(e){ log('IDB clear fail:',e.message||e); }
}

/* ===========================
   FETCH WITH PROGRESS & FALLBACK
=========================== */
async function fetchONNX(key){
  if(S.cache[key]) return S.cache[key];
  const cached = await idbGet(key);
  if(cached){
    const u8=new Uint8Array(cached);
    S.cache[key]=u8;
    log('Loaded from cache:', key, `${(u8.byteLength/1048576).toFixed(2)} MB`);
    return u8;
  }
  const info=MODELS[key]; if(!info) throw new Error('Unknown model '+key);
  async function fetchWithProgress(url){
    log('Fetch:', url); toast('Downloading model‚Ä¶'); setStep(0,'active'); statusText('Downloading model‚Ä¶');
    showProg(); setProg(0);
    const resp=await fetch(url,{mode:'cors',redirect:'follow',referrerPolicy:'no-referrer'});
    if(!resp.ok) throw new Error('HTTP '+resp.status);
    const len=+(resp.headers.get('Content-Length')||0); const r=resp.body.getReader(); let rec=0; const chunks=[];
    while(true){ const {value,done}=await r.read(); if(done) break; chunks.push(value); rec+=value.byteLength; if(len){ setProg(rec/len*100); statusText(`Downloading‚Ä¶ ${(rec/1048576).toFixed(2)} MB (${(rec/len*100).toFixed(1)}%)`);} }
    hideProg(); statusText('Download complete', 'ok'); toast('Model downloaded', 'ok');
    const blob=new Blob(chunks); const ab=await blob.arrayBuffer(); return ab;
  }
  let buf=null;
  // GitHub first (√ó3)
  if(info.gh){
    for(let i=1;i<=3;i++){
      try{
        statusText(`GitHub attempt ${i}/3‚Ä¶`); buf=await fetchWithProgress(info.gh); break;
      }catch(e){ log(`GitHub attempt ${i} failed:`, e.message||e); await new Promise(r=>setTimeout(r,150)); }
    }
  }
  // Dropbox as fallback
  if(!buf && info.db){
    try{ statusText('Trying Dropbox‚Ä¶'); buf=await fetchWithProgress(info.db); }
    catch(e){ statusText('Dropbox failed', 'err'); throw e; }
  }
  if(!buf) throw new Error('No source worked for '+key);
  await idbSet(key,buf);
  const u8=new Uint8Array(buf);
  S.cache[key]=u8;
  return u8;
}
async function pickProviders(){ try{ const a=await navigator.gpu?.requestAdapter(); if(a && ort.env.webgpu) return ['webgpu','wasm']; }catch{} return ['wasm']; }
async function ensureSession(key){
  if(key==='edgegrow'||key==='none') return null;
  if(S.sessions[key]) return S.sessions[key];
  dom.aiStatus.textContent=`loading ${key}‚Ä¶`; toast(`Loading ${MODELS[key].label}‚Ä¶`);
  try{
    const u8=await fetchONNX(key);
    const providers=await pickProviders();
    log(`Create ORT session [${providers.join('+')}]`, key);
    const sess=await ort.InferenceSession.create(u8,{executionProviders:providers,graphOptimizationLevel:'all'});
    S.sessions[key]=sess;
    dom.aiStatus.textContent='ready';
    toast('Model ready','ok');
    return sess;
  }catch(e){
    dom.aiStatus.textContent='failed';
    toast('Model failed','err');
    log('Model load failed:', key, e.message||e);
    throw e;
  }
}

/* ===========================
   CANVAS LAYOUT
=========================== */
function fitEditor(){
  const w=dom.edBox.clientWidth, h=dom.edBox.clientHeight;
  ED.c.width=w; ED.c.height=h;
  if(!S.img) return;
  const s=Math.min(w/S.img.width,h/S.img.height);
  S.ed.s=s; S.ed.x=(w - S.img.width*s)/2; S.ed.y=(h - S.img.height*s)/2;
}
function drawEditor(){
  const {ctx,c}=ED; ctx.clearRect(0,0,c.width,c.height);
  if(!S.img){ dom.edHint.style.display='block'; return; }
  dom.edHint.style.display='none';
  ctx.save(); ctx.translate(S.ed.x,S.ed.y); ctx.scale(S.ed.s,S.ed.s);
  ctx.drawImage(S.img,0,0);
  if(S.seed){
    ctx.strokeStyle='#2563eb'; ctx.lineWidth=1/S.ed.s;
    ctx.beginPath(); ctx.moveTo(S.seed.x-12,S.seed.y); ctx.lineTo(S.seed.x+12,S.seed.y);
    ctx.moveTo(S.seed.x,S.seed.y-12); ctx.lineTo(S.seed.x,S.seed.y+12); ctx.stroke();
  }
  ctx.restore();
}
function layoutPreview(){
  if(!S.img) return;
  const r=dom.pvBox.getBoundingClientRect(), asp=S.img.width/S.img.height;
  let w=r.width,h=w/asp; if(h>r.height){ h=r.height; w=h*asp; }
  PV.c.width=Math.round(w); PV.c.height=Math.round(h);
  PV.c.style.width=w+'px'; PV.c.style.height=h+'px';
}

/* ===========================
   IMAGE PACKING (AUTO NCHW/NHWC)
=========================== */
function packImageAuto(img,size,layout){ // layout: 'NCHW' | 'NHWC'
  const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d');
  x.fillStyle='#000'; x.fillRect(0,0,size,size);
  const r=Math.min(size/img.width,size/img.height),nw=Math.round(img.width*r),nh=Math.round(img.height*r);
  const dx=((size-nw)/2)|0, dy=((size-nh)/2)|0;
  x.drawImage(img,dx,dy,nw,nh);
  const id=x.getImageData(0,0,size,size).data;
  if(layout==='NCHW'){
    const arr=new Float32Array(1*3*size*size);
    let oR=0,oG=size*size,oB=2*size*size;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const p=(y*size+x)*4;
        arr[oR++]=id[p]/255; arr[oG++]=id[p+1]/255; arr[oB++]=id[p+2]/255;
      }
    }
    return {tensor:new ort.Tensor('float32',arr,[1,3,size,size]),scale:r,dx,dy,size};
  }else{
    const arr=new Float32Array(size*size*3);
    let j=0;
    for(let i=0;i<id.length;i+=4){ arr[j++]=id[i]/255; arr[j++]=id[i+1]/255; arr[j++]=id[i+2]/255; }
    return {tensor:new ort.Tensor('float32',arr,[1,size,size,3]),scale:r,dx,dy,size};
  }
}
async function runWithAutoLayout(session, size, img){
  // Learn or try sequence: prefer cached layout per-session key, else NCHW‚ÜíNHWC fallback.
  const key = Object.entries(S.sessions).find(([k,v])=>v===session)?.[0] || 'session';
  const cached = S.sessionLayout[key];
  const trials = cached ? [cached] : ['NCHW','NHWC'];
  let lastErr=null;
  for(const layout of trials){
    try{
      const inputName = session.inputNames[0] || 'images' || 'image' || 'pixel_values';
      const pack = packImageAuto(img,size,layout);
      const out = await session.run({[inputName]:pack.tensor});
      S.sessionLayout[key]=layout;
      return {out,pack,layout};
    }catch(e){ lastErr=e; }
  }
  // If both failed, throw last error
  throw lastErr || new Error('Inference failed');
}

/* ===========================
   SEGMENTATION
=========================== */
function IOU(a,b){
  const xx1=Math.max(a.x1,b.x1),yy1=Math.max(a.y1,b.y1),xx2=Math.min(a.x2,b.x2),yy2=Math.min(a.y2,b.y2);
  const w=Math.max(0,xx2-xx1),h=Math.max(0,yy2-yy1); const inter=w*h, areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
  return inter/Math.max(1e-6, areaA+areaB-inter);
}
function nms(list,thr){ const keep=[]; for(const a of list){ let ok=true; for(const b of keep){ if(IOU(a,b)>thr){ ok=false; break; } } if(ok) keep.push(a);} return keep; }
async function runSeg(session, key, img, seed){
  if(!session) return edgeGrowMask(img, seed?.x??(img.width>>1), seed?.y??(img.height>>1));
  const info=MODELS[key], size=info.size||640;
  let out,pack,layout;
  try{
    ({out,pack,layout} = await runWithAutoLayout(session,size,img));
  }catch(e){ log('Seg run error:', e.message||e); return edgeGrowMask(img, seed.x, seed.y); }
  const det = out[Object.keys(out)[0]];
  const names = Object.keys(out);
  // try find proto (4D) and det (2D/3D)
  let proto=null, det2=null;
  for(const n of names){
    const t=out[n]; if(t.dims.length===4) proto=t; else det2=t;
  }
  if(proto && det2){
    const res=await decodeYOLOMask(det2, proto, size, pack.scale, pack.dx, pack.dy, img.width, img.height, seed);
    if(res) return res;
  }
  log('Unknown seg outputs; fallback to EdgeGrow.');
  return edgeGrowMask(img, seed.x, seed.y);
}
async function decodeYOLOMask(det, proto, inputSize, scale, dx, dy, outW, outH, seed){
  const dd=det.data, ds=det.dims; if(ds.length<2) return null;
  let N, C;
  if(ds.length===3){
    // (batch?, C, N) or (batch?, N, C) ‚Äî try both
    if(ds[1] > ds[2]){ C=ds[1]; N=ds[2]; }
    else { N=ds[1]; C=ds[2]; }
  }else if(ds.length===2){ N=ds[0]; C=ds[1]; }
  const ps=proto.dims, M=ps[1], Hm=ps[2], Wm=ps[3];
  const clsCount=Math.max(0,C-4-1-M);
  function getVec(i){
    const v=new Float32Array(C);
    if(ds.length===3){
      if(ds[1]>ds[2]){ for(let c=0;c<C;c++) v[c]=dd[c*N+i]; }
      else { for(let c=0;c<C;c++) v[c]=dd[i*C+c]; }
    }else{ for(let c=0;c<C;c++) v[c]=dd[i*C+c]; }
    return v;
  }
  const cand=[];
  for(let i=0;i<N;i++){
    const v=getVec(i);
    const cx=v[0],cy=v[1],bw=v[2],bh=v[3],conf=v[4]; if(conf<0.2) continue;
    let bsc=-1; for(let c=0;c<clsCount;c++) bsc=Math.max(bsc,v[5+c]); const score=conf*(bsc>0?bsc:1); if(score<0.25) continue;
    const coeff=v.slice(5+clsCount,5+clsCount+M);
    cand.push({x1:cx-bw/2,y1:cy-bh/2,x2:cx+bw/2,y2:cy+bh/2,score,coeff});
  }
  cand.sort((a,b)=>b.score-a.score);
  const keep=nms(cand,0.5).slice(0,30); if(!keep.length) return null;

  const P=new Float32Array(M*Hm*Wm); P.set(proto.data);
  let bestCanvas=null,bestScore=-1;
  for(const det of keep){
    const c=det.coeff,flat=new Float32Array(Hm*Wm);
    for(let i=0;i<Hm*Wm;i++){ let s=0; for(let k=0;k<M;k++) s+=P[k*Hm*Wm+i]*c[k]; flat[i]=1/(1+Math.exp(-s)); }
    const small=document.createElement('canvas'); small.width=Wm; small.height=Hm; const sx=small.getContext('2d');
    const id=sx.createImageData(Wm,Hm);
    for(let i=0;i<Hm*Wm;i++){ const a=(flat[i]*255)|0; const o=i*4; id.data[o]=255; id.data[o+1]=255; id.data[o+2]=255; id.data[o+3]=a; }
    sx.putImageData(id,0,0);
    const big=document.createElement('canvas'); big.width=outW; big.height=outH; const bx=big.getContext('2d');
    bx.drawImage(small,0,0,inputSize,inputSize,-dx,-dy,inputSize/scale,inputSize/scale);
    if(seed){
      if(maskHit(big,seed.x,seed.y)) return big;
      if(det.score>bestScore){ bestScore=det.score; bestCanvas=big; }
    }else{
      if(det.score>bestScore){ bestScore=det.score; bestCanvas=big; }
    }
  }
  return bestCanvas;
}
function maskHit(maskC,x,y){ const d=maskC.getContext('2d').getImageData(Math.max(0,Math.min(maskC.width-1,x|0)),Math.max(0,Math.min(maskC.height-1,y|0)),1,1).data; return d[3]>10; }

/* ===========================
   DEPTH (square‚Üíunletterbox)
=========================== */
async function runDepth(session, key, img){
  if(!session) return {canvas:null,map:null};
  const info=MODELS[key], size=info.size||256;
  let out,pack,layout;
  try{
    ({out,pack,layout} = await runWithAutoLayout(session,size,img));
  }catch(e){ log('Depth run error:', e.message||e); return {canvas:null,map:null}; }
  const first=out[Object.keys(out)[0]];
  // dims may be [1,1,H,W] or [1,H,W,1] or [1,H,W]
  let Hs,Ws,arr=first.data;
  if(first.dims.length===4){ // [1,C,H,W] or [1,H,W,C]
    const d=first.dims;
    if(d[2] && d[3]){ Hs=d[2]; Ws=d[3]; }
    else { Hs=d[1]; Ws=d[2]; }
  }else if(first.dims.length===3){ Hs=first.dims[1]; Ws=first.dims[2]; }
  else { // fallback square
    Hs=Ws=info.size||256;
  }
  // normalize ‚Üí grayscale small
  let mn=Infinity,mx=-Infinity; for(let i=0;i<arr.length;i++){ const v=arr[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
  const rng=(mx-mn)||1;
  const small=document.createElement('canvas'); small.width=Ws; small.height=Hs; const sx=small.getContext('2d');
  const imgd=sx.createImageData(Ws,Hs);
  for(let i=0;i<Ws*Hs;i++){ const g=(((arr[i]-mn)/rng)*255)|0; const o=i*4; imgd.data[o]=g; imgd.data[o+1]=g; imgd.data[o+2]=g; imgd.data[o+3]=255; }
  sx.putImageData(imgd,0,0);
  // map to square input then unletterbox back to full
  const square=document.createElement('canvas'); square.width=size; square.height=size;
  square.getContext('2d').drawImage(small,0,0,Ws,Hs,0,0,size,size);
  const big=document.createElement('canvas'); big.width=img.width; big.height=img.height;
  const bx=big.getContext('2d'); bx.imageSmoothingEnabled=true;
  bx.drawImage(square,0,0,size,size,-pack.dx,-pack.dy,size/pack.scale,size/pack.scale);
  // 0..1 map
  const pixels=bx.getImageData(0,0,big.width,big.height).data;
  const map=new Float32Array(big.width*big.height); for(let i=0,j=0;i<map.length;i++,j+=4) map[i]=pixels[j]/255;
  return {canvas:big,map};
}

/* ===========================
   EDGE & GROW HELPERS
=========================== */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
function edgeMaskFromImage(img,thr=0.18){
  const W=img.width,H=img.height,maxSide=1024,sc=Math.min(1,maxSide/Math.max(W,H));
  const sw=Math.max(1,Math.round(W*sc)),sh=Math.max(1,Math.round(H*sc));
  const sC=makeCanvas(sw,sh),sx=sC.getContext('2d'); sx.drawImage(img,0,0,sw,sh);
  const src=sx.getImageData(0,0,sw,sh).data, gray=new Float32Array(sw*sh);
  for(let i=0,j=0;i<gray.length;i++,j+=4) gray[i]=(0.2126*src[j]+0.7152*src[j+1]+0.0722*src[j+2])/255;
  return buildEdgeMaskFromGray(gray,sw,sh,thr,W,H);
}
function edgeMaskFromDepthMap(map,W,H,thr=0.18){
  const maxSide=1024,sc=Math.min(1,maxSide/Math.max(W,H)), sw=Math.max(1,Math.round(W*sc)), sh=Math.max(1,Math.round(H*sc));
  const g=new Float32Array(sw*sh);
  for(let y=0;y<sh;y++){ for(let x=0;x<sw;x++){ const ox=Math.min(W-1,Math.round(x/sc)),oy=Math.min(H-1,Math.round(y/sc)); g[y*sw+x]=map[oy*W+ox]; } }
  return buildEdgeMaskFromGray(g,sw,sh,thr,W,H);
}
function buildEdgeMaskFromGray(gray,sw,sh,thr,W,H){
  const sob=new Float32Array(sw*sh), gxK=[-1,0,1,-2,0,2,-1,0,1], gyK=[-1,-2,-1,0,0,0,1,2,1];
  for(let y=1;y<sh-1;y++) for(let x=1;x<sw-1;x++){
    let gx=0,gy=0,p=0; for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++){ const v=gray[(y+ky)*sw+(x+kx)]; gx+=v*gxK[p]; gy+=v*gyK[p]; p++; }
    sob[y*sw+x]=Math.hypot(gx,gy)/4;
  }
  const lap=new Float32Array(sw*sh), lK=[0,1,0,1,-4,1,0,1,0];
  for(let y=1;y<sh-1;y++) for(let x=1;x<sw-1;x++){
    let s=0,p=0; for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++){ const v=gray[(y+ky)*sw+(x+kx)]; s+=v*lK[p++]; } lap[y*sw+x]=Math.abs(s);
  }
  let mn=Infinity,mx=-Infinity; const comb=new Float32Array(sw*sh);
  for(let i=0;i<comb.length;i++){ const v=0.6*sob[i]+0.4*lap[i]; comb[i]=v; if(v<mn) mn=v; if(v>mx) mx=v; }
  const rng=mx-mn||1; const mSmall=makeCanvas(sw,sh), msx=mSmall.getContext('2d'), id=msx.createImageData(sw,sh), d2=id.data;
  for(let i=0;i<comb.length;i++){ const v=(comb[i]-mn)/rng; const a=v>=thr?255:0; const o=i*4; d2[o]=255; d2[o+1]=255; d2[o+2]=255; d2[o+3]=a; }
  msx.putImageData(id,0,0);
  const mFull=makeCanvas(W,H),fx=mFull.getContext('2d'); fx.imageSmoothingEnabled=false; fx.drawImage(mSmall,0,0,sw,sh,0,0,W,H);
  return mFull;
}
function edgeGrowMask(img,sx,sy){
  const W=img.width,H=img.height,maxSide=1024,sc=Math.min(1,maxSide/Math.max(W,H));
  const sw=Math.max(1,Math.round(W*sc)),sh=Math.max(1,Math.round(H*sc));
  const sC=makeCanvas(sw,sh),sx2=sC.getContext('2d'); sx2.drawImage(img,0,0,sw,sh);
  const src=sx2.getImageData(0,0,sw,sh).data;
  const seedX=clamp(Math.round(sx*sc),0,sw-1), seedY=clamp(Math.round(sy*sc),0,sh-1);
  const p=4*(seedY*sw+seedX), r0=src[p], g0=src[p+1], b0=src[p+2], tol=28;
  const out=new Uint8Array(sw*sh), st=[[seedX,seedY]]; out[seedY*sw+seedX]=1;
  while(st.length){
    const [x,y]=st.pop();
    for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
      if(nx<0||ny<0||nx>=sw||ny>=sh) continue; const id=ny*sw+nx; if(out[id]) continue;
      const q=4*id; const dr=src[q]-r0,dg=src[q+1]-g0,db=src[q+2]-b0;
      if(Math.hypot(dr,dg,db)<=tol){ out[id]=1; st.push([nx,ny]); }
    }
  }
  const ms=makeCanvas(sw,sh),msx=ms.getContext('2d'), id=msx.createImageData(sw,sh), d=id.data;
  for(let i=0;i<sw*sh;i++){ const a=out[i]?255:0; const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=a; }
  msx.putImageData(id,0,0);
  const mf=makeCanvas(W,H),fx=mf.getContext('2d'); fx.imageSmoothingEnabled=false; fx.drawImage(ms,0,0,sw,sh,0,0,W,H);
  return mf;
}

/* Depth-aware edge-bound growth */
function edgeBoundGrow(img,seed,depthMap,band=0.07,edgeThr=0.18){
  const W=img.width,H=img.height; if(!seed) return makeCanvas(W,H);
  const edges=edgeMaskFromImage(img,edgeThr);
  return edgeBoundGrowGeneric(seed,edges,depthMap,band,W,H,img);
}
function edgeBoundGrowDepth(seed,depthMap,edgeThr=0.18,band=0.07,W,H){
  if(!seed||!depthMap) return makeCanvas(W,H);
  const edges=edgeMaskFromDepthMap(depthMap,W,H,edgeThr);
  return edgeBoundGrowGeneric(seed,edges,depthMap,band,W,H);
}
function edgeBoundGrowGeneric(seed,edges,depthMap,band,W,H,img=null){
  const ex=edges.getContext('2d'), ed=ex.getImageData(0,0,W,H).data;
  let lo=-1, hi=2;
  if(depthMap && band>0){ const sd=depthMap[seed.y*W+seed.x]; lo=Math.max(0,sd-band); hi=Math.min(1,sd+band); }
  let srcData=null, r0=0,g0=0,b0=0, tol=Infinity;
  if(img){
    const t=makeCanvas(W,H), tx=t.getContext('2d'); tx.drawImage(img,0,0); srcData=tx.getImageData(0,0,W,H).data;
    const q=4*(seed.y*W+seed.x); r0=srcData[q]; g0=srcData[q+1]; b0=srcData[q+2]; tol=28;
  }
  const out=new Uint8Array(W*H), st=[[seed.x,seed.y]]; out[seed.y*W+seed.x]=1;
  while(st.length){
    const [x,y]=st.pop();
    for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
      if(nx<0||ny<0||nx>=W||ny>=H) continue; const idx=ny*W+nx; if(out[idx]) continue;
      if(ed[idx*4+3]>0) continue; // edge barrier
      if(depthMap){ const v=depthMap[idx]; if(v<lo||v>hi) continue; }
      if(srcData){ const q=4*idx; const dr=srcData[q]-r0,dg=srcData[q+1]-g0,db=srcData[q+2]-b0; if(Math.hypot(dr,dg,db)>tol) continue; }
      out[idx]=1; st.push([nx,ny]);
    }
  }
  const m=makeCanvas(W,H), mx=m.getContext('2d'), id=mx.createImageData(W,H), d=id.data;
  for(let i=0;i<W*H;i++){ const a=out[i]?255:0; const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=a; }
  mx.putImageData(id,0,0); return m;
}

/* Depth masks + compositing */
function intersect(a,b){
  if(!a||!b) return null; const W=a.width,H=a.height;
  const c=makeCanvas(W,H), x=c.getContext('2d'); x.drawImage(a,0,0); x.globalCompositeOperation='destination-in'; x.drawImage(b,0,0); return c;
}
function emptyMask(W,H){ return makeCanvas(W,H); }
function depthBand(map,W,H,seed,band){
  if(!seed) return null; const sd=map[seed.y*W+seed.x]; const lo=Math.max(0,sd-band), hi=Math.min(1,sd+band);
  const c=makeCanvas(W,H), x=c.getContext('2d'), id=x.createImageData(W,H), d=id.data;
  for(let i=0;i<W*H;i++){ const ok=(map[i]>=lo&&map[i]<=hi)?255:0; const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=ok; }
  x.putImageData(id,0,0); return c;
}
function depthThresh(map,W,H,thr,near=true){
  const c=makeCanvas(W,H), x=c.getContext('2d'), id=x.createImageData(W,H), d=id.data;
  for(let i=0;i<W*H;i++){ const v=map[i]; const ok=near?(v<=thr):(v>=thr); const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=ok?255:0; }
  x.putImageData(id,0,0); return c;
}
function buildFinalMaskFullRes(){
  const W=S.img.width,H=S.img.height, feather=+dom.numFeather.value||0;
  let seg=S.maskCanvas, depthMask=null, edgeMaskRGB=null, edgeMaskDepth=null, finalMask=null;

  if(['depth-band','seg-and-depth','seg-and-depth-and-edges','edge-bound-grow','depth-canny','depth-canny-seed'].includes(S.effect) && S.depthMap){
    if(['depth-canny','depth-canny-seed'].includes(S.effect)){
      // compute edge-based in dedicated handlers below
    }else{
      depthMask = depthBand(S.depthMap,W,H,S.seed,+dom.rngBand.value);
    }
  }
  if(['edges','seg-and-edges','seg-and-depth-and-edges','edge-bound-grow'].includes(S.effect)){
    edgeMaskRGB = edgeMaskFromImage(S.img,+dom.rngEdgeT.value);
  }
  if(['depth-canny','depth-canny-seed'].includes(S.effect) && S.depthMap){
    edgeMaskDepth = edgeMaskFromDepthMap(S.depthMap,W,H,+dom.rngEdgeT.value);
  }

  switch(S.effect){
    case 'seg': finalMask = seg || edgeGrowMask(S.img,S.seed?.x??(W>>1),S.seed?.y??(H>>1)); break;
    case 'depth-band': finalMask = depthMask || emptyMask(W,H); break;
    case 'depth-thresh': finalMask = depthThresh(S.depthMap,W,H,+dom.rngDepthT.value,true); break;
    case 'edges': finalMask = edgeMaskRGB || emptyMask(W,H); break;
    case 'depth-canny': finalMask = edgeMaskDepth || emptyMask(W,H); break;
    case 'depth-canny-seed': finalMask = edgeBoundGrowDepth(S.seed,S.depthMap,+dom.rngEdgeT.value,+dom.rngBand.value,W,H); break;
    case 'seg-and-depth': finalMask = intersect(seg,depthMask) || seg || depthMask || emptyMask(W,H); break;
    case 'seg-and-edges': finalMask = intersect(seg,edgeMaskRGB) || seg || edgeMaskRGB || emptyMask(W,H); break;
    case 'seg-and-depth-and-edges': {
      const s_d=intersect(seg,depthMask);
      finalMask = intersect(s_d,edgeMaskRGB) || s_d || seg || depthMask || edgeMaskRGB || emptyMask(W,H);
      break;
    }
    case 'edge-bound-grow': finalMask = edgeBoundGrow(S.img,S.seed,S.depthMap,+dom.rngBand.value,+dom.rngEdgeT.value); break;
    default: finalMask = seg || emptyMask(W,H);
  }

  if(feather>0){
    const out=makeCanvas(W,H), x=out.getContext('2d');
    x.filter=`blur(${feather}px)`; x.drawImage(finalMask,0,0); x.filter='none';
    return out;
  }
  return finalMask;
}

/* ===========================
   RENDERING
=========================== */
function renderPreview(){
  if(!S.img){ PV.ctx.clearRect(0,0,PV.c.width,PV.c.height); return; }
  const {ctx,c}=PV; ctx.clearRect(0,0,c.width,c.height);
  // grayscale base
  const tmp=makeCanvas(S.img.width,S.img.height), tx=tmp.getContext('2d'); tx.drawImage(S.img,0,0);
  const im=tx.getImageData(0,0,tmp.width,tmp.height), d=im.data;
  for(let i=0;i<d.length;i+=4){ const y=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2])|0; d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255; }
  tx.putImageData(im,0,0); ctx.drawImage(tmp,0,0,c.width,c.height);
  // color foreground
  if(S.img){
    const mask=buildFinalMaskFullRes();
    const fg=makeCanvas(S.img.width,S.img.height), fx=fg.getContext('2d');
    fx.drawImage(S.img,0,0); fx.globalCompositeOperation='destination-in'; fx.drawImage(mask,0,0);
    ctx.drawImage(fg,0,0,c.width,c.height);
    drawThumbs(mask);
  }
}
function drawThumbs(finalMask){
  if(!S.img) return; const W=S.img.width,H=S.img.height;
  // Seg thumb (black)
  const segC=dom.thSeg,sx=segC.getContext('2d'); segC.width=240; segC.height=Math.round(segC.width*(H/W)); sx.fillStyle='#fff'; sx.fillRect(0,0,segC.width,segC.height);
  if(S.maskCanvas){ const t=makeCanvas(W,H), x=t.getContext('2d'); x.drawImage(S.maskCanvas,0,0); const id=x.getImageData(0,0,W,H), dd=id.data;
    for(let i=0;i<dd.length;i+=4){ const a=dd[i+3]; dd[i]=0; dd[i+1]=0; dd[i+2]=0; dd[i+3]=a?255:0; } x.putImageData(id,0,0);
    sx.imageSmoothingEnabled=false; sx.drawImage(t,0,0,W,H,0,0,segC.width,segC.height);
  }
  // Depth thumb
  const depC=dom.thDepth,dx=depC.getContext('2d'); depC.width=240; depC.height=Math.round(depC.width*(H/W)); dx.fillStyle='#fff'; dx.fillRect(0,0,depC.width,depC.height);
  if(S.depthCanvas){ dx.imageSmoothingEnabled=false; dx.drawImage(S.depthCanvas,0,0,W,H,0,0,depC.width,depC.height); }
  // Final thumb (black)
  const finC=dom.thFinal,fx=finC.getContext('2d'); finC.width=240; finC.height=Math.round(finC.width*(H/W)); fx.fillStyle='#fff'; fx.fillRect(0,0,finC.width,finC.height);
  if(finalMask){ const t2=makeCanvas(W,H), x2=t2.getContext('2d'); x2.drawImage(finalMask,0,0); const id2=x2.getImageData(0,0,W,H), d2=id2.data;
    for(let i=0;i<d2.length;i+=4){ const a=d2[i+3]; d2[i]=0; d2[i+1]=0; d2[i+2]=0; d2[i+3]=a?255:0; } x2.putImageData(id2,0,0);
    fx.imageSmoothingEnabled=false; fx.drawImage(t2,0,0,W,H,0,0,finC.width,finC.height);
  }
}

/* ===========================
   PIPELINE (with jobId & stepper)
=========================== */
async function runPipeline(){
  if(!S.img || !S.seed){ toast('Set a seed on ORIGINAL'); return; }
  const myJob=++S.jobId;
  dom.blocker.style.pointerEvents='auto'; // prevent accidental clicks
  setStep(1,'active'); toast('Segmenting‚Ä¶'); dom.aiStatus.textContent='segment‚Ä¶'; statusText('Segmenting‚Ä¶');
  let segMask=null, depthObj={canvas:null,map:null};

  try{
    // Seg
    if(S.segKey==='edgegrow'){ segMask=edgeGrowMask(S.img,S.seed.x,S.seed.y); }
    else{ const sess=await ensureSession(S.segKey); if(myJob!==S.jobId) return;
      segMask=await runSeg(sess,S.segKey,S.img,S.seed);
    }
    S.maskCanvas=segMask; setStep(1,'ok');
  }catch(e){ log('Seg fail:', e.message||e); setStep(1,'err'); S.maskCanvas=edgeGrowMask(S.img,S.seed.x,S.seed.y); }

  // Depth
  setStep(2,'active'); toast('Depth map‚Ä¶'); dom.aiStatus.textContent='depth‚Ä¶'; statusText('Depth generating‚Ä¶');
  try{
    if(S.depthKey==='none'){ depthObj={canvas:null,map:null}; }
    else{ const ds=await ensureSession(S.depthKey); if(myJob!==S.jobId) return;
      depthObj=await runDepth(ds,S.depthKey,S.img);
    }
    S.depthCanvas=depthObj.canvas; S.depthMap=depthObj.map; setStep(2,'ok');
  }catch(e){ log('Depth fail:', e.message||e); setStep(2,'err'); S.depthCanvas=null; S.depthMap=null; }

  // Compose
  if(myJob!==S.jobId) return;
  setStep(3,'active'); toast('Composing‚Ä¶'); dom.aiStatus.textContent='compose‚Ä¶'; statusText('Composing result‚Ä¶');
  layoutPreview(); renderPreview();
  setStep(3,'ok');
  setStep(0,''); // reset first step state view
  dom.aiStatus.textContent='ready'; statusText('Done','ok'); toast('Done','ok');
  dom.blocker.style.pointerEvents='none';
}

/* ===========================
   IMAGE I/O
=========================== */
function openImageFile(){ dom.fileImage.value=''; dom.fileImage.click(); }
function loadImageFromFile(file){
  const r=new FileReader();
  r.onload=()=>{ const im=new Image(); im.onload=()=>{ S.img=im; S.seed=null; S.maskCanvas=null; S.depthCanvas=null; S.depthMap=null; fitEditor(); drawEditor(); layoutPreview(); renderPreview(); log(`Image loaded: ${file.name} ${im.width}x${im.height}`); }; im.src=r.result; };
  r.readAsDataURL(file);
}
function enableDragDrop(el){
  el.addEventListener('dragover',e=>{ e.preventDefault(); el.style.outline='2px dashed #2563eb'; });
  el.addEventListener('dragleave',()=>{ el.style.outline=''; });
  el.addEventListener('drop',e=>{ e.preventDefault(); el.style.outline=''; const f=e.dataTransfer.files?.[0];
    if(f && f.type.startsWith('image/')) loadImageFromFile(f);
  });
}

/* ===========================
   UI EVENTS
=========================== */
function attachThumbHover(){
  dom.thumbs.addEventListener('mouseenter',()=>{ dom.thumbs.classList.add('float'); });
  dom.thumbs.addEventListener('mouseleave',()=>{ dom.thumbs.classList.remove('float'); dom.thumbs.classList.remove('left'); dom.thumbs.style.left=''; dom.thumbs.style.right='';});
  dom.pvBox.addEventListener('mousemove',(e)=>{
    const r=dom.pvBox.getBoundingClientRect(); const x=e.clientX-r.left;
    if(dom.thumbs.classList.contains('float')){
      if(x<r.width/2){ dom.thumbs.classList.add('left'); dom.thumbs.style.left='8px'; dom.thumbs.style.right='auto'; }
      else { dom.thumbs.classList.remove('left'); dom.thumbs.style.left='auto'; dom.thumbs.style.right='8px'; }
    }
  });
}
window.addEventListener('resize',()=>{ fitEditor(); drawEditor(); layoutPreview(); renderPreview(); });

dom.btnImage.addEventListener('click',openImageFile);
dom.fileImage.addEventListener('change',e=>{ const f=e.target.files?.[0]; if(f) loadImageFromFile(f); });
enableDragDrop(dom.edBox); enableDragDrop(dom.pvBox);

dom.btnReset.addEventListener('click',()=>{ S.img=null; S.seed=null; S.maskCanvas=null; S.depthCanvas=null; S.depthMap=null; S.jobId++; drawEditor(); PV.ctx.clearRect(0,0,PV.c.width,PV.c.height); dom.edHint.style.display='block'; toast('Reset'); });
dom.btnSave.addEventListener('click',()=>{
  if(!S.img){ alert('Upload an image first.'); return; }
  const out=makeCanvas(S.img.width,S.img.height), ox=out.getContext('2d');
  // grayscale base
  const tmp=makeCanvas(out.width,out.height), tx=tmp.getContext('2d'); tx.drawImage(S.img,0,0);
  const im=tx.getImageData(0,0,out.width,out.height), d=im.data;
  for(let i=0;i<d.length;i+=4){ const y=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2])|0; d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255; }
  tx.putImageData(im,0,0); ox.drawImage(tmp,0,0);
  // color fg
  const mask=buildFinalMaskFullRes(); const fg=makeCanvas(out.width,out.height), fx=fg.getContext('2d'); fx.drawImage(S.img,0,0); fx.globalCompositeOperation='destination-in'; fx.drawImage(mask,0,0); ox.drawImage(fg,0,0);
  const a=document.createElement('a'); a.href=out.toDataURL('image/png'); a.download=`colorsplash-${Date.now()}.png`; a.click();
});

dom.selSeg.addEventListener('change',()=>{ S.segKey=dom.selSeg.value; log('Seg model:',S.segKey); if(S.segKey!=='edgegrow') ensureSession(S.segKey).catch(e=>log('Seg preload failed:',e.message||e)); if(S.img && S.seed && S.aiOn) runPipeline().catch(e=>log('AI error:',e.message||e)); });
dom.selDepth.addEventListener('change',()=>{ S.depthKey=dom.selDepth.value; log('Depth model:',S.depthKey); if(S.depthKey!=='none') ensureSession(S.depthKey).catch(e=>log('Depth preload failed:',e.message||e)); if(S.img && S.seed && S.aiOn) runPipeline().catch(e=>log('AI error:',e.message||e)); });
dom.selEffect.addEventListener('change',()=>{ S.effect=dom.selEffect.value; layoutPreview(); renderPreview(); });
dom.rngBand.addEventListener('input',()=>{ if(S.img){ layoutPreview(); renderPreview(); }});
dom.rngDepthT.addEventListener('input',()=>{ if(S.img){ layoutPreview(); renderPreview(); }});
dom.rngEdgeT.addEventListener('input',()=>{ if(S.img){ layoutPreview(); renderPreview(); }});

dom.btnRun.addEventListener('click',()=>{ if(!S.img){ openImageFile(); return; } if(!S.seed) return alert('Click a seed in ORIGINAL first.'); runPipeline().catch(e=>log('AI error:',e.message||e)); });

dom.edBox.addEventListener('click',(e)=>{
  if(!S.img){ openImageFile(); return; }
  const r=dom.edBox.getBoundingClientRect(); const cx=e.clientX-r.left, cy=e.clientY-r.top;
  const x=Math.round((cx-S.ed.x)/S.ed.s), y=Math.round((cy-S.ed.y)/S.ed.s);
  S.seed={x:clamp(x,0,S.img.width-1), y:clamp(y,0,S.img.height-1)};
  drawEditor(); log(`Seed set at (${S.seed.x}, ${S.seed.y}).`);
  if(S.aiOn) runPipeline().catch(err=>log('AI error:', err.message||err));
});
dom.edBox.addEventListener('wheel',(e)=>{
  if(!S.img) return; e.preventDefault();
  const r=dom.edBox.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top; const zf=1.1; const zoom=e.deltaY<0?zf:1/zf;
  const ns=clamp(S.ed.s*zoom,0.1,20); S.ed.x=mx-(mx-S.ed.x)*zoom; S.ed.y=my-(my-S.ed.y)*zoom; S.ed.s=ns; drawEditor();
},{passive:false});

/* Logs panel */
dom.logBtn.addEventListener('click',()=>{ dom.logs.classList.toggle('visible'); });
dom.btnClearLog.addEventListener('click',()=>dom.log.textContent='');
dom.btnClearCache.addEventListener('click',async()=>{ await idbClear(); S.sessions={}; S.cache={}; S.sessionLayout={}; log('Cache cleared.'); toast('Cache cleared','warn'); });
dom.btnSelfTest.addEventListener('click',async()=>{
  for(const [k,m] of Object.entries(MODELS)){
    if(m.gh){ try{ const r=await fetch(m.gh,{method:'HEAD',mode:'cors'}); log(`[HEAD GH] ${k}: ${r.status}`);}catch(e){ log(`[HEAD GH] ${k}: ${e.message}`);} }
    if(m.db){ try{ const r=await fetch(m.db,{method:'HEAD',mode:'cors'}); log(`[HEAD DB] ${k}: ${r.status}`);}catch(e){ log(`[HEAD DB] ${k}: ${e.message}`);} }
    await new Promise(r=>setTimeout(r,40));
  }
});

/* ===========================
   BOOT
=========================== */
(async function init(){
  log('App ready. Version 5.0.0');
  try{
    await idbOpen(); // ensure store exists before any model activity
  }catch(e){ log('IDB open error:', e.message||e); }
  const providers=await pickProviders();
  log('Runtime:', providers.includes('webgpu') ? 'WebGPU + WASM fallback' : 'WASM only');
  fitEditor(); drawEditor(); layoutPreview(); renderPreview(); attachThumbHover();
})();
})();</script>
</body>
</html>
