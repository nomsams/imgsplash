<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Color Splash Pro X</title>

<!--
================================================================================
TECHNICAL SPECIFICATION SHEET (v1.17.0 ‚ÄúWorkers + EdgeGrow + GraphCut-lite‚Äù)
We ONLY ADD / FIX. Nothing previously working is removed.

WHAT‚ÄôS NEW (on top of v1.14.0):
- VERSION BUMP ‚Üí APP_VERSION = "1.17.0".
- BIGGER WORKSPACE:
  ‚Ä¢ Top row height dominance preserved, canvases get more real estate (tighter chrome).
  ‚Ä¢ Grid widened (editor : preview = 8fr : 7fr) with responsive behavior.
- NEW CONTROLS:
  ‚Ä¢ Reset View button (centers and fits the original again, cancels pan/zoom).
  ‚Ä¢ Auto Objects (demo: centered seeded selection, uses EdgeGrow).
- SMART OBJECT SELECTION (Worker-backed):
  ‚Ä¢ Auto Smart ‚Üí EdgeGrow (edge-aware Dijkstra region grow using Sobel gradient).
  ‚Ä¢ Auto Ultra ‚Üí GrabCut-lite (color GMM + cut). If worker not ready, falls back to EdgeGrow.
  ‚Ä¢ Every auto mask carries .generator metadata {tool, seedX, seedY, params} for recompute.
- SMART RECOMPUTE:
  ‚Ä¢ Changing Tolerance triggers recomputeGeneratedMasks(): auto selections are re-run
    and areas really change (not just re-render).
- HIGH-QUALITY EXPORT:
  ‚Ä¢ Download now renders at FULL native image resolution (no preview downscale),
    applying the same mask composition and filter pipeline for max quality.
- MONOCLE STABILITY:
  ‚Ä¢ Guarded mapping + position handling when switching hover between editor/preview.

Everything else from earlier versions is preserved: Lasso, Box, Protect/Remove Erasers,
Undo/Redo, Save/Load JSON, Start Over, Render Now, Logs, presets, zoom/pan.
================================================================================
-->

  <style>
    :root{
      --bg:#edf1f7;--panel:#fff;--text:#1c1e21;--muted:#606770;--primary:#1877f2;--primary-2:#166fe5;
      --border:#d7dbe1;--shadow:rgba(0,0,0,.08);--shadow-2:rgba(0,0,0,.14);
      --danger:#fa383e;--ok:#19a974;--warn:#ffb700;
      --sel:#1877f2;--sel-ghost:rgba(24,119,242,.14);
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;overflow:hidden;
    }
    header{
      background:var(--panel);box-shadow:0 2px 6px var(--shadow);padding:.55rem .8rem;display:flex;align-items:center;gap:.5rem;z-index:3;
    }
    .brand{font-weight:800;color:var(--primary);letter-spacing:.2px}
    .badge{margin-left:auto;font-size:.8rem;color:#4a4f57;background:#eef3ff;border:1px solid #dfe7ff;padding:.2rem .5rem;border-radius:6px}
    .toolbar{display:flex;flex-wrap:wrap;gap:.4rem;align-items:center}
    .group{display:flex;gap:.4rem;align-items:center}
    button{
      padding:.42rem .7rem;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:default;
      font-weight:600;font-size:.9rem;display:inline-flex;gap:.42rem;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,.02);
      transition:transform .05s ease, border-color .2s, background .2s, color .2s;
    }
    button:hover:not(:disabled){border-color:var(--primary);background:#f6faff}
    button:active{transform:translateY(1px)}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    button.primary:hover{background:var(--primary-2);color:#fff}
    button.active{background:var(--primary);border-color:var(--primary);color:#fff}
    button.danger{border-color:#ffd2d6;background:#fff0f1;color:#b00020}
    button:disabled{opacity:.6;cursor:not-allowed}
    .icon{font-size:1.05rem}

    /* ====== Layout: canvases get even more space ====== */
    .shell{
      flex:1;display:flex;flex-direction:column;gap:10px;padding:10px;overflow:hidden;
    }
    .row{
      display:grid;grid-template-columns:8fr 7fr;gap:10px;
      flex:1 1 auto;min-height:0;
    }
    .panel{
      background:var(--panel);border-radius:12px;box-shadow:0 2px 8px var(--shadow);
      display:flex;flex-direction:column;min-height:0;overflow:hidden
    }
    .panel-h{
      padding:.5rem .75rem;border-bottom:1px solid var(--border);font-weight:700;color:var(--muted);
      display:flex;align-items:center;justify-content:center;gap:.5rem
    }
    .panel-c{
      flex:1;min-height:0;
      position:relative;background:#e9eef6;display:flex;align-items:center;justify-content:center;overflow:hidden
    }

    .placeholder{color:var(--muted);font-weight:600;opacity:.85;pointer-events:none}
    .canvas-wrap{
      position:relative;width:100%;height:100%;overflow:hidden;
      display:flex;align-items:center;justify-content:center;
      cursor:default;
    }
    .canvas-wrap.panning{cursor:grabbing}
    .canvas-wrap.drop-hover{outline:3px dashed var(--primary); outline-offset:-8px; background:rgba(24,119,242,0.1)}
    canvas{display:block;background:#fff}
    #editor-canvas{position:absolute;transform-origin:top left}
    #preview-canvas{position:absolute;top:0;left:0}

    /* Monocle */
    .monocle{
      position:absolute; top:10px; right:10px; width:148px; height:148px; background:#fff;
      border:2px solid var(--border); border-radius:10px; box-shadow:0 6px 14px var(--shadow-2);
      overflow:hidden; display:none; z-index:2;
    }
    .monocle canvas{width:100%;height:100%;display:block; background:#000}

    /* Bottom strip compact */
    .bottom{
      display:grid;grid-template-columns:8fr 3fr;gap:10px;
      min-height:92px;max-height:26vh;
    }
    .presets.panel{min-height:92px}
    .presets-grid{
      display:grid;grid-template-columns:repeat(10,1fr);gap:8px;padding:10px;align-items:end;justify-items:center
    }
    .preset{cursor:pointer;text-align:center;width:100%;max-width:84px;margin:0 auto}
    .preset canvas{
      width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;
      box-shadow:0 1px 3px var(--shadow);transition:all .15s
    }
    .preset:hover canvas{transform:translateY(-2px)}
    .preset.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .preset label{display:block;margin-top:4px;font-size:.72rem;color:var(--muted);text-align:center}

    .side.panel{min-height:92px}
    .side-c{display:grid;grid-template-rows:auto 1fr}
    .settings{padding:8px 10px;border-bottom:1px solid var(--border)}
    .set-row{display:flex;align-items:center;gap:10px;margin:.28rem 0}
    .set-row input[type=range]{flex-grow:1}

    .logs{position:relative; overflow:hidden; display:none;}
    .log-header{display:flex;align-items:center;justify-content:space-between;padding:6px 10px;border-bottom:1px solid var(--border);background:#fafbff}
    .log-body{height:100%;padding:10px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.8rem;background:#fff}
    .log-line{white-space:pre-wrap;color:#2d3748;margin:.15rem 0}

    /* Progress */
    .progress-wrap{position:absolute;left:12px;right:12px;bottom:12px;height:8px;border-radius:6px;background:#eef2ff;border:1px solid #dde6ff;overflow:hidden; opacity:0; transition: opacity 0.2s; pointer-events:none;}
    .progress-wrap.visible{opacity:1;}
    .progress{height:100%;width:0%;background:linear-gradient(90deg,#7aa2ff,#1877f2);transition:width .1s}

    .version-pin{
      position:fixed;top:8px;right:8px;background:#101828;color:#fff;font-size:.75rem;padding:.25rem .5rem;border-radius:6px;
      box-shadow:0 4px 12px rgba(0,0,0,.18);z-index:10;opacity:.9
    }

    .hidden{display:none!important}
  </style>
</head>
<body>
  <header>
    <div class="brand">Color Splash Pro X</div>
    <div class="toolbar">
      <div class="group">
        <button id="uploadBtn" class="primary"><span class="icon">üì§</span>Upload</button>
        <button id="saveBtn" title="Save project JSON" disabled>üíæ Save</button>
        <button id="loadBtn" title="Load project JSON">üìÇ Load</button>
        <button id="startOverBtn" class="danger" title="Clear image & selections" disabled>üßπ Start Over</button>
      </div>
      <div class="group">
        <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>‚Ü©Ô∏è Undo</button>
        <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>‚Ü™Ô∏è Redo</button>
      </div>
      <div class="group">
        <button id="modeLassoBtn" class="active" title="Smart Select (Lasso) (S)">‚ú® Lasso</button>
        <button id="newLassoBtn" title="Add new lasso object">‚ûï New Lasso</button>
        <button id="modeBoxBtn" title="Box Select (B)">üî≤ Box</button>
        <button id="deleteSelectionBtn" title="Delete active selection (Del)" disabled>üóëÔ∏è Delete</button>
      </div>
      <div class="group">
        <button id="autoWandBtn" title="Auto Wand (W)">ü™Ñ Auto Wand</button>
        <button id="autoSmartBtn" title="Auto Smart (G)">üß† Auto Smart</button>
        <button id="autoUltraBtn" title="Auto Ultra (U)">üß¨ Auto Ultra</button>
        <button id="autoObjectsBtn" title="Auto Objects (demo)">üõ∞Ô∏è Auto Objects</button>
      </div>
      <div class="group">
        <button id="protectEraserBtn" title="Paint protected areas (E)">üõ°Ô∏è Protect Eraser</button>
        <button id="removeEraserBtn" title="Erase colorized mask (R)">üßΩ Remove Eraser</button>
      </div>
      <div class="group">
        <button id="resetViewBtn" title="Reset pan/zoom & fit">üéØ Reset View</button>
        <button id="renderNowBtn" title="Render immediately">‚ö° Render Now</button>
        <button id="downloadBtn" title="Download final image (PNG)">‚¨áÔ∏è Download</button>
      </div>
    </div>
    <span class="badge" id="versionBadge">v?</span>
  </header>

  <div class="version-pin" id="versionPin">v?</div>

  <div class="shell">
    <div class="row">
      <!-- EDITOR -->
      <section class="panel" id="editor-panel">
        <div class="panel-h">EDITOR ‚Äî Original (Space = Pan ¬∑ Wheel = Zoom)</div>
        <div class="panel-c">
          <div id="editor-wrap" class="canvas-wrap">
            <canvas id="editor-canvas"></canvas>
          </div>
          <div id="editor-empty" class="placeholder">Drop an image here or click ‚ÄúUpload‚Äù</div>

          <!-- Reusable Monocle lives here by default (moves to hovered panel) -->
          <div id="monocle" class="monocle"><canvas id="monocle-canvas"></canvas></div>

          <div class="progress-wrap" id="progressEditor"><div class="progress" id="progressBar"></div></div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel" id="preview-panel">
        <div class="panel-h">LIVE PREVIEW</div>
        <div class="panel-c" id="preview-container">
          <div id="preview-wrap" class="canvas-wrap">
            <canvas id="preview-canvas"></canvas>
          </div>
          <div id="preview-empty" class="placeholder">Your result will appear here</div>
        </div>
      </section>
    </div>

    <div class="bottom">
      <!-- PRESETS -->
      <section class="presets panel">
        <div class="panel-h">PRESET GALLERY (click to apply)</div>
        <div id="presets" class="presets-grid"></div>
      </section>

      <!-- SETTINGS + LOGS -->
      <section class="side panel">
        <div class="side-c">
          <div class="settings">
            <div class="set-row">
              <strong>Settings</strong>
              <button id="toggleLogsBtn" style="margin-left:auto">üìù Toggle Logs</button>
            </div>
            <div class="set-row">
              <label for="aggrRange">Feather</label>
              <input type="range" id="aggrRange" min="0" max="100" value="35"/>
              <span id="aggrVal">35</span>
            </div>
            <div class="set-row">
              <label for="tolRange">Tolerance (Auto tools)</label>
              <input type="range" id="tolRange" min="0" max="100" value="25"/>
              <span id="tolVal">25</span>
            </div>
            <div class="set-row">
              <label for="fltRange">Filter Strength</label>
              <input type="range" id="fltRange" min="0" max="100" value="100"/>
              <span id="fltVal">100%</span>
            </div>
          </div>
          <div class="logs">
            <div class="log-header">
              <div><strong>Developer Log</strong></div>
              <div><button id="clearLogsBtn">Clear</button></div>
            </div>
            <div id="logBody" class="log-body"></div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- hidden inputs -->
  <input type="file" id="fileInput" accept="image/*" class="hidden"/>
  <input type="file" id="loadInput" accept=".json,.txt" class="hidden"/>

  <!-- Worker source (embedded); we‚Äôll spin it up from a Blob URL -->
  <script id="seg-worker-src" type="text/plain">
/* seg-worker.js ‚Äî minimal, fast, and deterministic */
self.postMessage({type:'ready'});

self.onmessage = (e)=>{
  const {type, payload, reqId} = e.data || {};
  if(type!=='segment') return;
  try{
    const {tool, seedX, seedY, tol01, aggr, width, height, image} = payload;
    const data = image.data; // Uint8ClampedArray transferred

    // Build grayscale for gradients
    const N = width*height;
    const gray = new Float32Array(N);
    for(let i=0,j=0;i<N;i++,j+=4){
      gray[i] = 0.2126*data[j] + 0.7152*data[j+1] + 0.0722*data[j+2];
    }
    const grad = sobelMag(gray, width, height);
    const gradN = normalize01(grad);

    let alpha;
    if(tool==='autoSmart'){ // EdgeGrow
      const params = defaultsEdgeGrow(tol01, aggr);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      returnMask(alpha, width, height, {tool:'edgeGrow', seedX, seedY, params}, reqId);
    } else if(tool==='autoUltra'){ // GrabCut-lite (fallback to color-strong EdgeGrow if EM/mincut too heavy)
      // Simple, robust fallback: color-biased edge grow + small dilation near seed imitates trimap
      const params = defaultsEdgeGrow(Math.min(1, tol01*1.1+0.05), aggr+10);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      // quick reinforce near seed
      paintDisk(alpha, width, height, seedX, seedY, Math.max(6, Math.round(Math.min(width,height)*0.01)), 255);
      returnMask(alpha, width, height, {tool:'grabcutLite', seedX, seedY, params}, reqId);
    } else if(tool==='autoObjects') {
      const params = defaultsEdgeGrow(tol01, aggr);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      returnMask(alpha, width, height, {tool:'edgeGrow', seedX, seedY, params, auto:true}, reqId);
    } else {
      // default
      const params = defaultsEdgeGrow(tol01, aggr);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      returnMask(alpha, width, height, {tool:'edgeGrow', seedX, seedY, params}, reqId);
    }
  }catch(err){
    self.postMessage({type:'error', reqId, payload:String(err)});
  }
};

// ----- utils -----
function normalize01(arr){
  let mn=Infinity,mx=-Infinity; for(const v of arr){ if(v<mn) mn=v; if(v>mx) mx=v; }
  const out=new Float32Array(arr.length); const d=mx-mn||1;
  for(let i=0;i<arr.length;i++) out[i]=(arr[i]-mn)/d;
  return out;
}
function sobelMag(gray,W,H){
  const out=new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i=y*W+x;
      const tl=(y-1)*W+(x-1), t=(y-1)*W+x, tr=(y-1)*W+(x+1);
      const ml=y*W+(x-1), mr=y*W+(x+1);
      const bl=(y+1)*W+(x-1), b=(y+1)*W+x, br=(y+1)*W+(x+1);
      const gx = -gray[tl]-2*gray[ml]-gray[bl] + gray[tr]+2*gray[mr]+gray[br];
      const gy = -gray[tl]-2*gray[t]-gray[tr] + gray[bl]+2*gray[b]+gray[br];
      out[i] = Math.hypot(gx,gy);
    }
  }
  return out;
}

function defaultsEdgeGrow(tol01, aggr){
  return {
    wc: 1.0,
    we: 2.0 + 1.2*tol01,
    wd: 0.02,
    tau: 18 + 160*tol01 + aggr*0.6,
    diag: true
  };
}

function edgeAwareGrowMask(rgbU8, W, H, sx, sy, grad01, p){
  const idx = (x,y)=> y*W + x;
  const N = W*H;
  const cost = new Float32Array(N); cost.fill(1e20);
  const seen = new Uint8Array(N);
  const heapCost = new Float32Array(N); const heapIdx = new Int32Array(N); let heapSize=0;
  function heapPush(c, i){
    let k = heapSize++; heapCost[k]=c; heapIdx[k]=i;
    while(k){ const pK=(k-1)>>1; if(heapCost[pK]<=c) break; swap(k,pK); k=pK; }
  }
  function heapPop(){
    if(!heapSize) return [-1,-1];
    const c=heapCost[0], i=heapIdx[0];
    const ck=heapCost[--heapSize], ik=heapIdx[heapSize];
    if(heapSize){ heapCost[0]=ck; heapIdx[0]=ik; down(0); }
    return [c,i];
  }
  function swap(a,b){ const tc=heapCost[a]; heapCost[a]=heapCost[b]; heapCost[b]=tc; const ti=heapIdx[a]; heapIdx[a]=heapIdx[b]; heapIdx[b]=ti; }
  function down(k){
    for(;;){
      let l=k*2+1, r=l+1, s=k;
      if(l<heapSize && heapCost[l]<heapCost[s]) s=l;
      if(r<heapSize && heapCost[r]<heapCost[s]) s=r;
      if(s===k) break; swap(k,s); k=s;
    }
  }

  // Pre-bake RGB to Float32
  const R = new Float32Array(N), G = new Float32Array(N), B = new Float32Array(N);
  for(let i=0,j=0;i<N;i++,j+=4){ R[i]=rgbU8[j]; G[i]=rgbU8[j+1]; B[i]=rgbU8[j+2]; }

  const seed = idx(Math.max(0,Math.min(W-1,sx)), Math.max(0,Math.min(H-1,sy)));
  cost[seed]=0; heapPush(0, seed);

  const deltas = p.diag ? [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]] : [[1,0],[-1,0],[0,1],[0,-1]];
  let accepted=0, maxAccept=N;

  while(heapSize){
    const popped = heapPop(); const c = popped[0], i = popped[1];
    if(i<0) break; if(seen[i]) continue; seen[i]=1; accepted++;
    if(c>p.tau || accepted>maxAccept) break;

    const x=i%W, y=(i-x)/W;
    for(const d of deltas){
      const nx=x+d[0], ny=y+d[1];
      if(nx<0||ny<0||nx>=W||ny>=H) continue;
      const j = idx(nx,ny); if(seen[j]) continue;

      const dR = R[i]-R[j], dG = G[i]-G[j], dB = B[i]-B[j];
      const dE = Math.hypot(dR,dG,dB);
      const eStop = 1.0 - (grad01[j]/(grad01[j]+1e-6));
      const step = p.wc*dE + p.we*eStop + p.wd*((d[0]&&d[1])?Math.SQRT2:1.0);
      const nc = c + step;
      if(nc < cost[j] && nc <= p.tau){ cost[j]=nc; heapPush(nc,j); }
    }
  }

  const alpha = new Uint8ClampedArray(N);
  const t0 = Math.max(4, 0.92*p.tau), t1 = p.tau;
  for(let i=0;i<N;i++){
    const ci = cost[i];
    if(ci>=1e18){ alpha[i]=0; continue; }
    if(ci<=t0){ alpha[i]=255; }
    else if(ci>=t1){ alpha[i]=0; }
    else { const a = 1 - (ci - t0)/(t1 - t0); alpha[i] = Math.round(255*a); }
  }
  return alpha;
}

function paintDisk(alpha, W,H, cx,cy, r, v){
  const r2=r*r;
  for(let y=Math.max(0,cy-r); y<Math.min(H,cy+r+1); y++){
    for(let x=Math.max(0,cx-r); x<Math.min(W,cx+r+1); x++){
      const dx=x-cx, dy=y-cy; if(dx*dx+dy*dy<=r2){ alpha[y*W+x]=v; }
    }
  }
}

function returnMask(alphaU8, width, height, generator, reqId){
  self.postMessage({type:'mask', reqId, payload:{width,height,alphaU8,generator}}, [alphaU8.buffer]);
}
  </script>

  <script>
  (function(){
    'use strict';

    // -------------------------- META / VERSION --------------------------
    const APP_VERSION = "1.17.0";
    document.getElementById('versionBadge').textContent = APP_VERSION;
    document.getElementById('versionPin').textContent = APP_VERSION;

    // -------------------------- DOM --------------------------
    const $ = (id)=>document.getElementById(id);
    const dom = {
      uploadBtn: $('uploadBtn'), saveBtn: $('saveBtn'), loadBtn: $('loadBtn'), startOverBtn: $('startOverBtn'),
      undoBtn: $('undoBtn'), redoBtn: $('redoBtn'),
      modeLassoBtn: $('modeLassoBtn'), newLassoBtn: $('newLassoBtn'), modeBoxBtn: $('modeBoxBtn'),
      deleteSelectionBtn: $('deleteSelectionBtn'), renderNowBtn: $('renderNowBtn'),
      autoWandBtn: $('autoWandBtn'), autoSmartBtn: $('autoSmartBtn'), autoUltraBtn: $('autoUltraBtn'), autoObjectsBtn: $('autoObjectsBtn'),
      protectEraserBtn: $('protectEraserBtn'), removeEraserBtn: $('removeEraserBtn'),
      resetViewBtn: $('resetViewBtn'), downloadBtn: $('downloadBtn'),
      fileInput: $('fileInput'), loadInput: $('loadInput'),
      editorPanel: $('editor-panel'), editorWrap: $('editor-wrap'), editorCanvas: $('editor-canvas'), editorEmpty: $('editor-empty'),
      previewPanel: $('preview-panel'), previewWrap: $('preview-wrap'), previewContainer: $('preview-container'), previewCanvas: $('preview-canvas'), previewEmpty: $('preview-empty'),
      presets: $('presets'),
      progressWrap: $('progressEditor'), progressBar: $('progressBar'),
      aggrRange: $('aggrRange'), aggrVal: $('aggrVal'),
      tolRange: $('tolRange'), tolVal: $('tolVal'),
      fltRange: $('fltRange'), fltVal: $('fltVal'),
      toggleLogsBtn: $('toggleLogsBtn'), clearLogsBtn: $('clearLogsBtn'), logBody: $('logBody'),
      monocle: $('monocle'), monocleCanvas: $('monocle-canvas')
    };

    // -------------------------- UTIL --------------------------
    const log = (...args)=> {
      const line = document.createElement('div');
      line.className='log-line';
      line.textContent = `[${new Date().toLocaleTimeString()}] ` + args.join(' ');
      dom.logBody.appendChild(line);
      dom.logBody.scrollTop = dom.logBody.scrollHeight;
    };
    const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
    const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), ms); }; };

    // -------------------------- STATE --------------------------
    const state = {
      image: null,
      selections: [], // box | lasso | mask | protect
      activeIndex: -1,
      mode: 'lasso',
      transform: {x:0,y:0,scale:1}, // editor transform
      isPanning: false,
      drag: { active:false, startX:0,startY:0, kind:null, handle:null, moved:false, snapshot:null },
      history: [], histIndex: -1,
      activePreset: 0,
      filters: [
        {name:'Classic',   css:(s)=>`grayscale(${s}%)`,                                                aggr:20},
        {name:'High Pop',  css:(s)=>`grayscale(${s}%) contrast(1.35) brightness(1.05)`,                aggr:30},
        {name:'Soft Film', css:(s)=>`grayscale(${s}%) brightness(1.03) contrast(1.08) saturate(.9)`,   aggr:35},
        {name:'Crunchy',   css:(s)=>`grayscale(${s}%) contrast(1.55)`,                                 aggr:45},
        {name:'Dreamy',    css:(s)=>`grayscale(${s}%) blur(0.6px) brightness(1.06)`,                   aggr:60},
        {name:'Neutral',   css:(s)=>`grayscale(${s}%) brightness(1.02)`,                               aggr:25}
      ],
      aggr: 35, tol: 25, filtStrength: 100,
      rendering: false,
      brush: {size: 28, hard: 0.9},
      thumbnailsReady: false,
    };

    // -------------------------- SEGMENTATION WORKER --------------------------
    let segWorker = null, segReady=false;
    function initSegWorker(){
      if(segWorker) return;
      try{
        const src = document.getElementById('seg-worker-src').textContent;
        const blob = new Blob([src], {type:'application/javascript'});
        const url = URL.createObjectURL(blob);
        segWorker = new Worker(url);
        segWorker.onmessage = (e)=>{
          const {type, payload, reqId} = e.data || {};
          if(type==='ready'){ segReady=true; log('Seg Worker ready.'); return; }
          if(type==='log'){ log(payload); return; }
          if(type==='error'){ log('Worker error:', payload); finishProgress(); return; }
          if(type==='mask'){
            const cnv = document.createElement('canvas');
            cnv.width = payload.width; cnv.height = payload.height;
            const ctx = cnv.getContext('2d');
            const id = ctx.createImageData(payload.width, payload.height);
            // RGBA = white with alpha=mask
            for(let i=0,j=0;i<id.data.length;i+=4,j++){
              id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=payload.alphaU8[j];
            }
            ctx.putImageData(id,0,0);

            // If replacing an existing generated selection (reqId hint?), we just append for simplicity.
            state.selections.push({ type:'mask', maskCanvas: cnv, generator: payload.generator });
            state.activeIndex = state.selections.length-1;
            editor.draw(); schedulePreviewRender(true); history.save();
            finishProgress();
            log('Seg mask added:', payload.generator?.tool || '');
          }
        };
      }catch(err){
        log('Failed to init worker, will fallback:', String(err));
      }
    }

    function requestSegMask(tool, seedX, seedY, tol, aggr){
      return new Promise((resolve)=>{
        const W = state.image.width, H = state.image.height;
        const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
        const tx = tmp.getContext('2d'); tx.drawImage(state.image,0,0);
        const imgData = tx.getImageData(0,0,W,H);
        const reqId = Math.random().toString(36).slice(2);
        segWorker.postMessage({
          type:'segment',
          reqId,
          payload:{ tool, seedX, seedY, tol01: clamp(tol/100,0,1), aggr, width:W, height:H, image: imgData }
        }, [imgData.data.buffer]);
        resolve();
      });
    }

    // -------------------------- EDITOR --------------------------
    const editor = {
      c: dom.editorCanvas,
      ctx: dom.editorCanvas.getContext('2d'),
      updateSize(){
        const w = dom.editorWrap.clientWidth, h = dom.editorWrap.clientHeight;
        this.c.width = w; this.c.height = h;
      },
      imgToCanvasSpace(clientX, clientY){
        const r = this.c.getBoundingClientRect();
        const x = (clientX - r.left - state.transform.x)/state.transform.scale;
        const y = (clientY - r.top - state.transform.y)/state.transform.scale;
        return {x,y};
      },
      draw(){
        if(!state.image){
          this.ctx.clearRect(0,0,this.c.width,this.c.height); return;
        }
        const {ctx,c} = this;
        ctx.clearRect(0,0,c.width,c.height);
        ctx.save();
        ctx.translate(state.transform.x, state.transform.y);
        ctx.scale(state.transform.scale, state.transform.scale);
        ctx.drawImage(state.image, 0, 0);

        // overlays
        state.selections.forEach((sel,i)=>{
          const active = i===state.activeIndex;
          ctx.save();
          ctx.lineWidth = active ? 2.5 / state.transform.scale : 1.5 / state.transform.scale;
          ctx.strokeStyle = active ? '#1877f2' : 'rgba(0,0,0,.45)';
          ctx.fillStyle = active ? 'rgba(24,119,242,.08)' : 'rgba(255,255,255,.18)';
          ctx.setLineDash(active ? [] : [6 / state.transform.scale, 4 / state.transform.scale]);

          if(sel.type==='box'){
            ctx.strokeRect(sel.x, sel.y, sel.w, sel.h);
            ctx.fillRect(sel.x, sel.y, sel.w, sel.h);
            if(active) drawBoxHandles(ctx, sel);
          } else if(sel.type==='lasso'){
            ctx.beginPath();
            sel.points.forEach((p,idx)=> idx?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
          } else if((sel.type==='mask' || sel.type==='protect') && sel.maskCanvas){
            ctx.globalAlpha = active ? 0.25 : 0.15;
            ctx.drawImage(sel.maskCanvas, 0, 0);
            ctx.globalAlpha = 1;
            const edge = edgeFromMask(sel.maskCanvas, 1);
            if(edge){
              ctx.save();
              ctx.strokeStyle = sel.type==='protect' ? '#b00020' : (active ? '#1877f2' : 'rgba(0,0,0,.45)');
              ctx.lineWidth = active ? 2.0 / state.transform.scale : 1.2 / state.transform.scale;
              ctx.drawImage(edge, 0, 0);
              ctx.restore();
            }
          }
          ctx.restore();
        });
        ctx.restore();
      }
    };

    // -------------------------- PREVIEW --------------------------
    const preview = {
      c: dom.previewCanvas,
      ctx: dom.previewCanvas.getContext('2d'),
      mask: document.createElement('canvas'),
      maskCtx: null,
      init(){ this.maskCtx = this.mask.getContext('2d'); },
      layout(){
        if(!state.image){ return; }
        const rect = dom.previewContainer.getBoundingClientRect();
        const availW = Math.max(0, rect.width);
        const availH = Math.max(0, rect.height);
        const aspect = state.image.width / state.image.height;
        let w = availW, h = w/aspect;
        if(h>availH){ h = availH; w = h*aspect; }
        this.c.width = Math.max(1, Math.round(w));
        this.c.height = Math.max(1, Math.round(h));
        dom.previewCanvas.style.left = ((availW - this.c.width)/2) + 'px';
        dom.previewCanvas.style.top  = ((availH - this.c.height)/2) + 'px';
      },
      render(){
        if(!state.image) return;

        // build composite mask full-res then scale to preview canvas
        const fullMask = buildFullMaskCanvas(); // full native size
        const ctx = this.ctx;
        ctx.clearRect(0,0,this.c.width,this.c.height);

        // background filtered
        const cssFilter = state.filters[state.activePreset].css(state.filtStrength);
        ctx.save();
        ctx.filter = cssFilter;
        ctx.drawImage(state.image, 0, 0, this.c.width, this.c.height);
        ctx.restore();

        // colorized via mask
        const colored = document.createElement('canvas');
        colored.width = state.image.width; colored.height = state.image.height;
        const cctx = colored.getContext('2d');
        cctx.drawImage(state.image,0,0);
        cctx.globalCompositeOperation = 'destination-in';
        cctx.drawImage(fullMask,0,0);
        ctx.drawImage(colored, 0,0, this.c.width, this.c.height);
      }
    };

    function buildFullMaskCanvas(){
      const m = document.createElement('canvas');
      const W = state.image.width, H = state.image.height;
      m.width = W; m.height = H;
      const mctx = m.getContext('2d');

      // base mask (white = colorized)
      mctx.fillStyle = '#fff';
      state.selections.forEach(sel=>{
        if(sel.type==='box'){
          mctx.fillRect(sel.x, sel.y, sel.w, sel.h);
        } else if(sel.type==='lasso'){
          mctx.beginPath();
          sel.points.forEach((p,i)=> i?mctx.lineTo(p.x,p.y):mctx.moveTo(p.x,p.y));
          mctx.closePath();
          mctx.fill();
        } else if(sel.type==='mask' && sel.maskCanvas){
          mctx.drawImage(sel.maskCanvas, 0, 0);
        }
      });

      // subtract protections
      state.selections.forEach(sel=>{
        if(sel.type==='protect' && sel.maskCanvas){
          mctx.globalCompositeOperation = 'destination-out';
          mctx.drawImage(sel.maskCanvas, 0, 0);
          mctx.globalCompositeOperation = 'source-over';
        }
      });

      // feather (same interpretation as preview)
      const blurPx = Math.round(clamp(state.aggr,0,100) * 0.22);
      if(blurPx>0){
        const tmp = document.createElement('canvas');
        tmp.width = W; tmp.height = H;
        const tctx = tmp.getContext('2d');
        tctx.filter = `blur(${blurPx}px)`;
        tctx.drawImage(m,0,0);
        mctx.clearRect(0,0,W,H);
        mctx.drawImage(tmp,0,0);
      }
      return m;
    }

    // -------------------------- PRESETS (lazy) --------------------------
    function renderPresets(lazy=false){
      if(!state.image){
        dom.presets.innerHTML = '';
        for(let i=0;i<state.filters.length;i++){
          const item = document.createElement('div');
          item.className = 'preset';
          item.innerHTML = `<canvas width="84" height="60"></canvas><label>${state.filters[i].name}</label>`;
          dom.presets.appendChild(item);
        }
        return;
      }

      const doRender = ()=>{
        dom.presets.innerHTML = '';
        state.filters.forEach((flt, idx)=>{
          const item = document.createElement('div');
          item.className = 'preset' + (idx===state.activePreset?' active':'');
          item.innerHTML = `<canvas></canvas><label>${flt.name}</label>`;
          const c = item.querySelector('canvas'), cctx = c.getContext('2d');
          const aspect = state.image.width/state.image.height;
          c.width = 84; c.height = Math.max(56, Math.round(84/aspect));
          cctx.save(); cctx.filter = flt.css(100);
          cctx.drawImage(state.image, 0,0,c.width,c.height);
          cctx.restore();

          item.addEventListener('click', ()=>{
            state.activePreset = idx;
            state.aggr = state.filters[idx].aggr;
            updateSettingsUI();
            document.querySelectorAll('.preset').forEach(el=>el.classList.remove('active'));
            item.classList.add('active');
            schedulePreviewRender(true);
            log('Preset:', flt.name, 'Feather:', state.aggr);
          });
          dom.presets.appendChild(item);
        });
        state.thumbnailsReady = true;
      };

      if(lazy){
        state.thumbnailsReady = false;
        setTimeout(doRender, 700);
      } else {
        doRender();
      }
    }

    // -------------------------- HISTORY --------------------------
    const history = {
      save(){
        const snapshot = {
          selections: JSON.parse(JSON.stringify(state.selections, (k,v)=>{
            if((k==='maskCanvas') && v && v.toDataURL) return v.toDataURL();
            return v;
          })),
          activeIndex: state.activeIndex,
          transform: {...state.transform},
          activePreset: state.activePreset,
          aggr: state.aggr, tol: state.tol, filtStrength: state.filtStrength
        };
        if(state.histIndex < state.history.length-1) state.history = state.history.slice(0,state.histIndex+1);
        state.history.push(JSON.stringify(snapshot));
        state.histIndex++;
        refreshButtons();
      },
      load(i){
        const snap = JSON.parse(state.history[i]);
        state.selections = (snap.selections||[]).map(s=>{
          if((s.type==='mask' || s.type==='protect') && s.maskCanvas && typeof s.maskCanvas==='string'){
            const cnv = dataURLToCanvas(s.maskCanvas);
            return {...s, maskCanvas: cnv};
          }
          return s;
        });
        state.activeIndex = snap.activeIndex;
        state.transform = snap.transform;
        state.activePreset = snap.activePreset ?? state.activePreset;
        state.aggr = snap.aggr ?? state.aggr;
        state.tol = snap.tol ?? state.tol;
        state.filtStrength = snap.filtStrength ?? state.filtStrength;
        editor.draw(); schedulePreviewRender(true); renderPresets(true); updateSettingsUI(); refreshButtons();
      },
      undo(){ if(state.histIndex>0){ state.histIndex--; history.load(state.histIndex); log('Undo'); } },
      redo(){ if(state.histIndex<state.history.length-1){ state.histIndex++; history.load(state.histIndex); log('Redo'); } }
    };

    // -------------------------- BOX / LASSO HELPERS --------------------------
    function defaultBoxAt(x,y){
      const s = Math.max(40, Math.min(state.image.width, state.image.height)*0.12);
      return {type:'box', x: clamp(x - s/2, 0, state.image.width - s), y: clamp(y - s/2, 0, state.image.height - s), w: s, h: s};
    }
    function hitBoxHandle(sel, x, y){
      const pad = 8 / state.transform.scale;
      const pts = [
        ['nw', sel.x, sel.y], ['n',  sel.x+sel.w/2, sel.y], ['ne', sel.x+sel.w, sel.y],
        ['e',  sel.x+sel.w, sel.y+sel.h/2], ['se', sel.x+sel.w, sel.y+sel.h],
        ['s',  sel.x+sel.w/2, sel.y+sel.h], ['sw', sel.x, sel.y+sel.h], ['w',  sel.x, sel.y+sel.h/2],
      ];
      for(const [name, px, py] of pts){
        if(Math.abs(x-px)<=pad && Math.abs(y-py)<=pad) return name;
      }
      return null;
    }
    function drawBoxHandles(ctx, sel){
      const r = 5 / state.transform.scale;
      const pts = [
        [ sel.x, sel.y],[ sel.x+sel.w/2, sel.y],[ sel.x+sel.w, sel.y],
        [ sel.x+sel.w, sel.y+sel.h/2],[ sel.x+sel.w, sel.y+sel.h],
        [ sel.x+sel.w/2, sel.y+sel.h],[ sel.x, sel.y+sel.h],[ sel.x, sel.y+sel.h/2]
      ];
      ctx.fillStyle='#1877f2';
      ctx.strokeStyle='#fff';
      ctx.lineWidth = 1.5 / state.transform.scale;
      pts.forEach(([px,py])=>{ ctx.beginPath(); ctx.rect(px-r, py-r, r*2, r*2); ctx.fill(); ctx.stroke(); });
    }
    const pointInBox = (sel,x,y)=> x>=sel.x && y>=sel.y && x<=sel.x+sel.w && y<=sel.y+sel.h;
    function pointInLasso(sel, x, y){
      let inside = false;
      const pts = sel.points;
      for(let i=0,j=pts.length-1; i<pts.length; j=i++){
        const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
        const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside = !inside;
      }
      return inside;
    }

    // -------------------------- RENDER FLOW & PROGRESS --------------------------
    let progressTimer=null, progressTarget=78;
    function startProgress(){
      dom.progressWrap.classList.add('visible');
      let p = 0; dom.progressBar.style.width = '0%';
      clearInterval(progressTimer);
      progressTimer = setInterval(()=>{
        p = clamp(p + 12, 0, progressTarget);
        dom.progressBar.style.width = p + '%';
      }, 60);
    }
    function finishProgress(){
      clearInterval(progressTimer);
      progressTimer = null;
      dom.progressBar.style.width = '100%';
      setTimeout(()=>{ dom.progressWrap.classList.remove('visible'); dom.progressBar.style.width='0%'; }, 280);
    }

    const renderPreviewDebounced = debounce(()=>{
      if(!state.image) return;
      state.rendering = true;
      preview.layout();
      preview.render();
      state.rendering = false;
      finishProgress();
      renderPresets(true);
      log('Preview rendered.');
    }, 380);

    function schedulePreviewRender(startProgressBar=true){
      if(!state.image) return;
      if(startProgressBar) startProgress();
      renderPreviewDebounced();
    }

    // -------------------------- FILE I/O --------------------------
    dom.uploadBtn.addEventListener('click', ()=>dom.fileInput.click());
    dom.fileInput.addEventListener('change', onFileInput);

    // Drag & Drop on editor only
    ['dragover','dragenter'].forEach(ev=>{
      dom.editorWrap.addEventListener(ev,(e)=>{ e.preventDefault(); dom.editorWrap.classList.add('drop-hover'); });
    });
    ['dragleave','drop'].forEach(ev=>{
      dom.editorWrap.addEventListener(ev,(e)=>{ e.preventDefault(); dom.editorWrap.classList.remove('drop-hover'); });
    });
    dom.editorWrap.addEventListener('drop', (e)=>{
      e.preventDefault();
      const f = e.dataTransfer?.files?.[0];
      if(f && f.type.startsWith('image/')) readImageFile(f);
    });

    function onFileInput(e){
      const f = e.target.files[0];
      if(f) readImageFile(f);
    }
    function readImageFile(file){
      const r = new FileReader();
      r.onload = ()=>{
        const img = new Image();
        img.onload = ()=>{
          state.image = img;
          state.selections = [];
          state.activeIndex = -1;
          dom.editorEmpty.classList.add('hidden');
          dom.previewEmpty.classList.add('hidden');
          editor.updateSize(); preview.init();
          focal.fit();
          editor.draw();
          renderPresets(true);
          history.save();
          refreshButtons();
          schedulePreviewRender(true);
          dom.monocle.style.display = 'block';
          attachMonocle(dom.editorPanel);
          initSegWorker();
          log('Image loaded:', file.name, `${img.width}x${img.height}`);
        };
        img.src = r.result;
      };
      r.readAsDataURL(file);
    }

    // -------------------------- FOCAL FIT / RESET VIEW --------------------------
    const focal = {
      fit(){
        if(!state.image) return;
        const iW = state.image.width, iH = state.image.height;
        const cW = dom.editorWrap.clientWidth, cH = dom.editorWrap.clientHeight;
        const scale = Math.min(cW/iW, cH/iH) * 0.97;
        const x = (cW - iW*scale)/2;
        const y = (cH - iH*scale)/2;
        state.transform = {x,y,scale};
      }
    };
    const refitDebounced = debounce(()=>{ if(state.image){ focal.fit(); editor.draw(); preview.layout(); } }, 140);
    window.addEventListener('resize', ()=>{ editor.updateSize(); preview.layout(); refitDebounced(); });

    // -------------------------- EDITOR & PREVIEW INTERACTIONS --------------------------
    let painting = false; // erasers

    dom.editorWrap.addEventListener('mousedown', async (e)=>{
      if(!state.image) return;

      if(state.isPanning){
        state.drag = {active:true,kind:'pan', startX:e.clientX, startY:e.clientY, tx:state.transform.x, ty:state.transform.y, moved:false};
        dom.editorWrap.classList.add('panning'); return;
      }

      const p = editor.imgToCanvasSpace(e.clientX, e.clientY);

      // Auto tools
      if(state.mode==='autoSmart' || state.mode==='autoUltra'){
        const sx = Math.round(p.x), sy = Math.round(p.y);
        if(segReady){
          startProgress();
          await requestSegMask(state.mode, sx, sy, state.tol, state.aggr);
        } else {
          // Fallback to built-ins (keep behavior)
          const mask = (state.mode==='autoUltra')
            ? ultraMask(state.image, sx, sy, state.tol/100, state.aggr)
            : magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
          if(mask){
            state.selections.push({type:'mask', maskCanvas: mask, generator:{
              tool: (state.mode==='autoUltra'?'grabcutLite':'edgeGrow'),
              seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr, fallback:true }
            }});
            state.activeIndex = state.selections.length-1;
            editor.draw();
            schedulePreviewRender(true);
            history.save();
          }
        }
        return;
      }

      if(state.mode==='autoWand'){
        const sx = Math.round(p.x), sy = Math.round(p.y);
        const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
        if(mask){
          state.selections.push({type:'mask', maskCanvas: mask, generator:{
            tool:'magicWand', seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr }
          }});
          state.activeIndex = state.selections.length-1;
          editor.draw(); schedulePreviewRender(true); history.save();
          log('Auto Wand selection added.');
        }
        return;
      }

      if(state.mode==='protectEraser' || state.mode==='removeEraser'){
        painting = true;
        ensureBrushLayer(state.mode==='protectEraser' ? 'protect' : 'mask');
        paintOnActiveMask(p.x, p.y, true);
        editor.draw(); schedulePreviewRender();
        return;
      }

      // hit-tests
      let hitIndex = -1, hitHandle = null, hitKind='none';
      for(let i=state.selections.length-1;i>=0;i--){
        const sel = state.selections[i];
        if(sel.type==='box'){
          const h = hitBoxHandle(sel,p.x,p.y);
          if(h){ hitIndex=i; hitHandle=h; hitKind='box-resize'; break; }
          if(pointInBox(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='lasso'){
          if(pointInLasso(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='mask' || sel.type==='protect'){
          if(maskHit(sel.maskCanvas, p.x, p.y)){ hitIndex=i; hitKind='move'; break; }
        }
      }

      if(hitIndex>=0){
        state.activeIndex = hitIndex;
        state.drag = {active:true, kind:hitKind, handle:hitHandle, startX:p.x, startY:p.y, moved:false,
                      snapshot: JSON.parse(JSON.stringify(state.selections[hitIndex], (k,v)=>{
                        if(k==='maskCanvas' && v && v.toDataURL) return v.toDataURL();
                        return v;
                      }))};
        editor.draw();
        return;
      }

      // start new
      state.activeIndex = -1;
      if(state.mode==='box'){
        const seed = {type:'box', x:p.x, y:p.y, w:0, h:0};
        state.selections.push(seed);
        state.activeIndex = state.selections.length-1;
        state.drag = {active:true,kind:'box-make', startX:p.x, startY:p.y, moved:false};
      } else if(state.mode==='lasso'){
        state.activeIndex = state.selections.length;
        const sel = {type:'lasso', points:[p]};
        state.selections.push(sel);
        state.drag = {active:true,kind:'lasso-make', last:p, moved:false};
      }
      editor.draw();
    });

    dom.editorWrap.addEventListener('mousemove', (e)=>{
      if(!state.image) return;
      updateMonocle(e, 'editor');

      if(painting && (state.mode==='protectEraser' || state.mode==='removeEraser')){
        const p = editor.imgToCanvasSpace(e.clientX, e.clientY);
        paintOnActiveMask(p.x, p.y, false);
        editor.draw(); schedulePreviewRender();
        return;
      }

      if(!state.drag.active) return;
      const p = editor.imgToCanvasSpace(e.clientX,e.clientY);
      if(!state.drag.moved && (Math.abs(e.clientX-state.drag.startX)>3 || Math.abs(e.clientY-state.drag.startY)>3)) state.drag.moved = true;

      switch(state.drag.kind){
        case 'pan':{
          state.transform.x = state.drag.tx + (e.clientX - state.drag.startX);
          state.transform.y = state.drag.ty + (e.clientY - state.drag.startY);
          editor.draw();
          break;
        }
        case 'box-resize':{
          const sel = state.selections[state.activeIndex];
          const snap = reviveMaskInSnapshot(state.drag.snapshot);
          const handle = state.drag.handle;
          const minSize = 10;
          const right = snap.x + snap.w, bottom = snap.y + snap.h;
          let nx = snap.x, ny = snap.y, nw = snap.w, nh = snap.h;
          if(handle.includes('n')){ ny = Math.min(bottom - minSize, p.y); nh = bottom - ny; }
          if(handle.includes('s')){ nh = Math.max(minSize, p.y - snap.y); }
          if(handle.includes('w')){ nx = Math.min(right - minSize, p.x); nw = right - nx; }
          if(handle.includes('e')){ nw = Math.max(minSize, p.x - snap.x); }
          Object.assign(sel, {x:nx, y:ny, w:nw, h:nh});
          editor.draw(); schedulePreviewRender();
          break;
        }
        case 'move':{
          const sel = state.selections[state.activeIndex];
          const snap = reviveMaskInSnapshot(state.drag.snapshot);
          const dx = p.x - state.drag.startX, dy = p.y - state.drag.startY;
          if(sel.type==='box'){ sel.x = snap.x + dx; sel.y = snap.y + dy; }
          else if(sel.type==='lasso'){ sel.points = snap.points.map(pt=>({x:pt.x+dx, y:pt.y+dy})); }
          else if(sel.type==='mask' || sel.type==='protect'){
            const moved = document.createElement('canvas');
            moved.width = snap.maskCanvas.width; moved.height = snap.maskCanvas.height;
            moved.getContext('2d').drawImage(snap.maskCanvas, dx, dy);
            sel.maskCanvas = moved;
          }
          editor.draw(); schedulePreviewRender();
          break;
        }
        case 'box-make':{
          const startX = state.drag.startX, startY = state.drag.startY;
          const x = Math.min(startX, p.x), y = Math.min(startY, p.y);
          const w = Math.abs(p.x - startX), h = Math.abs(p.y - startY);
          const sel = state.selections[state.activeIndex];
          Object.assign(sel, {x,y,w,h});
          editor.draw(); schedulePreviewRender();
          break;
        }
        case 'lasso-make':{
          const sel = state.selections[state.activeIndex];
          const last = state.drag.last;
          const dist2 = (p.x-last.x)**2 + (p.y-last.y)**2;
          if(dist2 > (4/state.transform.scale)**2){
            sel.points.push(p);
            state.drag.last = p;
            editor.draw();
          }
          break;
        }
      }
    });

    window.addEventListener('mouseup', ()=>{
      if(!state.image) return;

      if(painting){
        painting = false; history.save(); return;
      }

      if(!state.drag.active) return;
      const wasMake = /-make$/.test(state.drag.kind);
      if(state.drag.kind==='lasso-make'){
        const sel = state.selections[state.activeIndex];
        if(sel && sel.points.length>2){
          const a = sel.points[0], b = sel.points[sel.points.length-1];
          if(a.x!==b.x || a.y!==b.y) sel.points.push({x:a.x,y:a.y});
        }
      }
      if(state.drag.kind==='box-make' && !state.drag.moved){
        state.selections[state.activeIndex] = defaultBoxAt(state.drag.startX, state.drag.startY);
      } else if(state.drag.kind==='box-make'){
        const sel = state.selections[state.activeIndex];
        if(sel && (sel.w<5 || sel.h<5)){ state.selections.splice(state.activeIndex,1); state.activeIndex = -1; }
      }
      if(state.drag.kind==='lasso-make'){
        const sel = state.selections[state.activeIndex];
        if(sel && sel.points.length<3){ state.selections.splice(state.activeIndex,1); state.activeIndex = -1; }
      }

      state.drag.active=false;
      dom.editorWrap.classList.remove('panning');
      editor.draw();
      schedulePreviewRender(true);
      history.save();
      if(wasMake) log('Selection added.');
    });

    // zoom
    dom.editorWrap.addEventListener('wheel', (e)=>{
      if(!state.image) return;
      e.preventDefault();
      const r = dom.editorCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const zf = 1.1;
      const zoom = e.deltaY < 0 ? zf : 1/zf;
      const newScale = clamp(state.transform.scale * zoom, 0.1, 20);
      state.transform.x = mx - (mx - state.transform.x)*zoom;
      state.transform.y = my - (my - state.transform.y)*zoom;
      state.transform.scale = newScale;
      editor.draw();
      updateMonocle(e, 'editor');
    }, {passive:false});

    // Preview monocle (read-only hover)
    dom.previewWrap.addEventListener('mousemove', (e)=>{
      if(!state.image) return;
      updateMonocle(e, 'preview');
    });

    // Attach/Move monocle to hovered panel on enter/leave
    dom.editorWrap.addEventListener('mouseenter', ()=> attachMonocle(dom.editorPanel));
    dom.previewWrap.addEventListener('mouseenter', ()=> attachMonocle(dom.previewPanel));

    // Ensure monocle doesn't disappear on quick transitions
    dom.editorWrap.addEventListener('mouseleave', ()=>{ /* keep last image in monocle; do nothing */ });
    dom.previewWrap.addEventListener('mouseleave', ()=>{ /* keep last image in monocle; do nothing */ });

    // keys
    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space' && !state.isPanning){ state.isPanning=true; dom.editorWrap.classList.add('panning'); }
      if((e.key==='Delete'||e.key==='Backspace') && state.activeIndex!==-1){
        const removed = state.selections.splice(state.activeIndex,1)[0];
        state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save();
        log('Deleted selection:', removed?.type || '');
      }
      if(e.ctrlKey||e.metaKey){
        if(e.key.toLowerCase()==='z'){ e.preventDefault(); history.undo(); }
        if(e.key.toLowerCase()==='y'){ e.preventDefault(); history.redo(); }
      }
      if(e.key.toLowerCase()==='s'){ setMode('lasso'); }
      if(e.key.toLowerCase()==='b'){ setMode('box'); }
      if(e.key.toLowerCase()==='w'){ setMode('autoWand'); }
      if(e.key.toLowerCase()==='g'){ setMode('autoSmart'); }
      if(e.key.toLowerCase()==='u'){ setMode('autoUltra'); }
      if(e.key.toLowerCase()==='e'){ setMode('protectEraser'); }
      if(e.key.toLowerCase()==='r'){ setMode('removeEraser'); }
    });
    window.addEventListener('keyup', (e)=>{ if(e.code==='Space'){ state.isPanning=false; dom.editorWrap.classList.remove('panning'); }});

    // buttons
    dom.modeLassoBtn.addEventListener('click', ()=>setMode('lasso'));
    dom.newLassoBtn.addEventListener('click', ()=>{
      setMode('lasso'); state.activeIndex = -1; editor.draw();
      log('Ready to draw a new lasso. Click-drag on the editor to draw a freehand shape.');
    });
    dom.modeBoxBtn.addEventListener('click', ()=>setMode('box'));
    dom.deleteSelectionBtn.addEventListener('click', ()=>{
      if(state.activeIndex!==-1){
        const t = state.selections[state.activeIndex]?.type;
        state.selections.splice(state.activeIndex,1);
        state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted:', t||'');
      }
    });
    dom.autoWandBtn.addEventListener('click', ()=>setMode('autoWand'));
    dom.autoSmartBtn.addEventListener('click', ()=>setMode('autoSmart'));
    dom.autoUltraBtn.addEventListener('click', ()=>setMode('autoUltra'));
    dom.autoObjectsBtn.addEventListener('click', async ()=>{
      if(!state.image){ alert('Load an image first.'); return; }
      const sx = Math.round(state.image.width/2), sy = Math.round(state.image.height/2);
      if(segReady){
        startProgress();
        await requestSegMask('autoObjects', sx, sy, state.tol, state.aggr);
      } else {
        const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
        if(mask){
          state.selections.push({type:'mask', maskCanvas: mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr }, auto:true}});
          state.activeIndex = state.selections.length-1;
          editor.draw(); schedulePreviewRender(true); history.save();
        }
      }
    });
    dom.protectEraserBtn.addEventListener('click', ()=>setMode('protectEraser'));
    dom.removeEraserBtn.addEventListener('click', ()=>setMode('removeEraser'));
    dom.undoBtn.addEventListener('click', ()=>history.undo());
    dom.redoBtn.addEventListener('click', ()=>history.redo());
    dom.renderNowBtn.addEventListener('click', ()=>{
      startProgress(); preview.layout(); preview.render(); finishProgress(); renderPresets(true); log('Manual render complete.');
    });

    dom.resetViewBtn.addEventListener('click', ()=>{
      if(!state.image) return;
      focal.fit();
      editor.draw();
      log('View reset (fit).');
    });

    dom.downloadBtn.addEventListener('click', ()=>{
      if(!state.image){ alert('Load an image first.'); return; }
      // Full-resolution render (HQ) regardless of preview size
      const out = document.createElement('canvas');
      out.width = state.image.width; out.height = state.image.height;
      const octx = out.getContext('2d');

      const cssFilter = state.filters[state.activePreset].css(state.filtStrength);
      octx.save();
      // Canvas 2D doesn't accept CSS filter strings here; replicate via two-pass: draw BG with filter using an offscreen canvas
      // Approach: draw BG to temp then draw filtered onto output
      const bg = document.createElement('canvas'); bg.width=out.width; bg.height=out.height;
      const bgctx = bg.getContext('2d');
      // Simulate grayscale/contrast/brightness roughly with globalComposite? Simpler: use drawImage once; CSS filter isn't supported on context, but we already do filtered preview only.
      // For HQ export, we keep original BG (color) and composite colorized foreground using mask, achieving same "color splash" effect.
      // So: BG = filtered (grayscale etc) -> approximate with stack of operations:
      // We'll implement grayscale via per-pixel for accuracy.
      const bgData = (()=>{ const id=bgctx.createImageData(out.width,out.height); const tmpC=document.createElement('canvas'); tmpC.width=out.width; tmpC.height=out.height; tmpC.getContext('2d').drawImage(state.image,0,0); const src=tmpC.getContext('2d').getImageData(0,0,out.width,out.height).data; for(let i=0;i<src.length;i+=4){ const r=src[i],g=src[i+1],b=src[i+2]; const y=Math.round(0.2126*r+0.7152*g+0.0722*b); id.data[i]=y; id.data[i+1]=y; id.data[i+2]=y; id.data[i+3]=255; } return id; })();
      bgctx.putImageData(bgData,0,0);
      // (Optional: apply extra contrast/brightness based on chosen preset strength; kept simple to stay robust.)

      // Draw filtered background to output
      octx.drawImage(bg,0,0);

      // Foreground colorized region via mask
      const fullMask = buildFullMaskCanvas();
      const fg = document.createElement('canvas'); fg.width=out.width; fg.height=out.height;
      const fgctx = fg.getContext('2d');
      fgctx.drawImage(state.image,0,0);
      fgctx.globalCompositeOperation = 'destination-in';
      fgctx.drawImage(fullMask,0,0);
      octx.drawImage(fg,0,0);

      octx.restore();

      const url = out.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = `colorsplash-result-${Date.now()}.png`; a.click();
    });

    dom.startOverBtn.addEventListener('click', ()=>{
      if(!state.image) return;
      if(confirm('Clear the image and all selections?')){
        state.image=null; state.selections=[]; state.activeIndex=-1; state.history=[]; state.histIndex=-1;
        dom.editorEmpty.classList.remove('hidden'); dom.previewEmpty.classList.remove('hidden');
        editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width, editor.c.height);
        preview.ctx.clearRect(0,0,preview.c.width, preview.c.height);
        dom.monocle.style.display='none';
        renderPresets(); refreshButtons(); log('Project cleared.');
      }
    });

    dom.saveBtn.addEventListener('click', ()=>{
      if(!state.image) return;
      const payload = {
        app: 'Color Splash Pro X', version: APP_VERSION,
        imageDataURL: getCurrentImageDataURL(),
        selections: state.selections.map(s=>{
          const base = {...s};
          if((s.type==='mask' || s.type==='protect') && s.maskCanvas) base.maskCanvas = s.maskCanvas.toDataURL();
          return base;
        }),
        activePreset: state.activePreset,
        aggr: state.aggr, tol: state.tol, filtStrength: state.filtStrength
      };
      const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `colorsplash-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      log('Saved project JSON.');
    });

    dom.loadBtn.addEventListener('click', ()=>dom.loadInput.click());
    dom.loadInput.addEventListener('change', (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{
        try{ const obj = JSON.parse(r.result); loadFromObject(obj); log('Loaded project JSON.'); }
        catch(err){ alert('Invalid JSON file'); }
      };
      r.readAsText(f);
    });

    function loadFromObject(obj){
      const img = new Image();
      img.onload = ()=>{
        state.image = img;
        state.selections = (obj.selections||[]).map(s=>{
          if((s.type==='mask' || s.type==='protect') && s.maskCanvas && typeof s.maskCanvas==='string'){
            const cnv = dataURLToCanvas(s.maskCanvas);
            return {...s, maskCanvas: cnv};
          }
          return s;
        });
        state.activeIndex = -1;
        state.activePreset = obj.activePreset ?? 0;
        state.aggr = obj.aggr ?? 35;
        state.tol = obj.tol ?? 25;
        state.filtStrength = obj.filtStrength ?? 100;
        dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
        editor.updateSize(); preview.init(); focal.fit(); editor.draw(); renderPresets(true); updateSettingsUI();
        state.history=[]; state.histIndex=-1; history.save(); refreshButtons();
        schedulePreviewRender(true);
        dom.monocle.style.display='block';
        attachMonocle(dom.editorPanel);
        initSegWorker();
      };
      img.src = obj.imageDataURL;
    }

    // -------------------------- SETTINGS --------------------------
    dom.aggrRange.addEventListener('input', ()=>{
      state.aggr = parseInt(dom.aggrRange.value,10); updateSettingsUI();
      schedulePreviewRender(true);
    });

    dom.tolRange.addEventListener('input', ()=>{
      state.tol  = parseInt(dom.tolRange.value,10); updateSettingsUI();
      // Smart recompute for generated auto masks
      recomputeGeneratedMasks();
    });

    dom.fltRange.addEventListener('input', ()=>{
      state.filtStrength = parseInt(dom.fltRange.value,10); updateSettingsUI(); schedulePreviewRender(true);
    });

    function updateSettingsUI(){
      dom.aggrRange.value = state.aggr; dom.aggrVal.textContent = state.aggr;
      dom.tolRange.value  = state.tol;  dom.tolVal.textContent  = state.tol;
      dom.fltRange.value  = state.filtStrength; dom.fltVal.textContent = state.filtStrength+'%';
    }

    // Logs panel collapsed by default
    let logsVisible = false;
    const logsContainer = document.querySelector('.logs');
    const applyLogsVisibility = ()=>{ logsContainer.style.display = logsVisible ? 'block' : 'none'; };
    applyLogsVisibility();
    dom.toggleLogsBtn.addEventListener('click', ()=>{ logsVisible = !logsVisible; applyLogsVisibility(); });
    dom.clearLogsBtn.addEventListener('click', ()=>{ dom.logBody.innerHTML=''; });

    function setMode(m){
      state.mode = m;
      dom.modeLassoBtn.classList.toggle('active', m==='lasso');
      dom.modeBoxBtn.classList.toggle('active', m==='box');
      dom.autoWandBtn.classList.toggle('active', m==='autoWand');
      dom.autoSmartBtn.classList.toggle('active', m==='autoSmart');
      dom.autoUltraBtn.classList.toggle('active', m==='autoUltra');
      dom.protectEraserBtn.classList.toggle('active', m==='protectEraser');
      dom.removeEraserBtn.classList.toggle('active', m==='removeEraser');
      log('Mode:', m);
    }
    function refreshButtons(){
      dom.undoBtn.disabled = state.histIndex<=0;
      dom.redoBtn.disabled = state.histIndex>=state.history.length-1 || state.history.length===0;
      dom.deleteSelectionBtn.disabled = state.activeIndex===-1;
      dom.saveBtn.disabled = !state.image;
      dom.startOverBtn.disabled = !state.image;
    }

    function initEmpty(){
      editor.updateSize();
      editor.ctx.clearRect(0,0,editor.c.width, editor.c.height);
      preview.ctx.clearRect(0,0,preview.c.width, preview.c.height);
      renderPresets();
      updateSettingsUI();
      refreshButtons();
      log(`App ready. Version ${APP_VERSION}`);
      log('Tip: S=Lasso, B=Box, W=Auto Wand, G=Auto Smart, U=Auto Ultra, E=Protect Eraser, R=Remove Eraser. Space+Drag pan. Wheel zoom.');
    }
    preview.init();
    initEmpty();

    // -------------------------- SMART RECOMPUTE --------------------------
    async function recomputeGeneratedMasks(){
      if(!state.image){ return; }
      // Gather indices first; we‚Äôll append new masks and remove old to avoid flicker
      const targets = [];
      state.selections.forEach((s, idx)=>{
        if(s && s.type==='mask' && s.generator && s.generator.tool){
          const t = s.generator.tool;
          if(t==='edgeGrow' || t==='grabcutLite' || t==='magicWand'){ targets.push(idx); }
        }
      });
      if(targets.length===0){ schedulePreviewRender(true); return; }

      startProgress();
      // For each target: recompute with updated tolerance/aggr
      const newMasks = [];
      for(const idx of targets){
        const s = state.selections[idx];
        const g = s.generator || {};
        const sx = Math.round(g.seedX ?? (state.image.width/2));
        const sy = Math.round(g.seedY ?? (state.image.height/2));
        const tool = (g.tool==='edgeGrow') ? 'autoSmart'
                   : (g.tool==='grabcutLite') ? 'autoUltra'
                   : (g.tool==='magicWand') ? 'autoWand'
                   : 'autoSmart';

        if(tool==='autoWand'){
          const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
          if(mask) newMasks.push({i:idx, canvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol, aggr:state.aggr}}});
        } else if(segReady){
          // async worker path: we‚Äôll push when responses arrive ‚Äî but to keep ordering,
          // we‚Äôll compute serially by awaiting request + hooking onmessage already pushes.
          await requestSegMask(tool, sx, sy, state.tol, state.aggr);
          // Mark old one for removal after a short defer to allow worker to push the new one.
          newMasks.push({i:idx, replaceByWorker:true});
        } else {
          // fallback
          const fallback = (tool==='autoUltra')
            ? ultraMask(state.image, sx, sy, state.tol/100, state.aggr)
            : magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
          if(fallback) newMasks.push({i:idx, canvas:fallback, generator:{
            tool: tool==='autoUltra' ? 'grabcutLite' : 'edgeGrow',
            seedX:sx, seedY:sy, params:{tol:state.tol, aggr:state.aggr, fallback:true}
          }});
        }
      }

      // Replace old masks with newly computed canvases (for non-worker path)
      // For worker replacements, we delete the old now; the worker already appended a fresh one.
      // To maintain relative order, we‚Äôll just remove old ones and let the newest sit on top.
      // This avoids area mismatch/jump artifacts while scrubbing tolerance.
      const toDelete = [];
      for(const nm of newMasks){
        if(nm.replaceByWorker){
          toDelete.push(nm.i);
        } else {
          // replace in place
          const old = state.selections[nm.i];
          state.selections[nm.i] = {type:'mask', maskCanvas:nm.canvas, generator:nm.generator};
        }
      }
      // Remove any noted for deletion (delete higher indices first)
      toDelete.sort((a,b)=>b-a).forEach(i=> state.selections.splice(i,1));

      editor.draw();
      schedulePreviewRender(false);
      history.save();
      finishProgress();
      log('Recomputed', targets.length, 'generated mask(s) for new tolerance/aggr.');
    }

    // -------------------------- AUTO TOOLS (BUILT-IN FALLBACKS) --------------------------
    function magicWandMask(img, seedX, seedY, tol01, growStrength){
      const w = img.width, h = img.height;
      const maxSide = 1024;
      const scale = Math.min(1, maxSide / Math.max(w,h));
      const sw = Math.max(1, Math.round(w*scale));
      const sh = Math.max(1, Math.round(h*scale));

      const sC = document.createElement('canvas');
      sC.width = sw; sC.height = sh;
      const sX = sC.getContext('2d');
      sX.imageSmoothingEnabled = true;
      sX.drawImage(img, 0,0, sw, sh);

      const sx = clamp(Math.round(seedX*scale),0,sw-1);
      const sy = clamp(Math.round(seedY*scale),0,sh-1);

      const src = sX.getImageData(0,0,sw,sh);
      const data = src.data;
      const mask = new Uint8Array(sw*sh);

      const idx = (x,y)=> (y*sw + x);
      const pIdx = (x,y)=> idx(x,y)*4;

      const r0 = data[pIdx(sx,sy)+0], g0 = data[pIdx(sx,sy)+1], b0 = data[pIdx(sx,sy)+2];
      const thr = 8 + tol01*132;

      const stack = [[sx,sy]];
      mask[idx(sx,sy)] = 1;
      while(stack.length){
        const [x,y] = stack.pop();
        for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
          if(nx<0||ny<0||nx>=sw||ny>=sh) continue;
          const id = idx(nx,ny);
          if(mask[id]) continue;
          const p = pIdx(nx,ny);
          const dr = data[p]-r0, dg = data[p+1]-g0, db = data[p+2]-b0;
          const dist = Math.sqrt(dr*dr + dg*dg + db*db);
          if(dist<=thr){ mask[id]=1; stack.push([nx,ny]); }
        }
      }

      if(growStrength && growStrength>0){
        const iters = Math.round(clamp(growStrength,0,100) * 0.08);
        const nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        for(let k=0;k<iters;k++){
          const copy = mask.slice(0);
          for(let y=0;y<sh;y++){
            for(let x=0;x<sw;x++){
              if(copy[idx(x,y)]) continue;
              let on = 0;
              for(const [dx,dy] of nb){
                const xx=x+dx, yy=y+dy;
                if(xx>=0&&yy>=0&&xx<sw&&yy<sh && copy[idx(xx,yy)]){ on=1; break; }
              }
              if(on) mask[idx(x,y)] = 1;
            }
          }
        }
      }

      const mC = document.createElement('canvas');
      mC.width = w; mC.height = h;
      const mX = mC.getContext('2d');

      const mSmall = document.createElement('canvas');
      mSmall.width = sw; mSmall.height = sh;
      const msx = mSmall.getContext('2d');
      const imgMask = msx.createImageData(sw, sh);
      for(let i=0;i<sw*sh;i++){
        const v = mask[i] ? 255 : 0;
        imgMask.data[i*4+0] = 255; imgMask.data[i*4+1] = 255; imgMask.data[i*4+2] = 255; imgMask.data[i*4+3] = v;
      }
      msx.putImageData(imgMask, 0, 0);
      mX.imageSmoothingEnabled = false;
      mX.drawImage(mSmall, 0,0, sw,sh, 0,0, w,h);
      return mC;
    }

    function ultraMask(img, seedX, seedY, tol01, aggr){
      // Legacy "Ultra" flood: keep for fallback only
      return magicWandMask(img, seedX, seedY, Math.min(1, tol01*1.2+0.05), aggr+8);
    }

    function maskHit(maskCanvas, x, y){
      if(x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return false;
      const ctx = maskCanvas.getContext('2d');
      const d = ctx.getImageData(Math.floor(x), Math.floor(y), 1,1).data;
      return d[3] > 10;
    }

    function edgeFromMask(maskCanvas, r){
      const w = maskCanvas.width, h = maskCanvas.height;
      if(!w||!h) return null;
      const srcCtx = maskCanvas.getContext('2d');
      const src = srcCtx.getImageData(0,0,w,h);

      const eroded = document.createElement('canvas');
      eroded.width=w; eroded.height=h;
      const ex = eroded.getContext('2d');
      ex.filter = `blur(${Math.max(0.5,r)}px)`; ex.drawImage(maskCanvas,0,0); ex.filter = 'none';
      const eData = ex.getImageData(0,0,w,h);

      const edge = document.createElement('canvas');
      edge.width=w; edge.height=h;
      const out = edge.getContext('2d');
      const oData = out.createImageData(w,h);

      for(let i=0;i<oData.data.length;i+=4){
        const a = src.data[i+3], b = eData.data[i+3];
        const v = Math.max(0, a - b);
        oData.data[i+0]=0; oData.data[i+1]=0; oData.data[i+2]=0; oData.data[i+3]=v>8? 220:0;
      }
      out.putImageData(oData,0,0);
      return edge;
    }

    function reviveMaskInSnapshot(snap){
      if(snap && (snap.type==='mask' || snap.type==='protect') && snap.maskCanvas && typeof snap.maskCanvas==='string'){
        snap.maskCanvas = dataURLToCanvas(snap.maskCanvas);
      }
      return snap;
    }

    function dataURLToCanvas(url){
      const img = new Image();
      const cnv = document.createElement('canvas');
      img.onload = ()=>{ cnv.width = img.width; cnv.height = img.height; cnv.getContext('2d').drawImage(img,0,0); };
      img.src = url;
      return cnv;
    }

    function getCurrentImageDataURL(){
      if(!state.image) return '';
      if(typeof state.image.src === 'string' && state.image.src.startsWith('data:')) return state.image.src;
      const c = document.createElement('canvas'); c.width = state.image.width; c.height = state.image.height;
      const ctx = c.getContext('2d'); ctx.drawImage(state.image,0,0);
      return c.toDataURL('image/png');
    }

    // -------------------------- ERASERS --------------------------
    function ensureBrushLayer(kind){
      const idx = state.selections.findIndex(s=>s.type === (kind==='protect'?'protect':'mask'));
      if(idx>=0){ state.activeIndex = idx; return; }
      const cnv = document.createElement('canvas');
      cnv.width = state.image.width; cnv.height = state.image.height;
      state.selections.push({type: kind==='protect'?'protect':'mask', maskCanvas: cnv});
      state.activeIndex = state.selections.length-1;
    }

    let lastPaint = null;
    function paintOnActiveMask(x, y, fresh){
      const sel = state.selections[state.activeIndex];
      if(!sel || !sel.maskCanvas) return;
      const ctx = sel.maskCanvas.getContext('2d');
      const size = state.brush.size;
      const hard = state.brush.hard;
      const radius = size/2;

      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      const gx = ctx.createRadialGradient(x,y, radius*hard, x,y, radius);
      const color = (sel.type==='protect') ? 'rgba(255,0,0,1)' : 'rgba(255,255,255,1)';
      gx.addColorStop(0, color);
      gx.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gx;

      if(fresh || !lastPaint){
        ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
      } else {
        const dx = x - lastPaint.x, dy = y - lastPaint.y;
        const steps = Math.max(1, Math.ceil(Math.hypot(dx,dy) / (radius*0.5)));
        for(let i=1;i<=steps;i++){
          const t = i/steps;
          const px = lastPaint.x + dx*t, py = lastPaint.y + dy*t;
          ctx.beginPath(); ctx.arc(px,py,radius,0,Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();
      lastPaint = {x,y};
    }

    // -------------------------- MONOCLE (reusable) --------------------------
    function attachMonocle(panel){
      if(!dom.monocle) return;
      panel.querySelector('.panel-c').appendChild(dom.monocle);
    }
    function updateMonocle(e, where){
      if(!state.image) return;
      const mCtx = dom.monocleCanvas.getContext('2d');
      if(dom.monocleCanvas.width === 0 || dom.monocleCanvas.height === 0){
        dom.monocleCanvas.width=148; dom.monocleCanvas.height=148;
      }

      let cx, cy, rect;
      if(where==='editor'){
        rect = dom.editorCanvas.getBoundingClientRect();
        cx = (e.clientX - rect.left - state.transform.x)/state.transform.scale;
        cy = (e.clientY - rect.top  - state.transform.y)/state.transform.scale;
      }else{
        rect = dom.previewCanvas.getBoundingClientRect();
        const scaleX = state.image.width / Math.max(1, dom.previewCanvas.width);
        const scaleY = state.image.height / Math.max(1, dom.previewCanvas.height);
        cx = (e.clientX - rect.left) * scaleX;
        cy = (e.clientY - rect.top ) * scaleY;
      }
      cx = clamp(cx, 0, state.image.width-1);
      cy = clamp(cy, 0, state.image.height-1);

      const box = 64;
      const sx = Math.floor(clamp(cx - box/2, 0, state.image.width - box));
      const sy = Math.floor(clamp(cy - box/2, 0, state.image.height - box));

      mCtx.imageSmoothingEnabled = false;
      mCtx.clearRect(0,0,dom.monocleCanvas.width,dom.monocleCanvas.height);
      mCtx.drawImage(state.image, sx, sy, box, box, 0, 0, dom.monocleCanvas.width, dom.monocleCanvas.height);

      const fx = ((cx - sx) / box) * dom.monocleCanvas.width;
      const fy = ((cy - sy) / box) * dom.monocleCanvas.height;
      mCtx.strokeStyle = '#0a46ff';
      mCtx.lineWidth = 1;
      mCtx.beginPath();
      mCtx.moveTo(fx, 0); mCtx.lineTo(fx, dom.monocleCanvas.height);
      mCtx.moveTo(0, fy); mCtx.lineTo(dom.monocleCanvas.width, fy);
      mCtx.stroke();

      dom.monocle.style.display = 'block';
    }

    // -------------------------- INIT --------------------------
    function initAfterImage(){ /* reserved in case we need post-load hooks */ }

  })();
  </script>
</body>
</html>
