<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Color Splash Pro X ‚Äî AI Mode</title>

<!--
================================================================================
TECHNICAL SPECIFICATION SHEET (v1.20.0 ‚ÄúAI Suggestions + Robust Model Fetch‚Äù)
This build PRESERVES all previous features and ADDS:

UI / Layout
- Two main canvases side-by-side (Original left, Preview right).
- When AI Mode is ON:
  ‚Ä¢ Top toolbar auto-switches to AI controls (manual groups hidden, not removed).
  ‚Ä¢ Under the LEFT (Original) panel: 5 clickable AI suggestion thumbnails.
  ‚Ä¢ Under the RIGHT (Preview) panel: 2 AI output thumbnails (Object Mask + Depth Map).
  ‚Ä¢ Optional text prompt + seed coordinate inputs in AI controls.
- Bottom-left pinned chat-circle opens a scrollable panel with AI logs & settings.

AI Pipeline
- Click Original to set seed -> run Segmentation + Depth -> show AI outputs ->
  compute 5 mask variations (‚ÄúFancy Math‚Äù banding, erode/dilate/edge-refine) ->
  click a suggestion to apply it at full quality in Preview.
- ‚ÄúUse‚Äù button also runs pipeline (if MobileSAM selected & no click, waits for click).

Robust Model Loading
- Multiple mirrors per model (HuggingFace / raw GitHub / jsDelivr). If one fails,
  we try the next. We fetch as ArrayBuffer and create ORT sessions from bytes.
- WebGPU provider preferred; auto-fallback to WASM.

Failsafes
- If all seg models fail => fallback to EdgeGrow worker (still AI flow continues).
- If depth fails => continue with segmentation-only suggestions (some variants skip depth).
- Timeouts, try/catch, progress + user logs, never blocks the UI thread unnecessarily.

App version bump: APP_VERSION = "1.20.0"
================================================================================
-->

  <style>
    :root{
      --bg:#edf1f7;--panel:#fff;--text:#1c1e21;--muted:#606770;--primary:#1877f2;--primary-2:#166fe5;
      --border:#d7dbe1;--shadow:rgba(0,0,0,.08);--shadow-2:rgba(0,0,0,.14);
      --danger:#fa383e;--ok:#19a974;--warn:#ffb700;--chip:#f4f7ff;
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;overflow:hidden;
    }
    header{
      background:var(--panel);box-shadow:0 2px 6px var(--shadow);padding:.55rem .8rem;display:flex;align-items:center;gap:.5rem;z-index:4;
      position:relative;
    }
    .brand{font-weight:800;color:var(--primary);letter-spacing:.2px}
    .badge{margin-left:auto;font-size:.8rem;color:#4a4f57;background:#eef3ff;border:1px solid #dfe7ff;padding:.2rem .5rem;border-radius:6px}
    .toolbar{display:flex;flex-wrap:wrap;gap:.4rem;align-items:center}
    .group{display:flex;gap:.4rem;align-items:center}
    .hide-on-ai{display:flex}
    .show-on-ai{display:none}
    .ai-on .hide-on-ai{display:none}
    .ai-on .show-on-ai{display:flex}

    button{
      padding:.42rem .7rem;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:default;
      font-weight:600;font-size:.9rem;display:inline-flex;gap:.42rem;align-items:center;box-shadow:0 1px 0 rgba(0,0,0,.02);
      transition:transform .05s ease, border-color .2s, background .2s, color .2s;
    }
    button:hover:not(:disabled){border-color:var(--primary);background:#f6faff}
    button:active{transform:translateY(1px)}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    button.primary:hover{background:var(--primary-2);color:#fff}
    button.active{background:var(--primary);border-color:var(--primary);color:#fff}
    button.danger{border-color:#ffd2d6;background:#fff0f1;color:#b00020}
    button:disabled{opacity:.6;cursor:not-allowed}
    .icon{font-size:1.05rem}

    /* ====== Layout ====== */
    .shell{flex:1;display:flex;flex-direction:column;gap:10px;padding:10px;overflow:hidden}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;flex:1 1 auto;min-height:0}
    .panel{
      background:var(--panel);border-radius:12px;box-shadow:0 2px 8px var(--shadow);
      display:flex;flex-direction:column;min-height:0;overflow:hidden;position:relative;
    }
    .panel-h{
      padding:.5rem .75rem;border-bottom:1px solid var(--border);font-weight:700;color:var(--muted);
      display:flex;align-items:center;justify-content:center;gap:.5rem
    }
    .panel-c{flex:1;min-height:0;position:relative;background:#e9eef6;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .placeholder{color:var(--muted);font-weight:600;opacity:.85;pointer-events:none}
    .canvas-wrap{
      position:relative;width:100%;height:100%;overflow:hidden;
      display:flex;align-items:center;justify-content:center;cursor:default;
    }
    .canvas-wrap.panning{cursor:grabbing}
    .canvas-wrap.drop-hover{outline:3px dashed var(--primary); outline-offset:-8px; background:rgba(24,119,242,0.1)}
    canvas{display:block;background:#fff}
    #editor-canvas{position:absolute;transform-origin:top left}
    #preview-canvas{position:absolute;top:0;left:0}

    /* Monocles */
    .monocle{
      position:absolute;width:148px;height:148px;background:#fff;border:2px solid var(--border);
      border-radius:10px;box-shadow:0 6px 14px var(--shadow-2);overflow:hidden;display:none;z-index:3;
    }
    .monocle canvas{width:100%;height:100%;display:block;background:#000}
    #monocle-left{ top:10px; left:10px; }
    #monocle-right{ top:10px; right:10px; }

    /* Bottom area (Manual mode) */
    .bottom{display:grid;grid-template-columns:8fr 3fr;gap:10px;min-height:92px;max-height:26vh}
    .presets.panel{min-height:92px}
    .presets-grid{display:grid;grid-template-columns:repeat(10,1fr);gap:8px;padding:10px;align-items:end;justify-items:center}
    .preset{cursor:pointer;text-align:center;width:100%;max-width:84px;margin:0 auto}
    .preset canvas{
      width:100%;height:auto;aspect-ratio:16/9;background:#f3f5f9;border-radius:10px;border:2px solid transparent;
      box-shadow:0 1px 3px var(--shadow);transition:all .15s
    }
    .preset:hover canvas{transform:translateY(-2px)}
    .preset.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .preset label{display:block;margin-top:4px;font-size:.72rem;color:var(--muted);text-align:center}

    .side.panel{min-height:92px}
    .side-c{display:grid;grid-template-rows:auto 1fr}
    .settings{padding:8px 10px;border-bottom:1px solid var(--border)}
    .set-row{display:flex;align-items:center;gap:10px;margin:.28rem 0}
    .set-row input[type=range]{flex-grow:1}
    .logs{position:relative; display:none;}
    .log-header{display:flex;align-items:center;justify-content:space-between;padding:6px 10px;border-bottom:1px solid var(--border);background:#fafbff}
    .log-body{height:100%;max-height:18vh;padding:10px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.8rem;background:#fff}

    /* Progress */
    .progress-wrap{position:absolute;left:12px;right:12px;bottom:12px;height:8px;border-radius:6px;background:#eef2ff;border:1px solid #dde6ff;overflow:hidden; opacity:0; transition: opacity 0.2s; pointer-events:none;}
    .progress-wrap.visible{opacity:1;}
    .progress{height:100%;width:0%;background:linear-gradient(90deg,#7aa2ff,#1877f2);transition:width .1s}

    .version-pin{position:fixed;top:8px;right:8px;background:#101828;color:#fff;font-size:.75rem;padding:.25rem .5rem;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.18);z-index:10;opacity:.9}

    /* AI Controls bar (shows when AI mode active) */
    .ai-bar{position:absolute;left:0;right:0;bottom:-52px;background:#fff;border-top:1px solid var(--border);display:none;gap:.6rem;align-items:center;padding:.45rem .8rem;z-index:3;}
    .ai-bar.visible{display:flex}
    .chip{padding:.28rem .5rem;border:1px solid var(--border);border-radius:999px;background:var(--chip);font-size:.82rem;color:#334155}
    .ai-bar select, .ai-bar input[type="text"], .ai-bar input[type="number"]{padding:.32rem .5rem;border:1px solid var(--border);border-radius:8px;background:#fff;font-weight:600}
    .ai-bar .rowline{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
    .ai-bar .spacer{flex:1}
    .switch{display:inline-flex;gap:.4rem;align-items:center;padding:.2rem .4rem;border:1px solid var(--border);border-radius:8px;background:#fff}

    /* AI bottom row (shows when AI mode active) */
    .ai-bottom{display:none;grid-template-columns:1fr 1fr;gap:10px;min-height:120px;max-height:28vh}
    .ai-on .ai-bottom{display:grid}
    .ai-suggestions{padding:8px;display:grid;grid-template-columns:repeat(5,1fr);gap:8px;align-items:end;justify-items:center}
    .ai-suggestion{cursor:pointer;text-align:center;width:100%;max-width:120px;margin:0 auto}
    .ai-suggestion canvas{width:100%;height:auto;aspect-ratio:16/10;background:#f3f5f9;border-radius:10px;border:2px solid transparent;box-shadow:0 1px 3px var(--shadow);transition:all .15s}
    .ai-suggestion:hover canvas{transform:translateY(-2px)}
    .ai-suggestion.active canvas{border-color:var(--primary);box-shadow:0 6px 14px var(--shadow-2)}
    .ai-suggestion label{display:block;margin-top:4px;font-size:.72rem;color:#475569}

    /* AI outputs under preview (right side of AI bottom) */
    .ai-outputs-box{padding:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .ai-plot{display:flex;flex-direction:column;align-items:center;gap:4px}
    .ai-plot canvas{width:100%;height:auto;max-height:120px;background:#f1f3f8;border-radius:10px;border:1px solid var(--border);image-rendering:pixelated}
    .ai-plot .cap{font-size:.75rem;color:#475569}

    /* AI FAB + Panel */
    #aiFab{position:fixed;left:12px;bottom:12px;z-index:8;border-radius:999px;padding:.6rem .75rem;background:#1877f2;color:#fff;border:none;box-shadow:0 6px 14px rgba(0,0,0,.18);cursor:pointer;font-weight:800}
    #aiPanel{position:fixed;left:12px;bottom:64px;width:360px;height:56vh;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 12px 32px rgba(0,0,0,.18);display:none;flex-direction:column;overflow:hidden;z-index:9}
    #aiPanel.visible{display:flex}
    #aiPanel header{box-shadow:none;padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #aiPanel .body{flex:1;display:grid;grid-template-rows:auto 1fr}
    #aiPanel .cfg{padding:.5rem .75rem;border-bottom:1px solid var(--border)}
    #aiPanel .cfg .row{display:flex;gap:.5rem;align-items:center;margin:.25rem 0;flex-wrap:wrap}
    #aiPanel .ilog{overflow:auto;background:#fff;padding:.25rem .5rem}
    #aiPanel .ilog .line{font-family:ui-monospace,monospace;font-size:.82rem;color:#1f2937;padding:.25rem 0;border-bottom:1px dashed #eef2ff;white-space:pre-wrap}

    .hidden{display:none!important}
  </style>

  <!-- ONNX Runtime Web (WebGPU + WASM) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <header id="topbar">
    <div class="brand">Color Splash Pro X</div>

    <!-- Manual toolbar (hidden when AI mode ON) -->
    <div class="toolbar hide-on-ai">
      <div class="group">
        <button id="uploadBtn" class="primary"><span class="icon">üì§</span>Upload</button>
        <button id="saveBtn" title="Save project JSON" disabled>üíæ Save</button>
        <button id="loadBtn" title="Load project JSON">üìÇ Load</button>
        <button id="startOverBtn" class="danger" title="Clear image & selections" disabled>üßπ Start Over</button>
      </div>
      <div class="group">
        <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>‚Ü©Ô∏è Undo</button>
        <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>‚Ü™Ô∏è Redo</button>
      </div>
      <div class="group">
        <button id="modeLassoBtn" class="active" title="Smart Select (Lasso) (S)">‚ú® Lasso</button>
        <button id="newLassoBtn" title="Add new lasso object">‚ûï New Lasso</button>
        <button id="modeBoxBtn" title="Box Select (B)">üî≤ Box</button>
        <button id="deleteSelectionBtn" title="Delete active selection (Del)" disabled>üóëÔ∏è Delete</button>
      </div>
      <div class="group">
        <button id="autoWandBtn" title="Auto Wand (W)">ü™Ñ Auto Wand</button>
        <button id="autoSmartBtn" title="Auto Smart (G)">üß† Auto Smart</button>
        <button id="autoUltraBtn" title="Auto Ultra (U)">üß¨ Auto Ultra</button>
        <button id="autoObjectsBtn" title="Auto Objects (demo)">üõ∞Ô∏è Auto Objects</button>
      </div>
      <div class="group">
        <button id="protectEraserBtn" title="Paint protected areas (E)">üõ°Ô∏è Protect Eraser</button>
        <button id="removeEraserBtn" title="Erase colorized mask (R)">üßΩ Remove Eraser</button>
      </div>
      <div class="group">
        <button id="resetViewBtn" title="Reset pan/zoom & fit">üéØ Reset View</button>
        <button id="renderNowBtn" title="Render immediately">‚ö° Render Now</button>
        <button id="downloadBtn" title="Download final image (PNG)">‚¨áÔ∏è Download</button>
      </div>
    </div>

    <!-- AI toolbar (visible when AI mode ON) -->
    <div class="toolbar show-on-ai" style="width:100%">
      <div class="group">
        <button id="uploadBtn2" class="primary"><span class="icon">üì§</span>Upload</button>
        <button id="saveBtn2" title="Save project JSON" disabled>üíæ Save</button>
        <button id="loadBtn2" title="Load project JSON">üìÇ Load</button>
        <button id="startOverBtn2" class="danger" title="Clear image & selections" disabled>üßπ Start Over</button>
      </div>
      <div class="group">
        <span class="chip">Seg:</span>
        <select id="aiSegModel">
          <option value="yolov8n-seg">YOLOv8n-seg (~13MB)</option>
          <option value="yolo11n-seg">YOLO11n-seg (~6MB)</option>
          <option value="mobile-sam">MobileSAM (promptable, ~50MB)</option>
        </select>

        <span class="chip">Depth:</span>
        <select id="aiDepthModel">
          <option value="mobiledepth">MobileDepth Tiny (~1.4MB)</option>
          <option value="midas-small">MiDaS small (~63MB)</option>
          <option value="da-v2-small">Depth Anything V2 Small (~99MB)</option>
        </select>

        <span class="chip">Prompt:</span>
        <input id="aiPrompt" type="text" placeholder="optional (e.g., ‚Äòperson‚Äô, ‚Äòcar‚Äô)"/>

        <span class="chip">Seed x:</span><input id="seedX" type="number" min="0" step="1" style="width:80px"/>
        <span class="chip">y:</span><input id="seedY" type="number" min="0" step="1" style="width:80px"/>

        <span class="switch"><input id="aiRefine" type="checkbox"/><label for="aiRefine">Fancy Math</label></span>

        <button id="aiUseBtn" class="primary">üöÄ Use</button>
      </div>
      <div class="group" style="margin-left:auto">
        <span id="aiRuntimeChip" class="chip">‚Äî</span>
        <span id="aiStatus" class="chip">AI idle</span>
      </div>
    </div>

    <span class="badge" id="versionBadge">v?</span>

    <!-- AI BAR band (sheet under header) -->
    <div id="aiBar" class="ai-bar">
      <div class="rowline">
        <span class="chip">AI Mode</span>
        <span class="switch"><input id="aiSwitch" type="checkbox"/><label for="aiSwitch">ON / OFF</label></span>
        <small style="color:#64748b">Tip: Click the object in the Original panel to seed.</small>
        <div class="spacer"></div>
        <small style="color:#64748b">WebGPU preferred ¬∑ WASM fallback</small>
      </div>
    </div>
  </header>

  <div class="version-pin" id="versionPin">v?</div>

  <div id="appRoot" class="shell">
    <div class="row">
      <!-- EDITOR -->
      <section class="panel" id="editor-panel">
        <div class="panel-h">ORIGINAL ‚Äî click to set seed (Space = Pan ¬∑ Wheel = Zoom)</div>
        <div class="panel-c">
          <div id="editor-wrap" class="canvas-wrap">
            <canvas id="editor-canvas"></canvas>
            <div id="monocle-left" class="monocle"><canvas id="monocle-left-canvas"></canvas></div>
          </div>
          <div id="editor-empty" class="placeholder">Drop an image here or click ‚ÄúUpload‚Äù</div>
          <div class="progress-wrap" id="progressEditor"><div class="progress" id="progressBar"></div></div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel" id="preview-panel">
        <div class="panel-h">PREVIEW</div>
        <div class="panel-c" id="preview-container">
          <div id="preview-wrap" class="canvas-wrap">
            <canvas id="preview-canvas"></canvas>
            <div id="monocle-right" class="monocle"><canvas id="monocle-right-canvas"></canvas></div>
          </div>
          <div id="preview-empty" class="placeholder">Your result will appear here</div>
        </div>
      </section>
    </div>

    <!-- Manual mode bottom strip (presets + settings/logs) -->
    <div class="bottom" id="manualBottom">
      <section class="presets panel">
        <div class="panel-h">PRESET GALLERY (click to apply)</div>
        <div id="presets" class="presets-grid"></div>
      </section>

      <section class="side panel">
        <div class="side-c">
          <div class="settings">
            <div class="set-row">
              <strong>Settings</strong>
              <button id="toggleLogsBtn" style="margin-left:auto">üìù Toggle Logs</button>
            </div>
            <div class="set-row">
              <label for="aggrRange">Feather</label>
              <input type="range" id="aggrRange" min="0" max="100" value="35"/>
              <span id="aggrVal">35</span>
            </div>
            <div class="set-row">
              <label for="tolRange">Tolerance (Auto tools)</label>
              <input type="range" id="tolRange" min="0" max="100" value="25"/>
              <span id="tolVal">25</span>
            </div>
            <div class="set-row">
              <label for="fltRange">Filter Strength</label>
              <input type="range" id="fltRange" min="0" max="100" value="100"/>
              <span id="fltVal">100%</span>
            </div>
          </div>
          <div class="logs" id="manualLogs">
            <div class="log-header">
              <div><strong>Developer Log</strong></div>
              <div><button id="clearLogsBtn">Clear</button></div>
            </div>
            <div id="logBody" class="log-body"></div>
          </div>
        </div>
      </section>
    </div>

    <!-- AI mode bottom strip (left: 5 suggestions ¬∑ right: 2 AI outputs) -->
    <div class="ai-bottom" id="aiBottom">
      <section class="panel">
        <div class="panel-h">AI SUGGESTIONS ‚Äî click to apply</div>
        <div id="aiSuggestions" class="ai-suggestions">
          <!-- 5 items inserted dynamically -->
        </div>
      </section>
      <section class="panel">
        <div class="panel-h">AI OUTPUTS ‚Äî Object Mask & Depth Map</div>
        <div class="ai-outputs-box">
          <div class="ai-plot">
            <canvas id="aiMaskThumb"></canvas>
            <div class="cap">AI Object Mask</div>
          </div>
          <div class="ai-plot">
            <canvas id="aiDepthThumb"></canvas>
            <div class="cap">Depth Map</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- FAB + AI Settings/Logs panel -->
  <button id="aiFab" title="AI Logs & Settings">üí¨ AI</button>
  <div id="aiPanel">
    <header><strong>ü§ñ AI Logs & Settings</strong></header>
    <div class="body">
      <div class="cfg">
        <div class="row">
          <span class="chip">Runtime</span>
          <span id="aiRuntimeChip2" class="chip">‚Äî</span>
        </div>
        <div class="row">
          <label>Fancy Math</label>
          <input id="aiRefine2" type="checkbox"/>
        </div>
        <div class="row">
          <label>Prompt (optional)</label>
          <input id="aiPrompt2" type="text" placeholder="e.g., ‚Äòperson‚Äô, ‚Äòcar‚Äô" style="flex:1"/>
        </div>
        <div class="row">
          <label>Seed X</label><input id="seedX2" type="number" min="0" step="1" style="width:100px"/>
          <label>Y</label><input id="seedY2" type="number" min="0" step="1" style="width:100px"/>
        </div>
        <div class="row">
          <small style="color:#64748b">Select models in the AI toolbar; we preload them with mirror fallbacks.</small>
        </div>
      </div>
      <div id="aiLogBody" class="ilog"></div>
    </div>
  </div>

  <!-- hidden inputs -->
  <input type="file" id="fileInput" accept="image/*" class="hidden"/>
  <input type="file" id="loadInput" accept=".json,.txt" class="hidden"/>

  <!-- Worker source (unchanged core; still used for fallbacks/refine) -->
  <script id="seg-worker-src" type="text/plain">
/* seg-worker.js ‚Äî minimal, fast, and deterministic */
self.postMessage({type:'ready'});
self.onmessage = (e)=>{
  const {type, payload, reqId} = e.data || {};
  if(type!=='segment') return;
  try{
    const {tool, seedX, seedY, tol01, aggr, width, height, image} = payload;
    const data = image.data;
    const N = width*height;
    const gray = new Float32Array(N);
    for(let i=0,j=0;i<N;i++,j+=4){ gray[i] = 0.2126*data[j] + 0.7152*data[j+1] + 0.0722*data[j+2]; }
    const grad = sobelMag(gray, width, height);
    const gradN = normalize01(grad);
    let alpha;
    if(tool==='autoUltra'){
      const params = defaultsEdgeGrow(Math.min(1, tol01*1.2+0.05), aggr+8);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      paintDisk(alpha, width, height, seedX, seedY, Math.max(6, Math.round(Math.min(width,height)*0.01)), 255);
      returnMask(alpha, width, height, {tool:'grabcutLite', seedX, seedY, params}, reqId);
    } else {
      const params = defaultsEdgeGrow(tol01, aggr);
      alpha = edgeAwareGrowMask(data, width, height, seedX, seedY, gradN, params);
      returnMask(alpha, width, height, {tool:'edgeGrow', seedX, seedY, params}, reqId);
    }
  }catch(err){
    self.postMessage({type:'error', reqId, payload:String(err)});
  }
};
function normalize01(arr){let mn=Infinity,mx=-Infinity;for(const v of arr){if(v<mn)mn=v;if(v>mx)mx=v;}
  const out=new Float32Array(arr.length);const d=mx-mn||1;for(let i=0;i<arr.length;i++) out[i]=(arr[i]-mn)/d;return out;}
function sobelMag(gray,W,H){
  const out=new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const i=y*W+x;
      const tl=(y-1)*W+(x-1), t=(y-1)*W+x, tr=(y-1)*W+(x+1);
      const ml=y*W+(x-1), mr=y*W+(x+1);
      const bl=(y+1)*W+(x-1), b=(y+1)*W+x, br=(y+1)*W+(x+1);
      const gx = -gray[tl]-2*gray[ml]-gray[bl] + gray[tr]+2*gray[mr]+gray[br];
      const gy = -gray[tl]-2*gray[t]-gray[tr] + gray[bl]+2*gray[b]+gray[br];
      out[i] = Math.hypot(gx,gy);
    }
  }
  return out;
}
function defaultsEdgeGrow(tol01, aggr){
  return { wc: 1.0, we: 2.0 + 1.2*tol01, wd: 0.02, tau: 18 + 160*tol01 + aggr*0.6, diag: true };
}
function edgeAwareGrowMask(rgbU8, W, H, sx, sy, grad01, p){
  const idx = (x,y)=> y*W + x;
  const N = W*H; const cost = new Float32Array(N); cost.fill(1e20);
  const seen = new Uint8Array(N);
  const heapCost = new Float32Array(N); const heapIdx = new Int32Array(N); let heapSize=0;
  function swap(a,b){ const tc=heapCost[a]; heapCost[a]=heapCost[b]; heapCost[b]=tc; const ti=heapIdx[a]; heapIdx[a]=heapIdx[b]; heapIdx[b]=ti; }
  function down(k){for(;;){let l=k*2+1,r=l+1,s=k;if(l<heapSize&&heapCost[l]<heapCost[s])s=l;if(r<heapSize&&heapCost[r]<heapCost[s])s=r;if(s===k)break;swap(k,s);k=s;}}
  function heapPush(c,i){let k=heapSize++;heapCost[k]=c;heapIdx[k]=i;while(k){const p=(k-1)>>1;if(heapCost[p]<=c)break;swap(k,p);k=p;}}
  function heapPop(){if(!heapSize)return[-1,-1];const c=heapCost[0],i=heapIdx[0];const ck=heapCost[--heapSize],ik=heapIdx[heapSize];
    if(heapSize){heapCost[0]=ck;heapIdx[0]=ik;down(0);}return[c,i];}
  const R=new Float32Array(N),G=new Float32Array(N),B=new Float32Array(N);
  for(let i=0,j=0;i<N;i++,j+=4){R[i]=rgbU8[j];G[i]=rgbU8[j+1];B[i]=rgbU8[j+2];}
  const seed = idx(Math.max(0,Math.min(W-1,sx)), Math.max(0,Math.min(H-1,sy)));
  cost[seed]=0; heapPush(0, seed);
  const deltas = p.diag ? [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]] : [[1,0],[-1,0],[0,1],[0,-1]];
  while(heapSize){
    const [c,i]=heapPop(); if(i<0) break; if(seen[i]) continue; seen[i]=1; if(c>p.tau) break;
    const x=i%W, y=(i-x)/W;
    for(const d of deltas){
      const nx=x+d[0], ny=y+d[1]; if(nx<0||ny<0||nx>=W||ny>=H) continue;
      const j=ny*W+nx; if(seen[j]) continue;
      const dR = R[i]-R[j], dG = G[i]-G[j], dB = B[i]-B[j];
      const dE = Math.hypot(dR,dG,dB);
      const eStop = 1.0 - (grad01[j]/(grad01[j]+1e-6));
      const step = 1.0*dE + (2.0+1.2)*eStop + 0.02*((d[0]&&d[1])?Math.SQRT2:1.0);
      const nc = c + step;
      if(nc < cost[j] && nc <= p.tau){ cost[j]=nc; heapPush(nc,j); }
    }
  }
  const alpha = new Uint8ClampedArray(N);
  const t0 = 0.92*p.tau, t1 = p.tau;
  for(let i=0;i<N;i++){
    const ci = cost[i];
    if(ci>=1e18){ alpha[i]=0; continue; }
    if(ci<=t0){ alpha[i]=255; }
    else if(ci>=t1){ alpha[i]=0; }
    else { const a = 1 - (ci - t0)/(t1 - t0); alpha[i] = Math.round(255*a); }
  }
  return alpha;
}
function paintDisk(alpha, W,H, cx,cy, r, v){
  const r2=r*r;
  for(let y=Math.max(0,cy-r); y<Math.min(H,cy+r+1); y++){
    for(let x=Math.max(0,cx-r); x<Math.min(W,cx+r+1); x++){
      const dx=x-cx, dy=y-cy; if(dx*dx+dy*dy<=r2){ alpha[y*W+x]=v; }
    }
  }
}
function returnMask(alphaU8, width, height, generator, reqId){
  const cnv = new OffscreenCanvas(width,height); const ctx = cnv.getContext('2d');
  const id = ctx.createImageData(width, height);
  for(let i=0,j=0;i<id.data.length;i+=4,j++){
    id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=alphaU8[j];
  }
  ctx.putImageData(id,0,0);
  self.postMessage({type:'mask', reqId, payload:{width,height,alphaU8:null,generator, bitmap:cnv.transferToImageBitmap()}});
}
  </script>

  <script>
  (function(){
    'use strict';

    // -------------------------- META / VERSION --------------------------
    const APP_VERSION = "1.20.0";
    document.getElementById('versionBadge').textContent = APP_VERSION;
    document.getElementById('versionPin').textContent = APP_VERSION;

    // -------------------------- DOM --------------------------
    const $ = (id)=>document.getElementById(id);
    const dom = {
      // Manual toolbar
      uploadBtn: $('uploadBtn'), saveBtn: $('saveBtn'), loadBtn: $('loadBtn'), startOverBtn: $('startOverBtn'),
      undoBtn: $('undoBtn'), redoBtn: $('redoBtn'),
      modeLassoBtn: $('modeLassoBtn'), newLassoBtn: $('newLassoBtn'), modeBoxBtn: $('modeBoxBtn'),
      deleteSelectionBtn: $('deleteSelectionBtn'),
      autoWandBtn: $('autoWandBtn'), autoSmartBtn: $('autoSmartBtn'), autoUltraBtn: $('autoUltraBtn'), autoObjectsBtn: $('autoObjectsBtn'),
      protectEraserBtn: $('protectEraserBtn'), removeEraserBtn: $('removeEraserBtn'),
      resetViewBtn: $('resetViewBtn'), renderNowBtn: $('renderNowBtn'), downloadBtn: $('downloadBtn'),

      // AI toolbar
      uploadBtn2: $('uploadBtn2'), saveBtn2: $('saveBtn2'), loadBtn2: $('loadBtn2'), startOverBtn2: $('startOverBtn2'),
      aiSegModel: $('aiSegModel'), aiDepthModel: $('aiDepthModel'),
      aiRefine: $('aiRefine'), aiUseBtn: $('aiUseBtn'), aiStatus: $('aiStatus'),
      aiPrompt: $('aiPrompt'), seedX: $('seedX'), seedY: $('seedY'),
      aiRuntimeChip: $('aiRuntimeChip'), aiBar: $('aiBar'), aiSwitch: $('aiSwitch'),

      // Editor/Preview
      fileInput: $('fileInput'), loadInput: $('loadInput'),
      editorPanel: $('editor-panel'), editorWrap: $('editor-wrap'), editorCanvas: $('editor-canvas'), editorEmpty: $('editor-empty'),
      previewPanel: $('preview-panel'), previewWrap: $('preview-wrap'), previewContainer: $('preview-container'), previewCanvas: $('preview-canvas'), previewEmpty: $('preview-empty'),

      // Monocles
      monocleLeft: $('monocle-left'), monoLeftCanvas: $('monocle-left-canvas'),
      monocleRight: $('monocle-right'), monoRightCanvas: $('monocle-right-canvas'),

      // Bottom (manual)
      manualBottom: $('manualBottom'), presets: $('presets'),
      aggrRange: $('aggrRange'), aggrVal: $('aggrVal'),
      tolRange: $('tolRange'), tolVal: $('tolVal'),
      fltRange: $('fltRange'), fltVal: $('fltVal'),
      toggleLogsBtn: $('toggleLogsBtn'), clearLogsBtn: $('clearLogsBtn'), logBody: $('logBody'), manualLogs: $('manualLogs'),

      // AI Bottom
      aiBottom: $('aiBottom'), aiSuggestions: $('aiSuggestions'),
      aiMaskThumb: $('aiMaskThumb'), aiDepthThumb: $('aiDepthThumb'),

      // FAB panel
      aiFab: $('aiFab'), aiPanel: $('aiPanel'), aiLogBody: $('aiLogBody'), aiRuntimeChip2: $('aiRuntimeChip2'),
      aiRefine2: $('aiRefine2'), aiPrompt2: $('aiPrompt2'), seedX2: $('seedX2'), seedY2: $('seedY2'),

      // Misc
      topbar: $('topbar'), appRoot: $('appRoot'),
      progressWrap: $('progressEditor'), progressBar: $('progressBar')
    };

    // -------------------------- UTIL / LOGGING --------------------------
    const log = (...args)=> {
      const t = `[${new Date().toLocaleTimeString()}] ` + args.join(' ');
      const line = document.createElement('div'); line.className='log-line'; line.textContent = t;
      dom.logBody.appendChild(line); dom.logBody.scrollTop = dom.logBody.scrollHeight;

      const l2 = document.createElement('div'); l2.className='line'; l2.textContent = t;
      dom.aiLogBody.appendChild(l2); dom.aiLogBody.scrollTop = dom.aiLogBody.scrollHeight;

      // console also (dev)
      try{ console.log(...args);}catch{}
    };
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), ms); }; };
    const now = ()=>performance.now();
    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    // -------------------------- STATE --------------------------
    const state = {
      image: null,
      selections: [],
      activeIndex: -1,
      mode: 'lasso',
      modeGroup: 'manual',
      transform: {x:0,y:0,scale:1},
      isPanning: false,
      drag:{active:false,startX:0,startY:0, moved:false, kind:null, handle:null, snapshot:null},
      history: [], histIndex: -1,
      activePreset: 0,
      filters:[
        {name:'Classic',   css:(s)=>`grayscale(${s}%)`,                                                aggr:20},
        {name:'High Pop',  css:(s)=>`grayscale(${s}%) contrast(1.35) brightness(1.05)`,                aggr:30},
        {name:'Soft Film', css:(s)=>`grayscale(${s}%) brightness(1.03) contrast(1.08) saturate(.9)`,   aggr:35},
        {name:'Crunchy',   css:(s)=>`grayscale(${s}%) contrast(1.55)`,                                 aggr:45},
        {name:'Dreamy',    css:(s)=>`grayscale(${s}%) blur(0.6px) brightness(1.06)`,                   aggr:60},
        {name:'Neutral',   css:(s)=>`grayscale(${s}%) brightness(1.02)`,                               aggr:25}
      ],
      aggr:35, tol:25, filtStrength:100, rendering:false, brush:{size:28, hard:0.9}, thumbnailsReady:false,

      // AI
      ai:{
        active:false,
        segModel:'yolov8n-seg', depthModel:'mobiledepth', refine:false,
        lastClick:null, prompt:'',
        sessions:{}, preloading:{},
        outputs:{ rawMask:null, finalMask:null, depth:null, depthCanvas:null, maskCanvas:null },
        suggestions: [] // [{name, canvas, fullMask}]
      }
    };

    // -------------------------- MODEL SOURCES (mirrors) --------------------------
    const MODEL_SOURCES = {
      // Segmentation
      'yolov8n-seg': [
        'https://huggingface.co/onnx-community/ultralytics-yolov8/resolve/main/yolov8n-seg.onnx',
        'https://raw.githubusercontent.com/ultralytics/assets/main/onnx/models/yolov8n-seg.onnx',
        'https://cdn.jsdelivr.net/gh/ultralytics/assets/onnx/models/yolov8n-seg.onnx'
      ],
      'yolo11n-seg': [
        'https://huggingface.co/keremberke/yolo11n-seg-onnx/resolve/main/model.onnx',
        'https://raw.githubusercontent.com/keremberke/YOLO11-ONNX-models/main/yolo11n-seg.onnx',
        'https://cdn.jsdelivr.net/gh/keremberke/YOLO11-ONNX-models/yolo11n-seg.onnx'
      ],
      'mobile-sam': [
        'https://huggingface.co/ziqiangxu/MobileSAM-onnx/resolve/main/mobile_sam.onnx',
        'https://raw.githubusercontent.com/ChaoningZhang/MobileSAM/master/onnx/mobile_sam.onnx',
        'https://cdn.jsdelivr.net/gh/ChaoningZhang/MobileSAM/onnx/mobile_sam.onnx'
      ],
      // Depth
      'mobiledepth': [
        'https://huggingface.co/apple/ml-depth-pro/resolve/main/mobiledepth_tiny.onnx',
        'https://raw.githubusercontent.com/apple/ml-depth-pro/main/assets/onnx/mobiledepth_tiny.onnx',
        'https://cdn.jsdelivr.net/gh/apple/ml-depth-pro/assets/onnx/mobiledepth_tiny.onnx'
      ],
      'midas-small': [
        'https://huggingface.co/onnx-community/MiDaS/resolve/main/midas_small.onnx',
        'https://raw.githubusercontent.com/isl-org/MiDaS/master/weights/midas_small.onnx',
        'https://cdn.jsdelivr.net/gh/isl-org/MiDaS/weights/midas_small.onnx'
      ],
      'da-v2-small': [
        'https://huggingface.co/depth-anything/Depth-Anything-V2-Small/resolve/main/depth_anything_v2_small.onnx',
        'https://raw.githubusercontent.com/DepthAnything/Depth-Anything-V2/main/weights/depth_anything_v2_small.onnx',
        'https://cdn.jsdelivr.net/gh/DepthAnything/Depth-Anything-V2/weights/depth_anything_v2_small.onnx'
      ]
    };
    const MODEL_META = {
      'yolov8n-seg': { type:'seg-yolo', inputSize:640 },
      'yolo11n-seg': { type:'seg-yolo', inputSize:640 },
      'mobile-sam' : { type:'seg-sam',  inputSize:512 },
      'mobiledepth':{ type:'depth',     inputSize:256 },
      'midas-small':{ type:'depth',     inputSize:256 },
      'da-v2-small':{ type:'depth',     inputSize:518 }
    };

    // -------------------------- SEGMENTATION WORKER --------------------------
    let segWorker=null, segReady=false;
    function initSegWorker(){
      if(segWorker) return;
      try{
        const src = document.getElementById('seg-worker-src').textContent;
        const blob = new Blob([src], {type:'application/javascript'});
        const url = URL.createObjectURL(blob);
        segWorker = new Worker(url);
        segWorker.onmessage = (e)=>{
          const {type, payload, reqId, bitmap} = e.data || {};
          if(type==='ready'){ segReady=true; log('Seg Worker ready.'); return; }
          if(type==='error'){ log('Worker error:', payload); finishProgress(); return; }
          if(type==='mask'){
            const cnv = document.createElement('canvas');
            cnv.width = state.image.width; cnv.height = state.image.height;
            const ctx = cnv.getContext('2d', { willReadFrequently:true });
            if(bitmap){
              ctx.drawImage(bitmap,0,0);
            }
            // Inject as AI or manual depending on group
            if(state.modeGroup==='ai'){
              state.ai.outputs.finalMask = cnv;
            }else{
              state.selections.push({ type:'mask', maskCanvas: cnv, generator: { tool:'edgeGrow', origin:'worker' } });
              state.activeIndex = state.selections.length-1;
            }
            editor.draw(); schedulePreviewRender(true); history.save(); finishProgress();
            log('Seg mask added (worker).');
          }
        };
      }catch(err){ log('Failed to init worker, fallback disabled:', String(err)); }
    }

    function requestSegMask(tool, seedX, seedY, tol, aggr){
      return new Promise((resolve)=>{
        const W = state.image.width, H = state.image.height;
        const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
        const tx = tmp.getContext('2d'); tx.drawImage(state.image,0,0);
        const imgData = tx.getImageData(0,0,W,H);
        const reqId = Math.random().toString(36).slice(2);
        segWorker.postMessage({ type:'segment', reqId,
          payload:{ tool, seedX, seedY, tol01: clamp(tol/100,0,1), aggr, width:W, height:H, image: imgData }
        }, [imgData.data.buffer]);
        resolve();
      });
    }

    // -------------------------- EDITOR --------------------------
    const editor = {
      c: dom.editorCanvas,
      ctx: dom.editorCanvas.getContext('2d', { willReadFrequently:true }),
      updateSize(){ const w = dom.editorWrap.clientWidth, h = dom.editorWrap.clientHeight; this.c.width = w; this.c.height = h; },
      imgToCanvasSpace(clientX, clientY){
        const r = this.c.getBoundingClientRect();
        const x = (clientX - r.left - state.transform.x)/state.transform.scale;
        const y = (clientY - r.top - state.transform.y)/state.transform.scale;
        return {x,y};
      },
      draw(){
        const {ctx,c} = this;
        ctx.clearRect(0,0,c.width,c.height);
        if(!state.image){ return; }
        ctx.save(); ctx.translate(state.transform.x, state.transform.y); ctx.scale(state.transform.scale, state.transform.scale);
        ctx.drawImage(state.image, 0, 0);

        // overlays
        state.selections.forEach((sel,i)=>{
          const active = i===state.activeIndex; ctx.save();
          ctx.lineWidth = active ? 2.5 / state.transform.scale : 1.5 / state.transform.scale;
          ctx.strokeStyle = active ? '#1877f2' : 'rgba(0,0,0,.45)';
          ctx.fillStyle = active ? 'rgba(24,119,242,.08)' : 'rgba(255,255,255,.18)';
          ctx.setLineDash(active ? [] : [6 / state.transform.scale, 4 / state.transform.scale]);
          if(sel.type==='box'){
            ctx.strokeRect(sel.x, sel.y, sel.w, sel.h); ctx.fillRect(sel.x, sel.y, sel.w, sel.h); if(active) drawBoxHandles(ctx, sel);
          } else if(sel.type==='lasso'){
            ctx.beginPath(); sel.points.forEach((p,idx)=> idx?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.closePath(); ctx.stroke(); ctx.fill();
          } else if((sel.type==='mask' || sel.type==='protect') && sel.maskCanvas){
            ctx.globalAlpha = active ? 0.25 : 0.15; ctx.drawImage(sel.maskCanvas,0,0); ctx.globalAlpha = 1;
            const edge = edgeFromMask(sel.maskCanvas, 1);
            if(edge){
              ctx.save(); ctx.strokeStyle = sel.type==='protect' ? '#b00020' : (active ? '#1877f2' : 'rgba(0,0,0,.45)');
              ctx.lineWidth = active ? 2.0 / state.transform.scale : 1.2 / state.transform.scale; ctx.drawImage(edge, 0, 0); ctx.restore();
            }
          }
          ctx.restore();
        });
        ctx.restore();
      }
    };

    // -------------------------- PREVIEW --------------------------
    const preview = {
      c: dom.previewCanvas,
      ctx: dom.previewCanvas.getContext('2d', { willReadFrequently:true }),
      layout(){
        if(!state.image) return;
        const rect = dom.previewContainer.getBoundingClientRect();
        const availW = Math.max(0, rect.width), availH = Math.max(0, rect.height);
        const aspect = state.image.width / state.image.height;
        let w = availW, h = w/aspect; if(h>availH){ h = availH; w = h*aspect; }
        this.c.width = Math.max(1, Math.round(w)); this.c.height = Math.max(1, Math.round(h));
        dom.previewCanvas.style.left = ((availW - this.c.width)/2) + 'px';
        dom.previewCanvas.style.top  = ((availH - this.c.height)/2) + 'px';
      },
      render(){
        if(!state.image) return;
        const fullMask = buildFullMaskCanvas();
        const ctx = this.ctx; ctx.clearRect(0,0,this.c.width,this.c.height);

        // grayscale background
        const cssFilter = state.filters[state.activePreset].css(state.filtStrength);
        ctx.save(); ctx.filter = cssFilter; ctx.drawImage(state.image, 0, 0, this.c.width, this.c.height); ctx.restore();

        // colorized via mask
        const colored = document.createElement('canvas'); colored.width = state.image.width; colored.height = state.image.height;
        const cctx = colored.getContext('2d');
        cctx.drawImage(state.image,0,0);
        cctx.globalCompositeOperation = 'destination-in';
        cctx.drawImage(fullMask,0,0);
        ctx.drawImage(colored, 0,0, this.c.width, this.c.height);
      }
    };

    function buildFullMaskCanvas(){
      const m = document.createElement('canvas');
      const W = state.image.width, H = state.image.height;
      m.width = W; m.height = H; const mctx = m.getContext('2d');

      // base mask (white=colorized)
      mctx.fillStyle = '#fff';
      state.selections.forEach(sel=>{
        if(sel.type==='box'){ mctx.fillRect(sel.x, sel.y, sel.w, sel.h); }
        else if(sel.type==='lasso'){
          mctx.beginPath(); sel.points.forEach((p,i)=> i?mctx.lineTo(p.x,p.y):mctx.moveTo(p.x,p.y)); mctx.closePath(); mctx.fill();
        } else if(sel.type==='mask' && sel.maskCanvas){ mctx.drawImage(sel.maskCanvas,0,0); }
      });

      // subtract protections
      state.selections.forEach(sel=>{
        if(sel.type==='protect' && sel.maskCanvas){
          mctx.globalCompositeOperation = 'destination-out'; mctx.drawImage(sel.maskCanvas,0,0); mctx.globalCompositeOperation = 'source-over';
        }
      });

      // AI final mask (additive)
      if(state.ai.active && state.ai.outputs.finalMask){ mctx.drawImage(state.ai.outputs.finalMask, 0, 0); }

      // feather (blur)
      const blurPx = Math.round(clamp(state.aggr,0,100) * 0.22);
      if(blurPx>0){
        const tmp = document.createElement('canvas'); tmp.width = W; tmp.height = H;
        const tctx = tmp.getContext('2d'); tctx.filter = `blur(${blurPx}px)`; tctx.drawImage(m,0,0);
        mctx.clearRect(0,0,W,H); mctx.drawImage(tmp,0,0);
      }
      return m;
    }

    // -------------------------- PRESETS --------------------------
    function renderPresets(){
      if(!state.image){ dom.presets.innerHTML=''; return; }
      dom.presets.innerHTML = '';
      state.filters.forEach((flt, idx)=>{
        const item = document.createElement('div');
        item.className = 'preset' + (idx===state.activePreset?' active':'');
        item.innerHTML = `<canvas></canvas><label>${flt.name}</label>`;
        const c = item.querySelector('canvas'), cctx = c.getContext('2d');
        const aspect = state.image.width/state.image.height;
        c.width = 84; c.height = Math.max(56, Math.round(84/aspect));
        cctx.save(); cctx.filter = flt.css(100); cctx.drawImage(state.image, 0,0,c.width,c.height); cctx.restore();
        item.addEventListener('click', ()=>{
          state.activePreset = idx; state.aggr = state.filters[idx].aggr; updateSettingsUI();
          document.querySelectorAll('.preset').forEach(el=>el.classList.remove('active'));
          item.classList.add('active'); schedulePreviewRender(true); log('Preset:', flt.name);
        });
        dom.presets.appendChild(item);
      });
      state.thumbnailsReady = true;
    }

    // -------------------------- HISTORY --------------------------
    const history = {
      save(){
        const snapshot = {
          selections: JSON.parse(JSON.stringify(state.selections, (k,v)=>((k==='maskCanvas' && v && v.toDataURL)? v.toDataURL():v))),
          activeIndex: state.activeIndex, transform:{...state.transform},
          activePreset: state.activePreset, aggr: state.aggr, tol: state.tol, filtStrength: state.filtStrength,
          ai: { active: state.ai.active, segModel: state.ai.segModel, depthModel: state.ai.depthModel, refine: state.ai.refine, lastClick: state.ai.lastClick, prompt: state.ai.prompt }
        };
        if(state.histIndex < state.history.length-1) state.history = state.history.slice(0,state.histIndex+1);
        state.history.push(JSON.stringify(snapshot)); state.histIndex++; refreshButtons();
      },
      load(i){
        const snap = JSON.parse(state.history[i]);
        state.selections = (snap.selections||[]).map(s=>{
          if((s.type==='mask' || s.type==='protect') && s.maskCanvas && typeof s.maskCanvas==='string'){ return {...s, maskCanvas: dataURLToCanvas(s.maskCanvas)}; }
          return s;
        });
        state.activeIndex = snap.activeIndex; state.transform = snap.transform;
        state.activePreset = snap.activePreset ?? state.activePreset; state.aggr = snap.aggr ?? state.aggr; state.tol = snap.tol ?? state.tol; state.filtStrength = snap.filtStrength ?? state.filtStrength;
        if(snap.ai){ state.ai.active=!!snap.ai.active; state.ai.segModel=snap.ai.segModel||state.ai.segModel; state.ai.depthModel=snap.ai.depthModel||state.ai.depthModel; state.ai.refine=!!snap.ai.refine; state.ai.lastClick=snap.ai.lastClick||null; state.ai.prompt=snap.ai.prompt||''; }
        editor.draw(); schedulePreviewRender(true); renderPresets(); updateSettingsUI(); refreshButtons(); setAIModeUI();
      },
      undo(){ if(state.histIndex>0){ state.histIndex--; history.load(state.histIndex); log('Undo'); } },
      redo(){ if(state.histIndex<state.history.length-1){ state.histIndex++; history.load(state.histIndex); log('Redo'); } }
    };

    // -------------------------- BOX/LASSO helpers --------------------------
    function drawBoxHandles(ctx, sel){
      const r = 5 / state.transform.scale;
      const pts = [[ sel.x, sel.y],[ sel.x+sel.w/2, sel.y],[ sel.x+sel.w, sel.y],[ sel.x+sel.w, sel.y+sel.h/2],[ sel.x+sel.w, sel.y+sel.h],[ sel.x+sel.w/2, sel.y+sel.h],[ sel.x, sel.y+sel.h],[ sel.x, sel.y+sel.h/2]];
      ctx.fillStyle='#1877f2'; ctx.strokeStyle='#fff'; ctx.lineWidth=1.5/state.transform.scale;
      pts.forEach(([px,py])=>{ ctx.beginPath(); ctx.rect(px-r, py-r, r*2, r*2); ctx.fill(); ctx.stroke(); });
    }
    function pointInLasso(sel, x, y){
      let inside = false, pts = sel.points;
      for(let i=0,j=pts.length-1; i<pts.length; j=i++){
        const xi=pts[i].x, yi=pts[i].y, xj=pts[j].x, yj=pts[j].y;
        const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside = !inside;
      }
      return inside;
    }
    function maskHit(maskCanvas, x, y){
      if(x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return false;
      const ctx = maskCanvas.getContext('2d'); const d = ctx.getImageData(Math.floor(x), Math.floor(y), 1,1).data; return d[3] > 10;
    }
    function edgeFromMask(maskCanvas, r){
      const w = maskCanvas.width, h = maskCanvas.height; if(!w||!h) return null;
      const srcCtx = maskCanvas.getContext('2d'); const src = srcCtx.getImageData(0,0,w,h);
      const eroded = document.createElement('canvas'); eroded.width=w; eroded.height=h; const ex = eroded.getContext('2d');
      ex.filter = `blur(${Math.max(0.5,r)}px)`; ex.drawImage(maskCanvas,0,0); ex.filter = 'none'; const eData = ex.getImageData(0,0,w,h);
      const edge = document.createElement('canvas'); edge.width=w; edge.height=h; const out = edge.getContext('2d'); const oData = out.createImageData(w,h);
      for(let i=0;i<oData.data.length;i+=4){ const a = src.data[i+3], b = eData.data[i+3]; const v = Math.max(0, a - b);
        oData.data[i]=0; oData.data[i+1]=0; oData.data[i+2]=0; oData.data[i+3]=v>8? 220:0; }
      out.putImageData(oData,0,0); return edge;
    }
    function dataURLToCanvas(url){
      const img = new Image(); const cnv = document.createElement('canvas');
      img.onload = ()=>{ cnv.width = img.width; cnv.height = img.height; cnv.getContext('2d').drawImage(img,0,0); };
      img.src = url; return cnv;
    }

    // -------------------------- RENDER FLOW --------------------------
    let progressTimer=null, progressTarget=85;
    function startProgress(){ dom.progressWrap.classList.add('visible'); let p = 0; dom.progressBar.style.width = '0%';
      clearInterval(progressTimer); progressTimer = setInterval(()=>{ p = clamp(p + 10, 0, progressTarget); dom.progressBar.style.width = p + '%'; }, 70); }
    function finishProgress(){ clearInterval(progressTimer); progressTimer=null; dom.progressBar.style.width = '100%';
      setTimeout(()=>{ dom.progressWrap.classList.remove('visible'); dom.progressBar.style.width='0%'; }, 260); }
    const renderPreviewDebounced = debounce(()=>{ if(!state.image) return; preview.layout(); preview.render(); finishProgress(); }, 320);
    function schedulePreviewRender(start=true){ if(!state.image) return; if(start) startProgress(); renderPreviewDebounced(); }

    // -------------------------- FILE I/O --------------------------
    $('uploadBtn2').addEventListener('click', ()=>dom.fileInput.click());
    dom.uploadBtn.addEventListener('click', ()=>dom.fileInput.click());
    dom.fileInput.addEventListener('change', onFileInput);

    ['dragover','dragenter'].forEach(ev=> dom.editorWrap.addEventListener(ev,(e)=>{ e.preventDefault(); dom.editorWrap.classList.add('drop-hover'); }));
    ['dragleave','drop'].forEach(ev=> dom.editorWrap.addEventListener(ev,(e)=>{ e.preventDefault(); dom.editorWrap.classList.remove('drop-hover'); }));
    dom.editorWrap.addEventListener('drop', (e)=>{ e.preventDefault(); const f = e.dataTransfer?.files?.[0]; if(f && f.type.startsWith('image/')) readImageFile(f); });

    function onFileInput(e){ const f = e.target.files[0]; if(f) readImageFile(f); }
    function readImageFile(file){
      const r = new FileReader();
      r.onload = ()=>{
        const img = new Image();
        img.onload = ()=>{
          state.image = img;
          state.selections = []; state.activeIndex = -1;
          state.ai.outputs = {rawMask:null, finalMask:null, depth:null, depthCanvas:null, maskCanvas:null};
          dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
          editor.updateSize(); focal.fit(); editor.draw(); renderPresets(); history.save(); refreshButtons(); schedulePreviewRender(true);
          initSegWorker(); dom.aiSuggestions.innerHTML=''; updateSeedInputs(null);
          log('Image loaded:', file.name, `${img.width}x${img.height}`);
        };
        img.src = r.result;
      };
      r.readAsDataURL(file);
    }

    // Save / Load JSON project
    function buildSavePayload(){
      return {
        app: 'Color Splash Pro X', version: APP_VERSION, imageDataURL: getCurrentImageDataURL(),
        selections: state.selections.map(s=>{ const base = {...s}; if((s.type==='mask'||s.type==='protect')&&s.maskCanvas) base.maskCanvas = s.maskCanvas.toDataURL(); return base; }),
        activePreset: state.activePreset, aggr: state.aggr, tol: state.tol, filtStrength: state.filtStrength,
        ai: { active: state.ai.active, segModel: state.ai.segModel, depthModel: state.ai.depthModel, refine: state.ai.refine, lastClick: state.ai.lastClick, prompt: state.ai.prompt }
      };
    }
    function triggerSave(){
      if(!state.image){ alert('Load an image first.'); return; }
      const blob = new Blob([JSON.stringify(buildSavePayload(),null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `colorsplash-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href); log('Saved project JSON.');
    }
    dom.saveBtn.addEventListener('click', triggerSave); dom.saveBtn2.addEventListener('click', triggerSave);

    dom.loadBtn.addEventListener('click', ()=>dom.loadInput.click());
    dom.loadBtn2.addEventListener('click', ()=>dom.loadInput.click());
    dom.loadInput.addEventListener('change', (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{ try{ const obj = JSON.parse(r.result); loadFromObject(obj); log('Loaded project JSON.'); } catch{ alert('Invalid JSON file'); } };
      r.readAsText(f);
    });
    function loadFromObject(obj){
      const img = new Image();
      img.onload = ()=>{
        state.image = img;
        state.selections = (obj.selections||[]).map(s=>((s.type==='mask'||s.type==='protect')&&s.maskCanvas&&typeof s.maskCanvas==='string')? {...s, maskCanvas: dataURLToCanvas(s.maskCanvas)} : s);
        state.activeIndex = -1;
        state.activePreset = obj.activePreset ?? 0; state.aggr = obj.aggr ?? 35; state.tol = obj.tol ?? 25; state.filtStrength = obj.filtStrength ?? 100;
        if(obj.ai){ state.ai.active=!!obj.ai.active; state.ai.segModel=obj.ai.segModel||state.ai.segModel; state.ai.depthModel=obj.ai.depthModel||state.ai.depthModel; state.ai.refine=!!obj.ai.refine; state.ai.lastClick=obj.ai.lastClick||null; state.ai.prompt=obj.ai.prompt||'';}
        dom.editorEmpty.classList.add('hidden'); dom.previewEmpty.classList.add('hidden');
        editor.updateSize(); focal.fit(); editor.draw(); renderPresets(); updateSettingsUI();
        state.history=[]; state.histIndex=-1; history.save(); refreshButtons(); schedulePreviewRender(true);
        initSegWorker(); setAIModeUI(); dom.aiSuggestions.innerHTML='';
        updateSeedInputs(state.ai.lastClick);
      };
      img.src = obj.imageDataURL;
    }
    function getCurrentImageDataURL(){
      if(!state.image) return '';
      if(typeof state.image.src === 'string' && state.image.src.startsWith('data:')) return state.image.src;
      const c = document.createElement('canvas'); c.width = state.image.width; c.height = state.image.height;
      const ctx = c.getContext('2d'); ctx.drawImage(state.image,0,0); return c.toDataURL('image/png');
    }

    dom.startOverBtn.addEventListener('click', clearAll); dom.startOverBtn2.addEventListener('click', clearAll);
    function clearAll(){
      if(!state.image) return;
      if(confirm('Clear the image and all selections?')){
        state.image=null; state.selections=[]; state.activeIndex=-1; state.history=[]; state.histIndex=-1;
        state.ai.outputs = {rawMask:null, finalMask:null, depth:null, depthCanvas:null, maskCanvas:null};
        dom.editorEmpty.classList.remove('hidden'); dom.previewEmpty.classList.remove('hidden');
        editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width, editor.c.height); preview.ctx.clearRect(0,0,preview.c.width, preview.c.height);
        dom.aiSuggestions.innerHTML = '';
        renderPresets(); refreshButtons(); log('Project cleared.');
      }
    }

    // -------------------------- FOCAL / VIEW --------------------------
    const focal = {
      fit(){ if(!state.image) return; const iW=state.image.width,iH=state.image.height; const cW=dom.editorWrap.clientWidth,cH=dom.editorWrap.clientHeight;
        const scale = Math.min(cW/iW, cH/iH)*0.97; const x=(cW - iW*scale)/2; const y=(cH - iH*scale)/2; state.transform = {x,y,scale}; }
    };
    window.addEventListener('resize', debounce(()=>{ editor.updateSize(); preview.layout(); if(state.image){ focal.fit(); editor.draw(); } }, 140));

    // -------------------------- INTERACTIONS --------------------------
    let painting=false;
    dom.editorWrap.addEventListener('mousedown', async (e)=>{
      if(!state.image) return;
      // AI seed click
      if(state.ai.active){
        const p = editor.imgToCanvasSpace(e.clientX, e.clientY);
        const sx = Math.round(clamp(p.x,0,state.image.width-1)), sy = Math.round(clamp(p.y,0,state.image.height-1));
        state.ai.lastClick = {x:sx,y:sy}; updateSeedInputs(state.ai.lastClick);
        log(`AI seed set at (${sx}, ${sy}).`); // auto-run
        runAIPipeline({trigger:'click'}).catch(err=>log('AI error:', err?.message||err));
        return;
      }

      if(state.isPanning){
        state.drag={active:true,kind:'pan',startX:e.clientX,startY:e.clientY,tx:state.transform.x,ty:state.transform.y,moved:false}; dom.editorWrap.classList.add('panning'); return;
      }
      const p = editor.imgToCanvasSpace(e.clientX, e.clientY);

      if(state.mode==='autoSmart' || state.mode==='autoUltra'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        startProgress();
        if(segReady){ await requestSegMask(state.mode, sx, sy, state.tol, state.aggr); }
        else{
          const mask = (state.mode==='autoUltra') ? ultraMask(state.image, sx, sy, state.tol/100, state.aggr) : magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
          if(mask){ state.selections.push({type:'mask', maskCanvas: mask, generator:{tool: (state.mode==='autoUltra'?'grabcutLite':'edgeGrow'), seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr }, origin:'manual'}}); state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); }
          finishProgress();
        }
        return;
      }
      if(state.mode==='autoWand'){
        const sx=Math.round(p.x), sy=Math.round(p.y);
        const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
        if(mask){ state.selections.push({type:'mask', maskCanvas: mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr }, origin:'manual'}}); state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save(); }
        return;
      }
      if(state.mode==='protectEraser' || state.mode==='removeEraser'){
        painting = true; ensureBrushLayer(state.mode==='protectEraser' ? 'protect' : 'mask'); paintOnActiveMask(p.x, p.y, true); editor.draw(); schedulePreviewRender(); return;
      }

      // hit-tests
      let hitIndex=-1, hitHandle=null, hitKind='none';
      for(let i=state.selections.length-1;i>=0;i--){
        const sel = state.selections[i];
        if(sel.type==='box'){
          const h = hitBoxHandle(sel,p.x,p.y); if(h){ hitIndex=i; hitHandle=h; hitKind='box-resize'; break; }
          if(pointInBox(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='lasso'){ if(pointInLasso(sel,p.x,p.y)){ hitIndex=i; hitKind='move'; break; }
        }else if(sel.type==='mask' || sel.type==='protect'){ if(maskHit(sel.maskCanvas, p.x, p.y)){ hitIndex=i; hitKind='move'; break; } }
      }

      if(hitIndex>=0){
        state.activeIndex = hitIndex;
        state.drag = {active:true, kind:hitKind, handle:hitHandle, startX:p.x, startY:p.y, moved:false,
          snapshot: JSON.parse(JSON.stringify(state.selections[hitIndex], (k,v)=>((k==='maskCanvas' && v && v.toDataURL)? v.toDataURL():v)))};
        editor.draw(); return;
      }

      // start new
      state.activeIndex = -1;
      if(state.mode==='box'){
        const s = Math.max(40, Math.min(state.image.width, state.image.height)*0.12);
        const seed = {type:'box', x: clamp(p.x - s/2, 0, state.image.width - s), y: clamp(p.y - s/2, 0, state.image.height - s), w: s, h: s};
        state.selections.push(seed); state.activeIndex = state.selections.length-1; state.drag = {active:true,kind:'box-make', startX:p.x, startY:p.y, moved:false}; editor.draw();
      } else if(state.mode==='lasso'){
        state.activeIndex = state.selections.length; const sel = {type:'lasso', points:[p]}; state.selections.push(sel); state.drag = {active:true,kind:'lasso-make', last:p, moved:false}; editor.draw();
      }
    });

    dom.editorWrap.addEventListener('mousemove', (e)=>{
      if(!state.image) return;
      updateMonocle(e, 'editor');
      if(painting && (state.mode==='protectEraser' || state.mode==='removeEraser')){
        const p = editor.imgToCanvasSpace(e.clientX, e.clientY); paintOnActiveMask(p.x, p.y, false); editor.draw(); schedulePreviewRender(); return;
      }
      if(!state.drag.active) return;
      const p = editor.imgToCanvasSpace(e.clientX,e.clientY);
      if(!state.drag.moved && (Math.abs(e.clientX-state.drag.startX)>3 || Math.abs(e.clientY-state.drag.startY)>3)) state.drag.moved = true;

      switch(state.drag.kind){
        case 'pan':{
          state.transform.x = state.drag.tx + (e.clientX - state.drag.startX);
          state.transform.y = state.drag.ty + (e.clientY - state.drag.startY);
          editor.draw(); break;
        }
        case 'box-resize':{
          const sel = state.selections[state.activeIndex];
          const snap = reviveMaskInSnapshot(state.drag.snapshot);
          const handle = state.drag.handle;
          const minSize = 10; const right = snap.x + snap.w, bottom = snap.y + snap.h;
          let nx=snap.x, ny=snap.y, nw=snap.w, nh=snap.h;
          if(handle.includes('n')){ ny = Math.min(bottom - minSize, p.y); nh = bottom - ny; }
          if(handle.includes('s')){ nh = Math.max(minSize, p.y - snap.y); }
          if(handle.includes('w')){ nx = Math.min(right - minSize, p.x); nw = right - nx; }
          if(handle.includes('e')){ nw = Math.max(minSize, p.x - snap.x); }
          Object.assign(sel, {x:nx,y:ny,w:nw,h:nh}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'move':{
          const sel = state.selections[state.activeIndex]; const snap = reviveMaskInSnapshot(state.drag.snapshot);
          const dx = p.x - state.drag.startX, dy = p.y - state.drag.startY;
          if(sel.type==='box'){ sel.x = snap.x + dx; sel.y = snap.y + dy; }
          else if(sel.type==='lasso'){ sel.points = snap.points.map(pt=>({x:pt.x+dx, y:pt.y+dy})); }
          else if(sel.type==='mask' || sel.type==='protect'){ const moved = document.createElement('canvas'); moved.width = snap.maskCanvas.width; moved.height = snap.maskCanvas.height; moved.getContext('2d').drawImage(snap.maskCanvas, dx, dy); sel.maskCanvas = moved; }
          editor.draw(); schedulePreviewRender(); break;
        }
        case 'box-make':{
          const startX = state.drag.startX, startY = state.drag.startY;
          const x = Math.min(startX, p.x), y = Math.min(startY, p.y);
          const w = Math.abs(p.x - startX), h = Math.abs(p.y - startY);
          const sel = state.selections[state.activeIndex]; Object.assign(sel, {x,y,w,h}); editor.draw(); schedulePreviewRender(); break;
        }
        case 'lasso-make':{
          const sel = state.selections[state.activeIndex]; const last = state.drag.last;
          const dist2 = (p.x-last.x)**2 + (p.y-last.y)**2;
          if(dist2 > (4/state.transform.scale)**2){ sel.points.push(p); state.drag.last = p; editor.draw(); }
          break;
        }
      }
    });

    window.addEventListener('mouseup', ()=>{
      if(!state.image) return;
      if(painting){ painting=false; history.save(); return; }
      if(!state.drag.active) return;
      const wasMake = /-make$/.test(state.drag.kind);
      if(state.drag.kind==='lasso-make'){
        const sel = state.selections[state.activeIndex];
        if(sel && sel.points.length>2){ const a = sel.points[0], b = sel.points[sel.points.length-1]; if(a.x!==b.x || a.y!==b.y) sel.points.push({x:a.x,y:a.y}); }
      }
      if(state.drag.kind==='box-make' && !state.drag.moved){
        const s = Math.max(40, Math.min(state.image.width, state.image.height)*0.12);
        state.selections[state.activeIndex] = {type:'box', x: clamp(state.drag.startX - s/2, 0, state.image.width - s), y: clamp(state.drag.startY - s/2, 0, state.image.height - s), w: s, h: s};
      } else if(state.drag.kind==='box-make'){
        const sel = state.selections[state.activeIndex]; if(sel && (sel.w<5 || sel.h<5)){ state.selections.splice(state.activeIndex,1); state.activeIndex = -1; }
      }
      if(state.drag.kind==='lasso-make'){ const sel = state.selections[state.activeIndex]; if(sel && sel.points.length<3){ state.selections.splice(state.activeIndex,1); state.activeIndex = -1; } }
      state.drag.active=false; dom.editorWrap.classList.remove('panning'); editor.draw(); schedulePreviewRender(true); history.save(); if(wasMake) log('Selection added.');
    });

    dom.previewWrap.addEventListener('mousemove', (e)=>{ if(!state.image) return; updateMonocle(e, 'preview'); });
    dom.editorWrap.addEventListener('mouseenter', ()=> dom.monocleLeft.style.display = 'block');
    dom.previewWrap.addEventListener('mouseenter', ()=> dom.monocleRight.style.display = 'block');

    dom.editorWrap.addEventListener('wheel', (e)=>{
      if(!state.image) return; e.preventDefault();
      const r = dom.editorCanvas.getBoundingClientRect(); const mx = e.clientX - r.left, my = e.clientY - r.top;
      const zf = 1.1; const zoom = e.deltaY < 0 ? zf : 1/zf; const newScale = clamp(state.transform.scale * zoom, 0.1, 20);
      state.transform.x = mx - (mx - state.transform.x)*zoom; state.transform.y = my - (my - state.transform.y)*zoom; state.transform.scale = newScale;
      editor.draw(); updateMonocle(e, 'editor');
    }, {passive:false});

    dom.modeLassoBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('lasso'); });
    dom.newLassoBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('lasso'); state.activeIndex=-1; editor.draw(); log('Ready to draw a new lasso.'); });
    dom.modeBoxBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('box'); });
    dom.deleteSelectionBtn.addEventListener('click', ()=>{ if(state.activeIndex!==-1){ const t=state.selections[state.activeIndex]?.type; state.selections.splice(state.activeIndex,1); state.activeIndex=-1; editor.draw(); schedulePreviewRender(true); history.save(); log('Deleted:', t||''); }});
    dom.autoWandBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('autoWand'); });
    dom.autoSmartBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('autoSmart'); });
    dom.autoUltraBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('autoUltra'); });
    dom.autoObjectsBtn.addEventListener('click', async ()=>{ setAIMode(false); if(!state.image){ alert('Load an image first.'); return; } const sx=Math.round(state.image.width/2), sy=Math.round(state.image.height/2); startProgress();
      if(segReady){ await requestSegMask('autoSmart', sx, sy, state.tol, state.aggr); } else {
        const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
        if(mask){ state.selections.push({type:'mask', maskCanvas: mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{ tol: state.tol, aggr: state.aggr }, auto:true, origin:'manual'}}); state.activeIndex=state.selections.length-1; editor.draw(); schedulePreviewRender(true); history.save();}
      }
      finishProgress();
    });
    dom.protectEraserBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('protectEraser'); });
    dom.removeEraserBtn.addEventListener('click', ()=>{ setAIMode(false); setMode('removeEraser'); });
    dom.undoBtn.addEventListener('click', ()=>history.undo());
    dom.redoBtn.addEventListener('click', ()=>history.redo());
    dom.renderNowBtn.addEventListener('click', ()=>{ startProgress(); preview.layout(); preview.render(); finishProgress(); log('Manual render complete.'); });
    dom.resetViewBtn.addEventListener('click', ()=>{ if(!state.image) return; focal.fit(); editor.draw(); log('View reset (fit).'); });

    dom.downloadBtn.addEventListener('click', ()=>{
      if(!state.image){ alert('Load an image first.'); return; }
      const out = document.createElement('canvas'); out.width = state.image.width; out.height = state.image.height; const octx = out.getContext('2d');
      // grayscale bg HQ
      const tmpC=document.createElement('canvas'); tmpC.width=out.width; tmpC.height=out.height; const tmpX=tmpC.getContext('2d'); tmpX.drawImage(state.image,0,0);
      const src=tmpX.getImageData(0,0,out.width,out.height); const data=src.data;
      for(let i=0;i<data.length;i+=4){ const y=Math.round(0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2]); data[i]=y; data[i+1]=y; data[i+2]=y; data[i+3]=255; }
      tmpX.putImageData(src,0,0); octx.drawImage(tmpC,0,0);
      const fullMask = buildFullMaskCanvas();
      const fg = document.createElement('canvas'); fg.width=out.width; fg.height=out.height; const fgctx = fg.getContext('2d');
      fgctx.drawImage(state.image,0,0); fgctx.globalCompositeOperation='destination-in'; fgctx.drawImage(fullMask,0,0); octx.drawImage(fg,0,0);
      const url = out.toDataURL('image/png'); const a = document.createElement('a'); a.href = url; a.download = `colorsplash-result-${Date.now()}.png`; a.click();
    });

    // Settings/logs
    let logsVisible=false; const applyLogsVisibility = ()=>{ dom.manualLogs.style.display = logsVisible ? 'block' : 'none'; };
    applyLogsVisibility();
    dom.toggleLogsBtn.addEventListener('click', ()=>{ logsVisible=!logsVisible; applyLogsVisibility(); });
    dom.clearLogsBtn.addEventListener('click', ()=>{ dom.logBody.innerHTML=''; dom.aiLogBody.innerHTML=''; });

    function setMode(m){
      state.mode = m;
      dom.modeLassoBtn.classList.toggle('active', m==='lasso');
      dom.modeBoxBtn.classList.toggle('active', m==='box');
      dom.autoWandBtn.classList.toggle('active', m==='autoWand');
      dom.autoSmartBtn.classList.toggle('active', m==='autoSmart');
      dom.autoUltraBtn.classList.toggle('active', m==='autoUltra');
      dom.protectEraserBtn.classList.toggle('active', m==='protectEraser');
      dom.removeEraserBtn.classList.toggle('active', m==='removeEraser');
      log('Mode:', m);
    }
    function refreshButtons(){
      const disabled = !state.image;
      [dom.saveBtn, dom.saveBtn2, dom.startOverBtn, dom.startOverBtn2].forEach(b=> b.disabled = disabled);
      dom.undoBtn.disabled = state.histIndex<=0;
      dom.redoBtn.disabled = state.histIndex>=state.history.length-1 || state.history.length===0;
      dom.deleteSelectionBtn.disabled = state.activeIndex===-1;
    }
    function updateSettingsUI(){
      dom.aggrRange.value = state.aggr; dom.aggrVal.textContent = state.aggr;
      dom.tolRange.value  = state.tol;  dom.tolVal.textContent  = state.tol;
      dom.fltRange.value  = state.filtStrength; dom.fltVal.textContent = state.filtStrength+'%';
      dom.aiRefine.checked = state.ai.refine; dom.aiRefine2.checked = state.ai.refine;
      dom.aiPrompt.value = state.ai.prompt; dom.aiPrompt2.value = state.ai.prompt;
    }

    // -------------------------- ERASERS --------------------------
    function ensureBrushLayer(kind){
      const idx = state.selections.findIndex(s=>s.type === (kind==='protect'?'protect':'mask'));
      if(idx>=0){ state.activeIndex = idx; return; }
      const cnv = document.createElement('canvas'); cnv.width = state.image.width; cnv.height = state.image.height;
      state.selections.push({type: kind==='protect'?'protect':'mask', maskCanvas: cnv}); state.activeIndex = state.selections.length-1;
    }
    let lastPaint=null;
    function paintOnActiveMask(x,y,fresh){
      const sel = state.selections[state.activeIndex]; if(!sel || !sel.maskCanvas) return;
      const ctx = sel.maskCanvas.getContext('2d'); const size = state.brush.size; const hard = state.brush.hard; const radius = size/2;
      ctx.save(); ctx.globalCompositeOperation = 'source-over';
      const gx = ctx.createRadialGradient(x,y, radius*hard, x,y, radius);
      const color = (sel.type==='protect') ? 'rgba(255,0,0,1)' : 'rgba(255,255,255,1)'; gx.addColorStop(0, color); gx.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = gx;
      if(fresh || !lastPaint){ ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill(); }
      else{ const dx=x-lastPaint.x, dy=y-lastPaint.y; const steps = Math.max(1, Math.ceil(Math.hypot(dx,dy)/(radius*0.5)));
        for(let i=1;i<=steps;i++){ const t=i/steps; const px=lastPaint.x+dx*t, py=lastPaint.y+dy*t; ctx.beginPath(); ctx.arc(px,py,radius,0,Math.PI*2); ctx.fill(); } }
      ctx.restore(); lastPaint = {x,y};
    }

    // -------------------------- MONOCLES --------------------------
    function updateMonocle(e, where){
      if(!state.image) return;
      const hopIfNear = (monoEl, panelRect, side)=>{
        const padding = 10; const monoRect = monoEl.getBoundingClientRect();
        const dist = Math.hypot(Math.max(0, Math.max(monoRect.left - e.clientX, e.clientX - monoRect.right)), Math.max(0, Math.max(monoRect.top - e.clientY, e.clientY - monoRect.bottom)));
        if(dist < 18){ if(side==='left'){ monoEl.style.left = (panelRect.width - monoRect.width - padding) + 'px'; monoEl.style.right='auto'; } else { monoEl.style.right = (panelRect.width - monoRect.width - padding) + 'px'; monoEl.style.left='auto'; } }
        else{ if(side==='left'){ monoEl.style.left = padding + 'px'; monoEl.style.right='auto'; } else { monoEl.style.right = padding + 'px'; monoEl.style.left='auto'; } }
      };

      if(where==='editor'){
        const mCtx = dom.monoLeftCanvas.getContext('2d'); if(dom.monoLeftCanvas.width===0){ dom.monoLeftCanvas.width=148; dom.monoLeftCanvas.height=148; }
        const rect = dom.editorCanvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left - state.transform.x)/state.transform.scale; const cy = (e.clientY - rect.top - state.transform.y)/state.transform.scale;
        const box=64; const sx=Math.floor(clamp(cx - box/2, 0, state.image.width - box)); const sy=Math.floor(clamp(cy - box/2, 0, state.image.height - box));
        mCtx.imageSmoothingEnabled=false; mCtx.clearRect(0,0,dom.monoLeftCanvas.width,dom.monoLeftCanvas.height); mCtx.drawImage(state.image, sx, sy, box, box, 0, 0, dom.monoLeftCanvas.width, dom.monoLeftCanvas.height);
        const fx=((cx - sx)/box)*dom.monoLeftCanvas.width, fy=((cy - sy)/box)*dom.monoLeftCanvas.height; mCtx.strokeStyle='#0a46ff'; mCtx.lineWidth=1; mCtx.beginPath(); mCtx.moveTo(fx,0); mCtx.lineTo(fx,dom.monoLeftCanvas.height); mCtx.moveTo(0,fy); mCtx.lineTo(dom.monoLeftCanvas.width,fy); mCtx.stroke();
        dom.monocleLeft.style.display='block'; hopIfNear(dom.monocleLeft, dom.editorWrap.getBoundingClientRect(), 'left');
      } else {
        const mCtx = dom.monoRightCanvas.getContext('2d'); if(dom.monoRightCanvas.width===0){ dom.monoRightCanvas.width=148; dom.monoRightCanvas.height=148; }
        const rect = dom.previewCanvas.getBoundingClientRect(); const scaleX = state.image.width/Math.max(1, dom.previewCanvas.width), scaleY = state.image.height/Math.max(1, dom.previewCanvas.height);
        const cx = (e.clientX - rect.left) * scaleX; const cy = (e.clientY - rect.top) * scaleY;
        const box=64; const sx=Math.floor(clamp(cx - box/2, 0, state.image.width - box)); const sy=Math.floor(clamp(cy - box/2, 0, state.image.height - box));
        mCtx.imageSmoothingEnabled=false; mCtx.clearRect(0,0,dom.monoRightCanvas.width,dom.monoRightCanvas.height);
        const cut = document.createElement('canvas'); cut.width=box; cut.height=box; const cutx=cut.getContext('2d');
        const px = sx/scaleX, py = sy/scaleY; cutx.drawImage(dom.previewCanvas, Math.round(px), Math.round(py), Math.round(box/scaleX), Math.round(box/scaleY), 0, 0, box, box);
        mCtx.drawImage(cut, 0,0, box, box, 0, 0, dom.monoRightCanvas.width, dom.monoRightCanvas.height);
        const fx=((cx - sx)/box)*dom.monoRightCanvas.width, fy=((cy - sy)/box)*dom.monoRightCanvas.height; mCtx.strokeStyle='#0a46ff'; mCtx.lineWidth=1; mCtx.beginPath(); mCtx.moveTo(fx,0); mCtx.lineTo(fx,dom.monoRightCanvas.height); mCtx.moveTo(0,fy); mCtx.lineTo(dom.monoRightCanvas.width,fy); mCtx.stroke();
        dom.monocleRight.style.display='block'; hopIfNear(dom.monocleRight, dom.previewWrap.getBoundingClientRect(), 'right');
      }
    }

    // -------------------------- SETTINGS --------------------------
    dom.aggrRange.addEventListener('input', ()=>{ state.aggr = parseInt(dom.aggrRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });
    dom.tolRange.addEventListener('input', ()=>{ state.tol  = parseInt(dom.tolRange.value,10); updateSettingsUI(); if(state.modeGroup==='manual'){ recomputeGeneratedMasks(); } });
    dom.fltRange.addEventListener('input', ()=>{ state.filtStrength = parseInt(dom.fltRange.value,10); updateSettingsUI(); schedulePreviewRender(true); });

    async function recomputeGeneratedMasks(){
      if(!state.image){ return; }
      const targets = [];
      state.selections.forEach((s, idx)=>{ if(s && s.type==='mask' && s.generator && s.generator.tool && s.generator.origin!=='ai'){ const t=s.generator.tool; if(t==='edgeGrow' || t==='grabcutLite' || t==='magicWand'){ targets.push(idx); } }});
      if(targets.length===0){ schedulePreviewRender(true); return; }
      startProgress();
      for(const idx of targets){
        const s = state.selections[idx]; const g = s.generator || {};
        const sx = Math.round(g.seedX ?? (state.image.width/2)); const sy = Math.round(g.seedY ?? (state.image.height/2));
        const tool = (g.tool==='edgeGrow') ? 'autoSmart' : (g.tool==='grabcutLite') ? 'autoUltra' : (g.tool==='magicWand') ? 'autoWand' : 'autoSmart';
        if(tool==='autoWand'){
          const mask = magicWandMask(state.image, sx, sy, state.tol/100, state.aggr); if(mask) state.selections[idx] = {type:'mask', maskCanvas:mask, generator:{tool:'magicWand', seedX:sx, seedY:sy, params:{tol:state.tol, aggr:state.aggr}, origin:'manual'}};
        } else if(segReady){
          await requestSegMask(tool, sx, sy, state.tol, state.aggr);
        } else {
          const fallback = (tool==='autoUltra') ? ultraMask(state.image, sx, sy, state.tol/100, state.aggr) : magicWandMask(state.image, sx, sy, state.tol/100, state.aggr);
          if(fallback) state.selections[idx] = {type:'mask', maskCanvas:fallback, generator:{ tool: tool==='autoUltra' ? 'grabcutLite':'edgeGrow', seedX:sx, seedY:sy, params:{tol:state.tol, aggr:state.aggr, fallback:true}, origin:'manual' }};
        }
      }
      editor.draw(); schedulePreviewRender(false); history.save(); finishProgress(); log('Recomputed generated mask(s) for new tolerance/aggr.');
    }

    // Built-in quick tools
    function magicWandMask(img, seedX, seedY, tol01, growStrength){
      const w=img.width,h=img.height; const maxSide=1024; const scale = Math.min(1, maxSide / Math.max(w,h));
      const sw = Math.max(1, Math.round(w*scale)), sh = Math.max(1, Math.round(h*scale));
      const sC = document.createElement('canvas'); sC.width=sw; sC.height=sh; const sX=sC.getContext('2d'); sX.imageSmoothingEnabled=true; sX.drawImage(img,0,0, sw,sh);
      const sx = clamp(Math.round(seedX*scale),0,sw-1), sy = clamp(Math.round(seedY*scale),0,sh-1);
      const src = sX.getImageData(0,0,sw,sh); const data=src.data; const mask=new Uint8Array(sw*sh);
      const idx=(x,y)=> (y*sw + x), pIdx=(x,y)=> idx(x,y)*4;
      const r0=data[pIdx(sx,sy)], g0=data[pIdx(sx,sy)+1], b0=data[pIdx(sx,sy)+2]; const thr = 8 + tol01*132;
      const stack=[[sx,sy]]; mask[idx(sx,sy)]=1;
      while(stack.length){
        const [x,y]=stack.pop();
        for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
          if(nx<0||ny<0||nx>=sw||ny>=sh) continue;
          const id=idx(nx,ny); if(mask[id]) continue;
          const p=pIdx(nx,ny); const dr=data[p]-r0, dg=data[p+1]-g0, db=data[p+2]-b0;
          if(Math.sqrt(dr*dr+dg*dg+db*db)<=thr){ mask[id]=1; stack.push([nx,ny]); }
        }
      }
      if(growStrength && growStrength>0){
        const iters = Math.round(clamp(growStrength,0,100) * 0.08);
        const nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        for(let k=0;k<iters;k++){
          const copy=mask.slice(0);
          for(let y=0;y<sh;y++){ for(let x=0;x<sw;x++){
            if(copy[idx(x,y)]) continue; let on=0;
            for(const [dx,dy] of nb){ const xx=x+dx, yy=y+dy; if(xx>=0&&yy>=0&&xx<sw&&yy<sh&&copy[idx(xx,yy)]){ on=1; break; } }
            if(on) mask[idx(x,y)]=1;
          }}
        }
      }
      const mC=document.createElement('canvas'); mC.width=w; mC.height=h; const mX=mC.getContext('2d'); const mSmall=document.createElement('canvas'); mSmall.width=sw; mSmall.height=sh; const msx=mSmall.getContext('2d');
      const imgMask = msx.createImageData(sw, sh);
      for(let i=0;i<sw*sh;i++){ const v = mask[i] ? 255 : 0; imgMask.data[i*4]=255; imgMask.data[i*4+1]=255; imgMask.data[i*4+2]=255; imgMask.data[i*4+3]=v; }
      msx.putImageData(imgMask,0,0); mX.imageSmoothingEnabled=false; mX.drawImage(mSmall,0,0, sw,sh, 0,0, w,h); return mC;
    }
    function ultraMask(img, seedX, seedY, tol01, aggr){ return magicWandMask(img, seedX, seedY, Math.min(1, tol01*1.2+0.05), aggr+8); }
    function pointInBox(sel,x,y){ return x>=sel.x && y>=sel.y && x<=sel.x+sel.w && y<=sel.y+sel.h; }
    function hitBoxHandle(sel, x, y){
      const pad = 8 / state.transform.scale;
      const pts = [['nw', sel.x, sel.y], ['n',  sel.x+sel.w/2, sel.y], ['ne', sel.x+sel.w, sel.y],['e',  sel.x+sel.w, sel.y+sel.h/2], ['se', sel.x+sel.w, sel.y+sel.h],['s',  sel.x+sel.w/2, sel.y+sel.h], ['sw', sel.x, sel.y+sel.h], ['w',  sel.x, sel.y+sel.h/2]];
      for(const [name, px, py] of pts){ if(Math.abs(x-px)<=pad && Math.abs(y-py)<=pad) return name; } return null;
    }
    function reviveMaskInSnapshot(snap){ if(snap && (snap.type==='mask'||snap.type==='protect') && snap.maskCanvas && typeof snap.maskCanvas==='string'){ snap.maskCanvas = dataURLToCanvas(snap.maskCanvas); } return snap; }

    // -------------------------- INIT --------------------------
    function initEmpty(){
      editor.updateSize(); editor.ctx.clearRect(0,0,editor.c.width, editor.c.height); preview.ctx.clearRect(0,0,preview.c.width, preview.c.height);
      renderPresets(); updateSettingsUI(); refreshButtons(); log(`App ready. Version ${APP_VERSION}`);
      log('Shortcuts: S=Lasso, B=Box, W=Auto Wand, G=Auto Smart, U=Auto Ultra, E=Protect Eraser, R=Remove Eraser. Space+Drag pan. Wheel zoom.');
      setAIModeUI(); detectRuntime();
    }
    initEmpty();

    // -------------------------- AI MODE TOGGLE --------------------------
    $('aiSwitch').addEventListener('change', ()=> setAIMode(dom.aiSwitch.checked));
    $('aiFab').addEventListener('click', ()=> dom.aiPanel.classList.toggle('visible'));

    function setAIMode(flag){
      state.ai.active = !!flag; state.modeGroup = flag ? 'ai' : 'manual';
      setAIModeUI(); if(flag){ backgroundPreload(state.ai.segModel); backgroundPreload(state.ai.depthModel); log('AI Mode ON. Select models, set a seed (click Original) and press Use if needed.'); } else { log('AI Mode OFF. Manual tools active.'); }
      history.save();
    }
    function setAIModeUI(){
      document.body.classList.toggle('ai-on', state.ai.active);
      dom.aiSwitch.checked = state.ai.active;
      dom.aiBar.classList.toggle('visible', state.ai.active);
      dom.manualBottom.style.display = state.ai.active ? 'none' : 'grid';
      dom.aiBottom.style.display     = state.ai.active ? 'grid' : 'none';
      dom.aiSegModel.value  = state.ai.segModel; dom.aiDepthModel.value = state.ai.depthModel;
      dom.aiRefine.checked  = state.ai.refine;  dom.aiRefine2.checked   = state.ai.refine;
      dom.aiPrompt.value    = state.ai.prompt;  dom.aiPrompt2.value     = state.ai.prompt;
      dom.aiStatus.textContent = state.ai.active ? 'AI ready' : 'AI off';
      // mirror save/undo buttons enabled state
      refreshButtons();
    }

    // -------------------------- RUNTIME DETECTION --------------------------
    async function detectRuntime(){
      try{
        const gpuAvailable = !!ort.env.webgpu && (await navigator.gpu?.requestAdapter())!=null;
        const label = gpuAvailable ? 'WebGPU + WASM fallback' : 'WASM only';
        dom.aiRuntimeChip.textContent = label; dom.aiRuntimeChip2.textContent = label; log('Runtime:', label);
      }catch{ dom.aiRuntimeChip.textContent = 'WASM only'; dom.aiRuntimeChip2.textContent = 'WASM only'; }
    }

    // -------------------------- MODEL LOADING WITH MIRRORS --------------------------
    async function fetchWithTimeout(url, ms=20000){
      const ctl = new AbortController(); const id = setTimeout(()=>ctl.abort('timeout'), ms);
      try{
        const res = await fetch(url, { cache:'no-store', signal: ctl.signal, credentials:'omit', mode:'cors' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const buf = await res.arrayBuffer(); return buf;
      } finally { clearTimeout(id); }
    }
    async function ensureORTSession(key){
      if(state.ai.sessions[key]) return state.ai.sessions[key];
      const meta = MODEL_META[key]; if(!meta) throw new Error('Unknown model key: '+key);
      dom.aiStatus.textContent = `loading ${key}‚Ä¶`; log(`AI: Loading model ${key} (${meta.type}) with mirrors‚Ä¶`);
      const gpuAvailable = !!ort.env.webgpu && (await navigator.gpu?.requestAdapter())!=null;
      const providers = gpuAvailable ? ['webgpu', 'wasm'] : ['wasm'];

      const mirrors = MODEL_SOURCES[key] || [];
      let lastErr = null;
      for(const url of mirrors){
        try{
          log('Fetching model:', url);
          const t0 = now(); const buf = await fetchWithTimeout(url, 25000);
          const bytes = new Uint8Array(buf);
          const session = await ort.InferenceSession.create(bytes, { executionProviders: providers, graphOptimizationLevel: 'all' });
          const dt = Math.max(1, Math.round(now()-t0)); log(`Loaded ${key} from mirror in ${dt} ms via ${providers[0]}.`);
          state.ai.sessions[key] = session; dom.aiStatus.textContent = `loaded ${key}`; return session;
        }catch(err){
          lastErr = err; log(`Mirror failed for ${key}:`, err?.message||err);
          await sleep(250);
        }
      }
      throw new Error(`All mirrors failed for ${key}: ${lastErr?.message||lastErr}`);
    }
    function backgroundPreload(key){
      if(state.ai.preloading[key]) return; state.ai.preloading[key] = true;
      ensureORTSession(key).catch(err=>{ log(`AI preload failed for ${key}:`, err?.message||err); state.ai.preloading[key] = false; });
    }

    // -------------------------- AI CONTROLS --------------------------
    dom.aiSegModel.addEventListener('change', ()=>{ state.ai.segModel = dom.aiSegModel.value; backgroundPreload(state.ai.segModel); log('AI seg model:', state.ai.segModel); });
    dom.aiDepthModel.addEventListener('change', ()=>{ state.ai.depthModel = dom.aiDepthModel.value; backgroundPreload(state.ai.depthModel); log('AI depth model:', state.ai.depthModel); });
    dom.aiRefine.addEventListener('change', ()=>{ state.ai.refine = dom.aiRefine.checked; dom.aiRefine2.checked = state.ai.refine; log('AI refine:', state.ai.refine?'ON':'OFF'); });
    dom.aiRefine2.addEventListener('change', ()=>{ state.ai.refine = dom.aiRefine2.checked; dom.aiRefine.checked = state.ai.refine; log('AI refine:', state.ai.refine?'ON':'OFF'); });
    dom.aiPrompt.addEventListener('input', ()=>{ state.ai.prompt = dom.aiPrompt.value.trim(); dom.aiPrompt2.value = state.ai.prompt; });
    dom.aiPrompt2.addEventListener('input', ()=>{ state.ai.prompt = dom.aiPrompt2.value.trim(); dom.aiPrompt.value = state.ai.prompt; });
    dom.seedX.addEventListener('input', syncSeedFromInputs); dom.seedY.addEventListener('input', syncSeedFromInputs);
    dom.seedX2.addEventListener('input', syncSeedFromInputs); dom.seedY2.addEventListener('input', syncSeedFromInputs);

    function syncSeedFromInputs(){
      const x = parseInt(dom.seedX.value || dom.seedX2.value || '0',10);
      const y = parseInt(dom.seedY.value || dom.seedY2.value || '0',10);
      if(state.image){ state.ai.lastClick = { x: clamp(x,0,state.image.width-1), y: clamp(y,0,state.image.height-1) }; }
    }
    function updateSeedInputs(seed){
      const x = seed?.x ?? ''; const y = seed?.y ?? '';
      dom.seedX.value = x; dom.seedY.value = y; dom.seedX2.value = x; dom.seedY2.value = y;
    }

    dom.aiUseBtn.addEventListener('click', ()=>{ if(!state.image){ alert('Load an image first.'); return; } runAIPipeline({trigger:'use'}).catch(err=>log('AI error:', err?.message||err)); });

    // -------------------------- AI PIPELINE --------------------------
    async function runAIPipeline({trigger}={}){
      if(!state.image){ return; }
      state.modeGroup = 'ai'; startProgress(); dom.aiStatus.textContent='running‚Ä¶'; dom.aiSuggestions.innerHTML='';

      // Preload sessions (robust)
      let segSess=null, depthSess=null;
      try{ segSess = await ensureORTSession(state.ai.segModel); }
      catch(err){ log('Segmentation model failed, fallback to worker:', String(err)); }
      try{ depthSess = await ensureORTSession(state.ai.depthModel); }
      catch(err){ log('Depth model failed, will skip depth refine:', String(err)); }

      // Required seed (for SAM and for fancy math)
      let seed = state.ai.lastClick;
      if((state.ai.segModel==='mobile-sam') && !seed){
        dom.aiStatus.textContent = 'awaiting click (MobileSAM needs a point)‚Ä¶'; finishProgress(); return;
      }
      if(!seed && state.image){ seed = {x: Math.round(state.image.width/2), y: Math.round(state.image.height/2)}; updateSeedInputs(seed); }

      // 1) SEGMENTATION
      let aiMaskCanvas = null;
      try{
        const meta = MODEL_META[state.ai.segModel];
        if(meta?.type==='seg-yolo'){
          aiMaskCanvas = await segWithYOLO(segSess, state.image, meta.inputSize, seed, state.ai.prompt);
        } else if(meta?.type==='seg-sam'){
          aiMaskCanvas = await segWithMobileSAM(segSess, state.image, meta.inputSize, seed);
        } else {
          throw new Error('Unknown seg model');
        }
        if(!aiMaskCanvas) throw new Error('No mask produced');
        state.ai.outputs.maskCanvas = aiMaskCanvas;
      }catch(err){
        log('AI segmentation failed ‚Üí using EdgeGrow worker fallback:', err?.message||err);
        try{
          await requestSegMask('autoSmart', seed.x, seed.y, state.tol, state.aggr);
          state.ai.outputs.maskCanvas = null; // selection stack handles it
        }catch(e){ log('Worker fallback failed:', e?.message||e); }
      }

      // 2) DEPTH
      let depthCanvas=null, depthMap=null;
      try{
        if(depthSess){
          const res = await depthPredict(depthSess, state.image, MODEL_META[state.ai.depthModel].inputSize);
          depthMap = res.map; depthCanvas = res.canvas; state.ai.outputs.depth = depthMap; state.ai.outputs.depthCanvas = depthCanvas;
        }
      }catch(err){ log('Depth estimation failed:', err?.message||err); }

      // 3) Thumbnails (mask + depth)
      try{
        if(aiMaskCanvas){
          const mthumb = dom.aiMaskThumb.getContext('2d'); const tw = dom.aiMaskThumb.width = 200, th = dom.aiMaskThumb.height = Math.round(200 * (state.image.height/state.image.width));
          mthumb.imageSmoothingEnabled=false; mthumb.clearRect(0,0,tw,th); mthumb.drawImage(aiMaskCanvas, 0,0, tw,th);
        }else{ dom.aiMaskThumb.width = dom.aiMaskThumb.height = 0; }
        if(depthCanvas){
          const dthumb = dom.aiDepthThumb.getContext('2d'); const tw = dom.aiDepthThumb.width = 200, th = dom.aiDepthThumb.height = Math.round(200 * (state.image.height/state.image.width));
          dthumb.imageSmoothingEnabled=false; dthumb.clearRect(0,0,tw,th); dthumb.drawImage(depthCanvas, 0,0, tw,th);
        }else{ dom.aiDepthThumb.width = dom.aiDepthThumb.height = 0; }
      }catch{}

      // 4) Build 5 suggestions (variations)
      const base = aiMaskCanvas || lastMaskFromSelections();
      state.ai.suggestions = [];
      if(base){
        const suggestions = buildSuggestions(base, depthMap, seed, state.image.width, state.image.height);
        // Render and attach
        dom.aiSuggestions.innerHTML = '';
        suggestions.forEach((sugg, idx)=>{
          const el = document.createElement('div'); el.className = 'ai-suggestion' + (idx===0?' active':'');
          el.innerHTML = `<canvas></canvas><label>${sugg.name}</label>`;
          const c = el.querySelector('canvas'); const ctx=c.getContext('2d');
          const aspect = state.image.width/state.image.height; c.width=120; c.height=Math.max(80, Math.round(120/aspect));
          ctx.imageSmoothingEnabled=false; ctx.drawImage(sugg.canvas,0,0, c.width, c.height);
          el.addEventListener('click', ()=>{
            // set active style
            document.querySelectorAll('.ai-suggestion').forEach(n=>n.classList.remove('active'));
            el.classList.add('active');
            state.ai.outputs.finalMask = sugg.fullMask; schedulePreviewRender(true); history.save(); log('Applied suggestion:', sugg.name);
          });
          dom.aiSuggestions.appendChild(el);
        });

        // Choose default suggestion to apply (index 1 if exists, else 0)
        const pick = suggestions[1] || suggestions[0];
        if(pick){ state.ai.outputs.finalMask = pick.fullMask; schedulePreviewRender(true); history.save(); }
      } else {
        log('No base mask available to build suggestions.');
      }

      dom.aiStatus.textContent='AI done'; finishProgress();
    }

    function lastMaskFromSelections(){
      for(let i=state.selections.length-1;i>=0;i--){ const s=state.selections[i]; if(s.type==='mask' && s.maskCanvas) return s.maskCanvas; }
      return null;
    }

    // -------------------------- YOLO SEGMENTATION --------------------------
    const COCO80 = ["person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light","fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow","elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee","skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket","bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange","broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed","dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven","toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"];

    function promptWeightForClassName(clsName, prompt){
      if(!prompt) return 1.0;
      const p = prompt.toLowerCase();
      const c = clsName.toLowerCase();
      if(c.includes(p) || p.includes(c)) return 1.8;
      // simple token overlap bonus
      const tokens = p.split(/[^a-z0-9]+/).filter(Boolean);
      let hits = 0; for(const t of tokens){ if(c.includes(t)) hits++; }
      return 1.0 + Math.min(0.6, hits*0.3);
    }

    async function segWithYOLO(session, img, inputSize, seed, prompt){
      const {tensor, scale, dx, dy} = makeLetterboxInput(img, inputSize);
      const feeds = {}; const inputName = getFirstInputName(session) || 'images'; feeds[inputName] = tensor;
      const outputs = await session.run(feeds);
      const det = pickFirstTensor(outputs); const proto = pickSecondTensor(outputs);
      const detData = det.data; const [_, num, ch] = det.dims;
      const protoData = proto.data; const [__, maskDim, mh, mw] = proto.dims;

      const clsCount = ch - 4 - 1 - maskDim; const stride = ch;
      const candidates = [];
      for(let i=0;i<num;i++){
        const off = i*stride; const cx=detData[off+0], cy=detData[off+1], bw=detData[off+2], bh=detData[off+3];
        const conf = detData[off+4]; if(conf<0.2) continue;
        // class scores
        let bestCls=-1, bestSc=-1; for(let c=0;c<clsCount;c++){ const sc = detData[off+5+c]; if(sc>bestSc){ bestSc = sc; bestCls = c; } }
        let score = conf * bestSc;
        const clsName = COCO80[bestCls] || `cls${bestCls}`;
        score *= promptWeightForClassName(clsName, prompt||'');
        if(score < 0.25) continue;
        const coeff = detData.slice(off+5+clsCount, off+5+clsCount+maskDim);
        const x1 = cx - bw/2, y1 = cy - bh/2, x2 = cx + bw/2, y2 = cy + bh/2;
        candidates.push({x1,y1,x2,y2, score, coeff});
      }

      // NMS
      candidates.sort((a,b)=>b.score-a.score);
      const keep=[]; const iouThr=0.5;
      for(const a of candidates){
        let ok=true; for(const b of keep){ if(IOU(a,b)>iouThr){ ok=false; break; } }
        if(ok) keep.push(a); if(keep.length>30) break;
      }
      if(keep.length===0) return null;

      // Decode masks and pick by seed proximity / inclusion
      const chosen = await decodeYOLOMaskAndChoose(keep, protoData, maskDim, mw, mh, inputSize, scale, dx, dy, img.width, img.height, seed);
      return chosen;
    }
    function IOU(a,b){ const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1); const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
      const w=Math.max(0, xx2-xx1), h=Math.max(0, yy2-yy1); const inter=w*h; const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1); return inter/Math.max(1e-6, areaA+areaB-inter); }

    async function decodeYOLOMaskAndChoose(keep, protoData, maskDim, mw, mh, inputSize, scale, dx, dy, outW, outH, seed){
      // proto matrix P: [maskDim, mh*mw]
      const P = new Float32Array(protoData.length); P.set(protoData);
      let bestCanvas=null, bestScore=-1;
      for(const det of keep){
        const c = det.coeff;
        const m = new Float32Array(mw*mh);
        for(let i=0;i<mw*mh;i++){ let s=0; for(let k=0;k<maskDim;k++){ s += P[k*mw*mh + i] * c[k]; } m[i] = 1/(1+Math.exp(-s)); }

        // upsample to input space
        const small=document.createElement('canvas'); small.width=mw; small.height=mh; const sctx=small.getContext('2d'); const id=sctx.createImageData(mw,mh);
        for(let i=0;i<mw*mh;i++){ const v=Math.round(255*clamp(m[i],0,1)); id.data[i*4]=255; id.data[i*4+1]=255; id.data[i*4+2]=255; id.data[i*4+3]=v; } sctx.putImageData(id,0,0);

        const maskCanvas=document.createElement('canvas'); maskCanvas.width=outW; maskCanvas.height=outH; const mctx=maskCanvas.getContext('2d');
        mctx.clearRect(0,0,outW,outH); mctx.drawImage(small, 0,0, inputSize,inputSize, -dx, -dy, inputSize/scale, inputSize/scale);

        // choose by seed inclusion or center proximity
        let score = det.score;
        if(seed && maskHit(maskCanvas, seed.x, seed.y)){ score += 0.5; } // prefer inclusion
        else if(seed){
          const cx = (det.x1+det.x2)/2, cy = (det.y1+det.y2)/2;
          const dist = Math.hypot(seed.x - (cx-dx)/scale, seed.y - (cy-dy)/scale);
          score = score / (1 + 0.002*dist);
        }
        if(score>bestScore){ bestScore=score; bestCanvas=maskCanvas; }
      }
      return bestCanvas;
    }

    function makeLetterboxInput(img, size){
      const srcCanvas = document.createElement('canvas'); srcCanvas.width=size; srcCanvas.height=size; const sctx=srcCanvas.getContext('2d');
      sctx.fillStyle='#000'; sctx.fillRect(0,0,size,size);
      const r = Math.min(size/img.width, size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r);
      const dx=Math.floor((size - nw)/2), dy=Math.floor((size - nh)/2); sctx.drawImage(img, dx, dy, nw, nh);
      const iData = sctx.getImageData(0,0,size,size).data; const input = new Float32Array(size*size*3);
      for(let i=0,j=0;i<iData.length;i+=4){ input[j++]=iData[i]/255; input[j++]=iData[i+1]/255; input[j++]=iData[i+2]/255; }
      const nhwc = new ort.Tensor('float32', input, [1,size,size,3]);
      return {tensor: nhwc, scale:r, dx, dy};
    }
    function getFirstInputName(session){ try{ return session.inputNames?.[0]; }catch{ return null; } }
    function pickFirstTensor(outputs){ const names=Object.keys(outputs); return outputs[names[0]]; }
    function pickSecondTensor(outputs){ const names=Object.keys(outputs); return outputs[names[1]]; }

    // -------------------------- MobileSAM (best-effort) --------------------------
    async function segWithMobileSAM(session, img, inputSize, seed){
      try{
        if(!seed) throw new Error('MobileSAM needs a point prompt');
        const {normTensor, meta} = prepareSAMInput(img, inputSize);
        const point = new ort.Tensor('float32', new Float32Array([seed.x/meta.W, seed.y/meta.H]), [1,2]);
        const feeds = {};
        const names = session.inputNames || [];
        const imgName = names.find(n=>/image|input/i.test(n)) || 'input_image'; feeds[imgName] = normTensor;
        const pn = names.find(n=>/point|coords/i.test(n)) || 'point_coords'; feeds[pn] = point;

        const outputs = await session.run(feeds);
        const out = pickFirstTensor(outputs);
        const maskCanvas = tensorToMaskCanvas(out, meta.W, meta.H);
        if(maskCanvas) return maskCanvas; throw new Error('Unexpected MobileSAM output');
      }catch(err){
        log('MobileSAM failed, using EdgeGrow fallback:', err?.message||err);
        if(segReady){ await requestSegMask('autoSmart', seed.x, seed.y, state.tol, state.aggr); return null; }
        else{ return magicWandMask(img, seed.x, seed.y, state.tol/100, state.aggr); }
      }
    }
    function prepareSAMInput(img, size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d'); x.drawImage(img,0,0,size,size);
      const d=x.getImageData(0,0,size,size).data; const arr=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ arr[j++]=(d[i]/255 - 0.5)/0.5; arr[j++]=(d[i+1]/255 - 0.5)/0.5; arr[j++]=(d[i+2]/255 - 0.5)/0.5; }
      const t=new ort.Tensor('float32', arr, [1,size,size,3]);
      return {normTensor:t, meta:{W:img.width, H:img.height}};
    }
    function tensorToMaskCanvas(tensor, outW, outH){
      const data=tensor.data, dims=tensor.dims; let H=0,W=0;
      if(dims.length===4){ H=dims[2]||dims[1]; W=dims[3]||dims[2]; } else if(dims.length===3){ H=dims[1]; W=dims[2]; } else return null;
      const c=document.createElement('canvas'); c.width=outW; c.height=outH;
      const s=document.createElement('canvas'); s.width=W; s.height=H; const sx=s.getContext('2d'); const id=sx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=1/(1+Math.exp(-data[i])); const a=Math.round(255*clamp(v,0,1)); id.data[i*4]=255; id.data[i*4+1]=255; id.data[i*4+2]=255; id.data[i*4+3]=a; }
      sx.putImageData(id,0,0); const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(s, 0,0, W,H, 0,0, outW,outH); return c;
    }

    // -------------------------- DEPTH PREDICTION --------------------------
    async function depthPredict(session, img, inputSize){
      const {tensor, mapW, mapH} = prepareDepthInput(img, inputSize);
      const inputName = getFirstInputName(session) || 'input';
      const outputs = await session.run({[inputName]:tensor}); const out = pickFirstTensor(outputs);
      const dims = out.dims; let H = dims[dims.length-2], W = dims[dims.length-1]; if(!H||!W){ H = mapH; W = mapW; }
      const arr = out.data; let mn=Infinity, mx=-Infinity; for(let i=0;i<arr.length;i++){ const v=arr[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
      const range = mx-mn || 1;

      const small=document.createElement('canvas'); small.width=W; small.height=H; const sctx=small.getContext('2d'); const id=sctx.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const v=(arr[i]-mn)/range; const g=Math.round(255*v); id.data[i*4]=g; id.data[i*4+1]=g; id.data[i*4+2]=g; id.data[i*4+3]=255; } sctx.putImageData(id,0,0);
      const big=document.createElement('canvas'); big.width=img.width; big.height=img.height; const bctx=big.getContext('2d'); bctx.imageSmoothingEnabled=true; bctx.drawImage(small,0,0,W,H, 0,0, img.width, img.height);

      const map = new Float32Array(img.width*img.height); const bd=bctx.getImageData(0,0,img.width,img.height).data;
      for(let i=0,j=0;i<map.length;i++,j+=4) map[i] = bd[j]/255;
      return {canvas:big, map};
    }
    function prepareDepthInput(img, size){
      const c=document.createElement('canvas'); c.width=size; c.height=size; const x=c.getContext('2d');
      const r=Math.min(size/img.width, size/img.height); const nw=Math.round(img.width*r), nh=Math.round(img.height*r);
      const dx=Math.floor((size - nw)/2), dy=Math.floor((size - nh)/2);
      x.fillStyle='#000'; x.fillRect(0,0,size,size); x.drawImage(img, dx, dy, nw, nh);
      const d=x.getImageData(0,0,size,size).data; const arr=new Float32Array(size*size*3);
      for(let i=0,j=0;i<d.length;i+=4){ arr[j++]= d[i]/255; arr[j++]= d[i+1]/255; arr[j++]= d[i+2]/255; }
      const t=new ort.Tensor('float32', arr, [1,size,size,3]); return {tensor:t, mapW:size, mapH:size};
    }

    // -------------------------- FANCY SUGGESTIONS --------------------------
    function buildSuggestions(baseMask, depthMap, seed, W, H){
      // Utility: clone canvas
      const clone = (cnv)=>{ const c=document.createElement('canvas'); c.width=cnv.width; c.height=cnv.height; c.getContext('2d').drawImage(cnv,0,0); return c; };
      const blur = (cnv,r)=>{ const c=document.createElement('canvas'); c.width=cnv.width; c.height=cnv.height; const x=c.getContext('2d'); x.filter=`blur(${r}px)`; x.drawImage(cnv,0,0); x.filter='none'; return c; };
      const erode = (cnv,r)=>{ return blur(cnv, r); }; // cheap approximation; visual-only
      const dilate= (cnv,r)=>{ const c=blur(cnv,r); return c; };

      const suggestions = [];

      // 0) Base (raw)
      suggestions.push(makeSuggestion('Base', baseMask, 0));

      // 1) Depth-Intersect (narrow band)
      if(depthMap){
        const band = 0.06; const sd = depthMap[seed.y*W + seed.x]; const lo=Math.max(0, sd - band), hi=Math.min(1, sd + band);
        const dMask = maskFromDepth(depthMap, W, H, lo, hi);
        const inter = intersectMasks(baseMask, dMask);
        suggestions.push(makeSuggestion('Depth Band', inter, 1));
      }

      // 2) Edge-Refined (soft blur)
      suggestions.push(makeSuggestion('Edge Refine', blur(baseMask, 1.2), 2));

      // 3) Erode
      suggestions.push(makeSuggestion('Tighten', erode(baseMask, 1.8), 3));

      // 4) Dilate
      suggestions.push(makeSuggestion('Loosen', dilate(baseMask, 1.8), 4));

      return suggestions;

      function makeSuggestion(name, maskCanvas, idx){
        // Thumbnail canvas (same size as base internally; we scale when drawing)
        return { name, canvas: maskCanvas, fullMask: clone(maskCanvas), index: idx };
      }
    }

    function maskFromDepth(depthMap, W, H, lo, hi){
      const c=document.createElement('canvas'); c.width=W; c.height=H; const x=c.getContext('2d'); const id=x.createImageData(W,H);
      for(let i=0;i<W*H;i++){ const ok = (depthMap[i]>=lo && depthMap[i]<=hi) ? 255 : 0;
        id.data[i*4]=255; id.data[i*4+1]=255; id.data[i*4+2]=255; id.data[i*4+3]=ok; }
      x.putImageData(id,0,0); return c;
    }
    function intersectMasks(a, b){
      const W=a.width,H=a.height; const out=document.createElement('canvas'); out.width=W; out.height=H;
      const ax=a.getContext('2d').getImageData(0,0,W,H); const bx=b.getContext('2d').getImageData(0,0,W,H);
      const id=new ImageData(W,H);
      for(let i=0;i<id.data.length;i+=4){
        const va=ax.data[i+3], vb=bx.data[i+3], v = Math.min(va, vb);
        id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=v;
      }
      const ctx=out.getContext('2d'); ctx.putImageData(id,0,0); return out;
    }

    // -------------------------- APPLY INIT --------------------------
    function updateAIBottomVisibility(){ /* handled by setAIModeUI */ }

    // -------------------------- HELPERS --------------------------
    function setStatus(text){ dom.aiStatus.textContent = text; }

    // Kick things off
    backgroundPreload(state.ai.segModel); backgroundPreload(state.ai.depthModel);

  })();
  </script>
</body>
</html>
