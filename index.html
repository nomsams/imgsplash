<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Color Splash Pro X ‚Äî Stable AI Demo</title>

<!-- =========================================================
  v3.1.0 (Stable ‚ÄúGH‚ÜíDB, IDB cache, progress, 3 thumbs, edge-bound grow‚Äù)
  - GitHub Releases first (up to 3 direct attempts), then Dropbox DIRECT.
  - IndexedDB cache (‚Äúonnx‚Äù store). If cached ‚Üí no download.
  - Streaming download progress (bytes, %, MB/s), ‚Äúcompleted‚Äù notice.
  - Three mini-previews (Seg mask ‚Ä¢ Depth map ‚Ä¢ Final mask) under preview.
  - Black masks in thumbs for contrast.
  - Prompt UI (checkbox+input); disabled for current models (non-promptable).
  - Robust NCHW/NHWC input packing (fixes FastSAM-X input error).
  - Effects incl. ‚ÄúDepth+Edge-Bound Grow‚Äù (seed ‚Üí depth ‚Üí edges ‚Üí grow).
=========================================================== -->

<style>
  :root{
    --bg:#eef2f7; --panel:#fff; --ink:#0f172a; --muted:#475569; --border:#e5e7eb;
    --p:#2563eb; --p2:#1e40af; --ok:#16a34a; --warn:#f59e0b; --err:#dc2626;
  }
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--ink); background:var(--bg); display:flex; flex-direction:column; overflow:hidden}
  header{background:var(--panel); border-bottom:1px solid var(--border); display:flex; gap:.5rem; align-items:center; padding:.55rem .75rem; box-shadow:0 1px 8px rgba(0,0,0,.07); z-index:3}
  .brand{font-weight:800; color:var(--p)}
  .toolbar{display:flex; gap:.4rem; align-items:center; flex-wrap:wrap}
  button, select, input[type="number"], input[type="text"]{
    background:#fff; border:1px solid var(--border); border-radius:8px; padding:.38rem .58rem; font-weight:600;
  }
  button{cursor:pointer; box-shadow:0 1px 0 rgba(0,0,0,.02)}
  button:hover{border-color:#cfe0ff; background:#f9fbff}
  button.primary{background:var(--p); border-color:var(--p); color:#fff}
  button.primary:hover{background:var(--p2)}
  .chip{background:#f1f5f9; border:1px solid var(--border); color:#1f2937; font-size:.8rem; padding:.18rem .5rem; border-radius:999px}
  .bar{display:flex; gap:.45rem; align-items:center; flex-wrap:wrap; margin-left:.6rem}
  .kv{font-size:.75rem; color:#334155; background:#f8fafc; border:1px dashed #d1e3ff; padding:.1rem .35rem; border-radius:6px}
  .shell{flex:1; display:grid; grid-template-rows:auto 1fr; gap:10px; padding:10px; min-height:0}
  .row{min-height:0; display:grid; grid-template-columns:1fr 1fr; gap:10px}
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.06); display:flex; flex-direction:column; min-height:0}
  .panel-h{padding:.5rem .75rem; border-bottom:1px solid var(--border); font-weight:700; color:#334155}
  .panel-c{flex:1; min-height:0; position:relative; display:flex; align-items:center; justify-content:center; background:#e9eef6; overflow:hidden}
  .canvas-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center}
  #editorCanvas, #previewCanvas{position:absolute; left:0; top:0; background:#fff}
  .hint{position:absolute; pointer-events:none; color:#334155; background:#fff; border:1px solid var(--border); border-radius:999px; padding:.25rem .65rem}
  #thumbs{background:#fff; border-top:1px solid var(--border); display:grid; grid-template-columns:repeat(3,1fr); gap:8px; padding:8px}
  .thumb{display:flex; flex-direction:column; align-items:center; gap:4px}
  .thumb canvas{width:100%; max-width:200px; height:auto; border:1px solid var(--border); border-radius:8px; background:#fff}
  .cap{font-size:.78rem; color:#475569}
  #logFab{position:fixed; left:12px; bottom:12px; z-index:9; background:var(--p); color:#fff; border:none; border-radius:999px; padding:.6rem .85rem; font-weight:800; box-shadow:0 10px 26px rgba(0,0,0,.25)}
  #logs{position:fixed; left:12px; bottom:64px; width:520px; height:66vh; background:#fff; border:1px solid var(--border); border-radius:12px; box-shadow:0 16px 38px rgba(0,0,0,.25); display:none; grid-template-rows:auto auto 1fr auto}
  #logs.visible{display:grid}
  #logs h3{margin:.6rem .75rem}
  #logs .help{margin:0 .75rem .6rem; color:#334155; font-size:.86rem; background:#fafbff; border-top:1px solid var(--border); border-bottom:1px solid var(--border); padding:.5rem}
  #logs pre{margin:0; padding:.5rem .6rem; font-family:ui-monospace,Consolas,Menlo,monospace; font-size:.83rem; overflow:auto}
  #logs .foot{border-top:1px solid var(--border); display:grid; grid-template-columns:1fr 1fr 1fr; gap:.4rem; padding:.5rem .6rem}
  .progress{position:absolute; left:12px; right:12px; bottom:12px; height:8px; border-radius:6px; background:#eef2ff; border:1px solid #dde6ff; overflow:hidden; box-shadow:inset 0 1px 0 rgba(0,0,0,.03); display:none}
  .barp{height:100%; width:0%; background:linear-gradient(90deg,#7aa2ff,#2563eb)}
  .status{position:absolute; left:12px; bottom:28px; background:#111827; color:#fff; padding:.18rem .4rem; border-radius:6px; font-size:.72rem; opacity:.9}
  .ver{position:fixed; top:8px; right:8px; background:#111827; color:#fff; font-size:.72rem; padding:.22rem .45rem; border-radius:6px; opacity:.9; z-index:10}
  .hidden{display:none!important}
</style>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <div class="ver" id="ver">v3.1.0</div>
  <header>
    <div class="brand">Color Splash Pro X</div>

    <div class="toolbar">
      <button id="uploadImg" class="primary">üì§ Image</button>
      <button id="reset">üßπ Reset</button>
      <button id="download">‚¨áÔ∏è Download</button>
      <span class="chip" id="aiBadge">ü§ñ AI: ON</span>
    </div>

    <!-- Compact AI bar always visible -->
    <div class="bar" id="aiBar">
      <span class="chip">AI Controls</span>

      <label>Seg:</label>
      <select id="segSel"></select>

      <label>Depth:</label>
      <select id="depthSel"></select>

      <label>Effect:</label>
      <select id="effectSel">
        <option value="seg">Segmentation only</option>
        <option value="depth-band">Depth: seed band</option>
        <option value="depth-thresh">Depth: global threshold</option>
        <option value="edges">Edges: Sobel+Laplacian</option>
        <option value="seg-and-depth">Seg ‚à© Depth</option>
        <option value="seg-and-edges">Seg ‚à© Edges</option>
        <option value="seg-and-depth-and-edges">Seg ‚à© Depth ‚à© Edges</option>
        <option value="edge-bound-grow">Depth+Edge-Bound Grow (seed)</option>
      </select>

      <span class="kv">Band</span>
      <input id="band" type="range" min="0.01" max="0.25" step="0.005" value="0.07"/>

      <span class="kv">Depth T</span>
      <input id="depthT" type="range" min="0" max="1" step="0.01" value="0.5"/>

      <span class="kv">Edge T</span>
      <input id="edgeT" type="range" min="0.02" max="0.6" step="0.01" value="0.18"/>

      <span class="kv">Feather(px)</span>
      <input id="feather" type="number" min="0" max="12" step="1" value="2" style="width:68px"/>

      <label style="display:inline-flex;align-items:center;gap:.35rem">
        <input id="usePrompt" type="checkbox"/>
        <span>Prompt</span>
      </label>
      <input id="promptTxt" type="text" placeholder="text prompt (if supported)" style="width:200px" disabled/>

      <button id="run" class="primary">üöÄ Use</button>
      <span id="aiStatus" class="chip">ready</span>
    </div>
  </header>

  <div class="shell">
    <div class="row">
      <section class="panel">
        <div class="panel-h">ORIGINAL ‚Äî Editor (click seed ¬∑ Space=Pan ¬∑ Wheel=Zoom)</div>
        <div class="panel-c">
          <div class="canvas-wrap" id="edWrap">
            <canvas id="editorCanvas"></canvas>
            <div class="hint" id="edHint">Drop/upload an image</div>
          </div>
          <div class="progress" id="dlProg"><div class="barp" id="dlBar"></div></div>
          <div class="status hidden" id="dlStatus"></div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-h">PREVIEW ‚Äî Color Splash</div>
        <div class="panel-c" id="pvPanel">
          <div class="canvas-wrap" id="pvWrap">
            <canvas id="previewCanvas"></canvas>
          </div>
        </div>
        <div id="thumbs">
          <div class="thumb">
            <canvas id="thumbSeg"></canvas>
            <div class="cap">Segmentation Mask</div>
          </div>
          <div class="thumb">
            <canvas id="thumbDepth"></canvas>
            <div class="cap">Depth Map</div>
          </div>
          <div class="thumb">
            <canvas id="thumbFinal"></canvas>
            <div class="cap">Final Mask</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <button id="logFab">üí¨ Logs</button>
  <div id="logs">
    <h3>AI Logs & Model Manager</h3>
    <div class="help">
      GitHub Releases are tried first (up to 3 direct attempts). If they fail, we use your Dropbox DIRECT link.
      Models are cached in <b>IndexedDB</b>. If cached, they load instantly (no re-download).
    </div>
    <pre id="log"></pre>
    <div class="foot">
      <button id="clearLog">Clear Logs</button>
      <button id="clearCache">Clear Cache</button>
      <button id="selfTest">Self-Test Links</button>
    </div>
  </div>

  <input id="imgFile" class="hidden" type="file" accept="image/*"/>

<script>
(() => {
  'use strict';

  // ---------- DOM ----------
  const dom = {
    uploadImg: byId('uploadImg'),
    reset: byId('reset'),
    download: byId('download'),
    aiBadge: byId('aiBadge'),

    segSel: byId('segSel'),
    depthSel: byId('depthSel'),
    effectSel: byId('effectSel'),
    band: byId('band'),
    depthT: byId('depthT'),
    edgeT: byId('edgeT'),
    feather: byId('feather'),
    usePrompt: byId('usePrompt'),
    promptTxt: byId('promptTxt'),
    run: byId('run'),
    aiStatus: byId('aiStatus'),

    edWrap: byId('edWrap'),
    edCanvas: byId('editorCanvas'),
    edHint: byId('edHint'),
    pvWrap: byId('pvWrap'),
    pvCanvas: byId('previewCanvas'),

    dlProg: byId('dlProg'),
    dlBar: byId('dlBar'),
    dlStatus: byId('dlStatus'),

    logFab: byId('logFab'),
    logs: byId('logs'),
    log: byId('log'),
    clearLog: byId('clearLog'),
    clearCache: byId('clearCache'),
    selfTest: byId('selfTest'),

    imgFile: byId('imgFile'),

    thumbSeg: byId('thumbSeg'),
    thumbDepth: byId('thumbDepth'),
    thumbFinal: byId('thumbFinal'),
  };

  // ---------- STATE ----------
  const state = {
    aiOn: true,
    img: null,
    seed: null,
    ed: {x:0,y:0,s:1,panning:false,panStart:[0,0],tx:0,ty:0},
    segKey: 'edgegrow',
    depthKey: 'none',
    effect: 'seg',
    sessions: {},
    cacheBuffers: {},
    maskCanvas: null,
    depthCanvas: null,
    depthMap: null,
    supportsPrompt: false,
  };

  // ---------- MODELS (exact links as provided) ----------
  const MODELS = {
    // Seg
    'edgegrow': {type:'seg', label:'No model (EdgeGrow)', input:640, prompt:false},

    'gh-yolov8n-seg': {
      type:'seg', label:'YOLOv8n-seg (GitHub)', input:640, prompt:false,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/yolov8n-seg.onnx',
      db: 'https://dl.dropboxusercontent.com/scl/fi/g3hh1rpbn4es4pqbgypj8/yolov8n-seg.onnx?rlkey=0etbjr7tb8jsrctn2l3wv2amy&dl=1'
    },
    'db-yolov8n-seg': {
      type:'seg', label:'YOLOv8n-seg (Dropbox)', input:640, prompt:false,
      db: 'https://dl.dropboxusercontent.com/scl/fi/g3hh1rpbn4es4pqbgypj8/yolov8n-seg.onnx?rlkey=0etbjr7tb8jsrctn2l3wv2amy&dl=1'
    },

    'gh-fastsam-s': {
      type:'seg', label:'FastSAM-s (GitHub)', input:640, prompt:false,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/FastSAM-s.onnx',
      // optional DB alt if you add later:
      // db: '...'
    },
    'gh-fastsam-x': {
      type:'seg', label:'FastSAM-X (GitHub)', input:640, prompt:false,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/FastSam-X.onnx',
      db: 'https://dl.dropboxusercontent.com/scl/fi/hpwyjvgc9yl0mbf2ty9dr/FastSam-X.onnx?rlkey=i9kfkcucagp5tb4qm0m1fgwm5&dl=1'
    },
    'db-fastsam-x': {
      type:'seg', label:'FastSAM-X (Dropbox)', input:640, prompt:false,
      db: 'https://dl.dropboxusercontent.com/scl/fi/hpwyjvgc9yl0mbf2ty9dr/FastSam-X.onnx?rlkey=i9kfkcucagp5tb4qm0m1fgwm5&dl=1'
    },

    // Depth
    'none': {type:'depth', label:'None', input:256},
    'gh-midas-small': {
      type:'depth', label:'MiDaS v2.1 Small (GitHub)', input:256,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/midas_small.onnx',
      db: 'https://dl.dropboxusercontent.com/scl/fi/ljsrtwxbd5oscq6hgthrk/midas_small.onnx?rlkey=emtxd6xhxsjrpq8j2jbabqoxn&dl=1'
    },
    'db-midas-small': {
      type:'depth', label:'MiDaS v2.1 Small (Dropbox)', input:256,
      db: 'https://dl.dropboxusercontent.com/scl/fi/ljsrtwxbd5oscq6hgthrk/midas_small.onnx?rlkey=emtxd6xhxsjrpq8j2jbabqoxn&dl=1'
    },
    'gh-da-v2-small': {
      type:'depth', label:'Depth Anything v2 Small FP32 (GitHub)', input:518,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small.onnx',
      db: 'https://dl.dropboxusercontent.com/scl/fi/oif7z9iap5ua1wlef04e3/depth_anything_v2_small.onnx?rlkey=tfv2lz4xalrxp30fmoes006gy&dl=1'
    },
    'db-da-v2-small': {
      type:'depth', label:'Depth Anything v2 Small FP32 (Dropbox)', input:518,
      db: 'https://dl.dropboxusercontent.com/scl/fi/oif7z9iap5ua1wlef04e3/depth_anything_v2_small.onnx?rlkey=tfv2lz4xalrxp30fmoes006gy&dl=1'
    },
    'gh-da-v2-small-int8': {
      type:'depth', label:'Depth Anything v2 Small INT8 (GitHub)', input:518,
      gh: 'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small_int8.onnx',
      db: 'https://dl.dropboxusercontent.com/scl/fi/8brcbml22th9om9axdv5t/depth_anything_v2_small_int8.onnx?rlkey=rqkjeu0bd222xx9sr13qdywnz&dl=1'
    },
    'db-da-v2-small-int8': {
      type:'depth', label:'Depth Anything v2 Small INT8 (Dropbox)', input:518,
      db: 'https://dl.dropboxusercontent.com/scl/fi/8brcbml22th9om9axdv5t/depth_anything_v2_small_int8.onnx?rlkey=rqkjeu0bd222xx9sr13qdywnz&dl=1'
    }
  };

  // ---------- UI build ----------
  buildDropdown(dom.segSel, [
    'edgegrow','gh-yolov8n-seg','db-yolov8n-seg','gh-fastsam-s','gh-fastsam-x','db-fastsam-x'
  ]);
  buildDropdown(dom.depthSel, [
    'none','gh-midas-small','db-midas-small','gh-da-v2-small','db-da-v2-small','gh-da-v2-small-int8','db-da-v2-small-int8'
  ]);

  dom.segSel.value = state.segKey;
  dom.depthSel.value = state.depthKey;

  // ---------- Logging ----------
  function log(...a){
    const line = `[${new Date().toLocaleTimeString()}] ` + a.join(' ');
    dom.log.textContent += line + '\n';
    dom.log.scrollTop = dom.log.scrollHeight;
    console.debug(...a);
  }

  // ---------- Progress ----------
  function showProg(){ dom.dlProg.style.display='block'; dom.dlBar.style.width='0%'; }
  function setProg(p){ dom.dlBar.style.width = Math.max(0,Math.min(100,p)).toFixed(1) + '%'; }
  function hideProg(){ dom.dlProg.style.display='none'; }
  function showStatus(txt, ok=null){
    dom.dlStatus.textContent = txt;
    dom.dlStatus.classList.remove('hidden');
    dom.dlStatus.style.background = ok===true ? '#065f46' : ok===false ? '#7f1d1d' : '#111827';
    dom.dlStatus.style.color = '#fff';
  }
  function hideStatus(){ dom.dlStatus.classList.add('hidden'); }

  // ---------- IDB ----------
  let idb = null;
  async function idbOpen(){
    return new Promise((res,rej)=>{
      const req = indexedDB.open('cspx-models', 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains('onnx')) db.createObjectStore('onnx');
      };
      req.onsuccess = ()=>{ idb=req.result; res(); };
      req.onerror = ()=> rej(req.error);
    });
  }
  async function idbSet(key, buffer){
    if(!idb) await idbOpen();
    return new Promise((res,rej)=>{
      const tx = idb.transaction('onnx','readwrite');
      tx.objectStore('onnx').put(buffer, key);
      tx.oncomplete = res;
      tx.onerror = ()=> rej(tx.error);
    });
  }
  async function idbGet(key){
    if(!idb) await idbOpen();
    return new Promise((res,rej)=>{
      const tx = idb.transaction('onnx','readonly');
      const rq = tx.objectStore('onnx').get(key);
      rq.onsuccess = ()=> res(rq.result || null);
      rq.onerror = ()=> rej(rq.error);
    });
  }
  async function idbClear(){
    if(!idb) await idbOpen();
    return new Promise((res,rej)=>{
      const tx = idb.transaction('onnx','readwrite');
      const rq = tx.objectStore('onnx').clear();
      rq.onsuccess = res;
      rq.onerror = ()=> rej(rq.error);
    });
  }

  // ---------- Fetch (GH ‚Üí DB with progress) ----------
  async function fetchWithProgress(url){
    const t0 = performance.now();
    showProg(); setProg(0);
    log('Fetch:', url);
    const resp = await fetch(url, {mode:'cors', redirect:'follow', referrerPolicy:'no-referrer'});
    if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const len = +(resp.headers.get('Content-Length')||0);
    const reader = resp.body.getReader();
    let rec = 0;
    const chunks = [];
    while(true){
      const {value, done} = await reader.read();
      if(done) break;
      chunks.push(value);
      rec += value.byteLength;
      if(len) setProg((rec/len)*100);
      if(len){
        const mb = (rec/1048576).toFixed(2);
        const pct = ((rec/len)*100).toFixed(1);
        showStatus(`Downloading‚Ä¶ ${mb} MB (${pct}%)`);
      }else{
        const mb = (rec/1048576).toFixed(2);
        showStatus(`Downloading‚Ä¶ ${mb} MB`);
      }
    }
    const blob = new Blob(chunks);
    const ab = await blob.arrayBuffer();
    const t1 = performance.now();
    hideProg();
    const mb = (ab.byteLength/1048576).toFixed(2);
    const dt = ((t1-t0)/1000).toFixed(2);
    showStatus(`Downloaded ${mb} MB in ${dt}s`, true);
    log(`ONNX downloaded: ${mb} MB in ${dt}s`);
    return ab;
  }

  async function getModelBuffer(key){
    // 1) RAM cache
    if(state.cacheBuffers[key]) return state.cacheBuffers[key];

    // 2) IDB
    const ib = await idbGet(key);
    if(ib){
      log(`Loaded from IDB cache: ${key} (${Math.round(ib.byteLength/1024)} KB)`);
      const u8 = new Uint8Array(ib);
      state.cacheBuffers[key] = u8;
      return u8;
    }

    // 3) Download: GH (3 tries) ‚Üí DB
    const info = MODELS[key];
    if(!info) throw new Error('Unknown model key '+key);

    let ab = null;
    if(info.gh){
      for(let i=1;i<=3;i++){
        try{
          showStatus(`GitHub attempt ${i}/3‚Ä¶`);
          const buf = await fetchWithProgress(info.gh);
          ab = buf; break;
        }catch(e){
          log(`GitHub attempt ${i} failed: ${e.message||e}`);
          if(i<3) await sleep(350);
        }
      }
    }
    if(!ab && info.db){
      try{
        showStatus('Trying Dropbox...');
        ab = await fetchWithProgress(info.db);
      }catch(e){
        hideProg();
        showStatus(`Dropbox failed: ${e.message||e}`, false);
        throw e;
      }
    }
    if(!ab) throw new Error('No downloadable source for '+key);

    await idbSet(key, ab);
    const u8 = new Uint8Array(ab);
    state.cacheBuffers[key] = u8;
    return u8;
  }

  async function ensureSession(key){
    if(key==='edgegrow' || key==='none') return null;
    if(state.sessions[key]) return state.sessions[key];

    dom.aiStatus.textContent = `loading ${key}‚Ä¶`;
    try{
      const u8 = await getModelBuffer(key);
      const providers = await pickProviders();
      log(`Creating ORT session (${providers.join('+')}) for ${key}`);
      const sess = await ort.InferenceSession.create(u8, { executionProviders: providers, graphOptimizationLevel:'all' });
      state.sessions[key] = sess;
      dom.aiStatus.textContent = `loaded ${key}`;
      showStatus(`Model ready: ${MODELS[key].label}`, true);
      return sess;
    }catch(e){
      dom.aiStatus.textContent = `failed ${key}`;
      log(`Model load failed for ${key}:`, e?.message||e);
      showStatus(`Model failed: ${MODELS[key].label}`, false);
      throw e;
    }
  }

  async function pickProviders(){
    try{
      const adapter = await navigator.gpu?.requestAdapter();
      if(adapter && ort.env.webgpu) return ['webgpu','wasm'];
    }catch{}
    return ['wasm'];
  }

  // ---------- Editor / Preview ----------
  const ed = {
    c: dom.edCanvas, ctx: dom.edCanvas.getContext('2d'),
    updateSize(){
      const w = dom.edWrap.clientWidth, h = dom.edWrap.clientHeight;
      this.c.width = w; this.c.height = h;
    },
    fit(){
      if(!state.img) return;
      const iW = state.img.width, iH = state.img.height;
      const cW = dom.edWrap.clientWidth, cH = dom.edWrap.clientHeight;
      const s = Math.min(cW/iW, cH/iH)*0.98;
      state.ed.s = s; state.ed.x = (cW - iW*s)/2; state.ed.y = (cH - iH*s)/2;
    },
    toImageXY(clientX, clientY){
      const r = this.c.getBoundingClientRect();
      const cx = clientX - r.left, cy = clientY - r.top;
      const x = (cx - state.ed.x)/state.ed.s;
      const y = (cy - state.ed.y)/state.ed.s;
      return {x,y};
    },
    draw(){
      const {ctx,c} = this;
      ctx.clearRect(0,0,c.width,c.height);
      if(!state.img) return;
      ctx.save();
      ctx.translate(state.ed.x, state.ed.y);
      ctx.scale(state.ed.s, state.ed.s);
      ctx.drawImage(state.img, 0,0);
      if(state.seed){
        ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 1/state.ed.s;
        ctx.beginPath();
        ctx.moveTo(state.seed.x-12, state.seed.y); ctx.lineTo(state.seed.x+12, state.seed.y);
        ctx.moveTo(state.seed.x, state.seed.y-12); ctx.lineTo(state.seed.x, state.seed.y+12);
        ctx.stroke();
      }
      ctx.restore();
    }
  };

  const pv = {
    c: dom.pvCanvas, ctx: dom.pvCanvas.getContext('2d'),
    layout(){
      if(!state.img) return;
      const rect = dom.pvWrap.getBoundingClientRect();
      const availW = rect.width, availH = rect.height;
      const asp = state.img.width/state.img.height;
      let w = availW, h = w/asp; if(h>availH){ h = availH; w = h*asp; }
      this.c.width = Math.round(w); this.c.height = Math.round(h);
      this.c.style.left = ((availW - this.c.width)/2) + 'px';
      this.c.style.top  = ((availH - this.c.height)/2) + 'px';
    },
    render(){
      if(!state.img) return;
      const {ctx,c} = this;
      ctx.clearRect(0,0,c.width,c.height);

      // background grayscale
      const tmp = makeCanvas(state.img.width, state.img.height);
      const tx = tmp.getContext('2d');
      tx.drawImage(state.img,0,0);
      const im = tx.getImageData(0,0,tmp.width,tmp.height);
      const d = im.data;
      for(let i=0;i<d.length;i+=4){
        const y = Math.round(0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]);
        d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255;
      }
      tx.putImageData(im,0,0);
      ctx.drawImage(tmp, 0,0, c.width,c.height);

      // foreground via final mask
      const mask = buildFinalMaskFullRes();
      const fg = makeCanvas(state.img.width, state.img.height);
      const fx = fg.getContext('2d');
      fx.drawImage(state.img,0,0);
      fx.globalCompositeOperation='destination-in';
      fx.drawImage(mask,0,0);
      ctx.drawImage(fg, 0,0, c.width,c.height);

      // thumbs
      drawThumbs(mask);
    }
  };

  // ---------- Helpers ----------
  function byId(s){return document.getElementById(s)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function sleep(ms){return new Promise(r=>setTimeout(r,ms))}
  function makeCanvas(w,h){const c=document.createElement('canvas'); c.width=w; c.height=h; return c;}

  function drawThumbs(finalMask){
    const w = state.img.width, h = state.img.height;

    // Segmentation thumb (black mask)
    const sctx = dom.thumbSeg.getContext('2d');
    const tw = dom.thumbSeg.width = 200;
    const th = dom.thumbSeg.height = Math.max(1, Math.round(tw*(h/w)));
    sctx.fillStyle = '#fff'; sctx.fillRect(0,0,tw,th);
    if(state.maskCanvas){
      // draw as black on white
      const tmp = makeCanvas(w,h), x = tmp.getContext('2d');
      x.drawImage(state.maskCanvas,0,0);
      const id = x.getImageData(0,0,w,h);
      const d = id.data;
      for(let i=0;i<d.length;i+=4){ const a=d[i+3]; d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=a?255:0; }
      x.putImageData(id,0,0);
      sctx.imageSmoothingEnabled = false;
      sctx.drawImage(tmp, 0,0,w,h, 0,0, tw,th);
    }

    // Depth thumb (grayscale)
    const dctx = dom.thumbDepth.getContext('2d');
    const tw2 = dom.thumbDepth.width = 200;
    const th2 = dom.thumbDepth.height = Math.max(1, Math.round(tw2*(h/w)));
    dctx.fillStyle='#fff'; dctx.fillRect(0,0,tw2,th2);
    if(state.depthCanvas){
      dctx.imageSmoothingEnabled=false;
      dctx.drawImage(state.depthCanvas, 0,0,w,h, 0,0, tw2,th2);
    } else {
      // fallback: blurred gray
      dctx.fillStyle='#cbd5e1'; dctx.fillRect(0,0,tw2,th2);
    }

    // Final mask thumb (black mask)
    const fctx = dom.thumbFinal.getContext('2d');
    const tw3 = dom.thumbFinal.width = 200;
    const th3 = dom.thumbFinal.height = Math.max(1, Math.round(tw3*(h/w)));
    fctx.fillStyle='#fff'; fctx.fillRect(0,0,tw3,th3);
    if(finalMask){
      const tmp2 = makeCanvas(w,h), x2 = tmp2.getContext('2d');
      x2.drawImage(finalMask,0,0);
      const id2 = x2.getImageData(0,0,w,h), dd=id2.data;
      for(let i=0;i<dd.length;i+=4){ const a=dd[i+3]; dd[i]=0; dd[i+1]=0; dd[i+2]=0; dd[i+3]=a?255:0; }
      x2.putImageData(id2,0,0);
      fctx.imageSmoothingEnabled=false;
      fctx.drawImage(tmp2, 0,0,w,h, 0,0, tw3,th3);
    }
  }

  // ---------- Build final mask from current effect ----------
  function buildFinalMaskFullRes(){
    const W = state.img.width, H = state.img.height;
    const effect = state.effect;
    const seg = state.maskCanvas;
    const depth = state.depthMap;
    const feather = clamp(parseInt(dom.feather.value||'2',10),0,12);

    let segMask = seg || null;
    let depthMask = null;
    let edgesMask = null;

    if(effect==='depth-band' || effect==='seg-and-depth' || effect==='seg-and-depth-and-edges' || effect==='edge-bound-grow'){
      if(depth) depthMask = makeDepthBandMask(depth, W,H, state.seed, parseFloat(dom.band.value||'0.07'));
    }
    if(effect==='depth-thresh'){
      if(depth) depthMask = makeDepthThresholdMask(depth, W,H, parseFloat(dom.depthT.value||'0.5'), true);
    }
    if(effect==='edges' || effect==='seg-and-edges' || effect==='seg-and-depth-and-edges' || effect==='edge-bound-grow'){
      edgesMask = makeEdgesMask(state.img, parseFloat(dom.edgeT.value||'0.18'));
    }

    let finalMask = null;
    switch(effect){
      case 'seg': finalMask = segMask || edgeGrowMask(state.img, state.seed?.x ?? (W>>1), state.seed?.y ?? (H>>1)); break;
      case 'depth-band':
      case 'depth-thresh': finalMask = depthMask || emptyMask(W,H); break;
      case 'edges': finalMask = edgesMask || emptyMask(W,H); break;
      case 'seg-and-depth': finalMask = intersectMasks(segMask, depthMask) || segMask || depthMask || emptyMask(W,H); break;
      case 'seg-and-edges': finalMask = intersectMasks(segMask, edgesMask) || segMask || edgesMask || emptyMask(W,H); break;
      case 'seg-and-depth-and-edges': {
        const s_d = intersectMasks(segMask, depthMask);
        finalMask = intersectMasks(s_d, edgesMask) || s_d || segMask || depthMask || edgesMask || emptyMask(W,H);
        break;
      }
      case 'edge-bound-grow': {
        finalMask = edgeBoundGrowMask(state.img, state.seed, depth, parseFloat(dom.band.value||'0.07'), parseFloat(dom.edgeT.value||'0.18'));
        break;
      }
      default: finalMask = segMask || emptyMask(W,H);
    }

    if(feather>0){
      const out = makeCanvas(W,H), ox=out.getContext('2d');
      ox.filter = `blur(${feather}px)`; ox.drawImage(finalMask,0,0); ox.filter='none';
      return out;
    }
    return finalMask;
  }

  function emptyMask(W,H){ const c=makeCanvas(W,H); return c; }
  function unionMasks(a,b){
    if(!a && !b) return null; if(a && !b) return a; if(!a && b) return b;
    const W=a.width,H=a.height, out=makeCanvas(W,H), x=out.getContext('2d');
    x.drawImage(a,0,0); x.globalCompositeOperation='destination-over'; x.drawImage(b,0,0); return out;
  }
  function intersectMasks(a,b){
    if(!a || !b) return null;
    const W=a.width,H=a.height, out=makeCanvas(W,H), x=out.getContext('2d');
    x.drawImage(a,0,0); x.globalCompositeOperation='destination-in'; x.drawImage(b,0,0); return out;
  }

  // ---------- Depth utilities ----------
  function makeDepthBandMask(depthMap, W,H, seed, band){
    if(!seed) return null;
    const sd = depthMap[seed.y*W + seed.x];
    const lo = Math.max(0, sd - band), hi = Math.min(1, sd + band);
    const c = makeCanvas(W,H), x = c.getContext('2d'), id = x.createImageData(W,H), d=id.data;
    for(let i=0;i<W*H;i++){
      const ok = (depthMap[i]>=lo && depthMap[i]<=hi) ? 255 : 0;
      const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=ok;
    }
    x.putImageData(id,0,0); return c;
  }
  function makeDepthThresholdMask(depthMap, W,H, thr, near=true){
    const c = makeCanvas(W,H), x=c.getContext('2d'), id=x.createImageData(W,H), d=id.data;
    for(let i=0;i<W*H;i++){
      const v = depthMap[i];
      const ok = near ? (v<=thr) : (v>=thr);
      const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=ok?255:0;
    }
    x.putImageData(id,0,0); return c;
  }

  // ---------- Edges: Sobel + Laplacian + Canny-lite ----------
  function makeEdgesMask(img, thr=0.18){
    const W=img.width,H=img.height, maxSide=1024, scale=Math.min(1, maxSide/Math.max(W,H));
    const sw=Math.max(1,Math.round(W*scale)), sh=Math.max(1,Math.round(H*scale));
    const sC=makeCanvas(sw,sh), sx=sC.getContext('2d'); sx.drawImage(img,0,0,sw,sh);
    const src = sx.getImageData(0,0,sw,sh).data;
    const gray = new Float32Array(sw*sh);
    for(let i=0,j=0;i<gray.length;i++,j+=4){ gray[i]=(0.2126*src[j]+0.7152*src[j+1]+0.0722*src[j+2])/255; }

    // Sobel
    const sob = new Float32Array(sw*sh);
    const gxK=[-1,0,1,-2,0,2,-1,0,1], gyK=[-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<sh-1;y++){
      for(let x=1;x<sw-1;x++){
        let gx=0,gy=0, p=0;
        for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++){
          const v=gray[(y+ky)*sw + (x+kx)];
          const i=(p++); gx += v*gxK[i]; gy += v*gyK[i];
        }
        sob[y*sw+x]=Math.hypot(gx,gy)/4;
      }
    }
    // Laplacian
    const lap = new Float32Array(sw*sh);
    const lK=[0,1,0,1,-4,1,0,1,0];
    for(let y=1;y<sh-1;y++){
      for(let x=1;x<sw-1;x++){
        let s=0,p=0;
        for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++){
          const v=gray[(y+ky)*sw + (x+kx)];
          const i=(p++); s+=v*lK[i];
        }
        lap[y*sw+x]=Math.abs(s);
      }
    }
    // Simple Canny-lite magnitude (just reuse sobel mag)
    const mag = sob;

    // Combine
    let mn=Infinity,mx=-Infinity;
    for(let i=0;i<gray.length;i++){
      const v = 0.6*mag[i] + 0.4*lap[i];
      if(v<mn) mn=v; if(v>mx) mx=v;
    }
    const rng=mx-mn || 1;

    const maskSmall = makeCanvas(sw,sh), msx=maskSmall.getContext('2d'), id=msx.createImageData(sw,sh), d=id.data;
    for(let i=0;i<gray.length;i++){
      const v=(0.6*mag[i] + 0.4*lap[i] - mn)/rng;
      const a = v>=thr ? 255 : 0;
      const o=i*4; d[o]=255; d[o+1]=255; d[o+2]=255; d[o+3]=a;
    }
    msx.putImageData(id,0,0);

    const mFull = makeCanvas(W,H), fx=mFull.getContext('2d'); fx.imageSmoothingEnabled=false;
    fx.drawImage(maskSmall,0,0,sw,sh, 0,0,W,H);
    return mFull;
  }

  // ---------- Edge-bounded region grow using depth + edges ----------
  function edgeBoundGrowMask(img, seed, depthMap, band=0.07, edgeThr=0.18){
    const W=img.width,H=img.height;
    if(!seed) return emptyMask(W,H);

    // edges at full-res (but internally downsampled)
    const edges = makeEdgesMask(img, edgeThr);
    const ex = edges.getContext('2d');
    const edata = ex.getImageData(0,0,W,H).data;

    // optional depth band
    let lo=-1, hi=2;
    if(depthMap){
      const sd = depthMap[seed.y*W + seed.x];
      lo = Math.max(0, sd-band); hi = Math.min(1, sd+band);
    }

    // seed color
    const tmp = makeCanvas(W,H), tx=tmp.getContext('2d');
    tx.drawImage(img,0,0); const src = tx.getImageData(0,0,W,H); const d=src.data;
    const p = 4*(seed.y*W + seed.x);
    const r0=d[p],g0=d[p+1],b0=d[p+2];

    // grow until hitting strong edges or depth outside band
    const tol = 28;
    const out = new Uint8Array(W*H);
    const stack=[[seed.x,seed.y]];
    out[seed.y*W+seed.x]=1;

    while(stack.length){
      const [x,y] = stack.pop();
      for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        const idx = ny*W+nx; if(out[idx]) continue;

        // edge stop
        const eA = edata[idx*4+3]; if(eA>0){ continue; }

        // depth band filter
        if(depthMap){
          const v = depthMap[idx];
          if(v<lo || v>hi) continue;
        }

        // color similarity
        const q = 4*idx;
        const dr=d[q]-r0, dg=d[q+1]-g0, db=d[q+2]-b0;
        if(Math.sqrt(dr*dr+dg*dg+db*db) <= tol){
          out[idx]=1; stack.push([nx,ny]);
        }
      }
    }

    const m=makeCanvas(W,H), mx=m.getContext('2d'), id=mx.createImageData(W,H), md=id.data;
    for(let i=0;i<W*H;i++){ const a=out[i]?255:0; const o=i*4; md[o]=255; md[o+1]=255; md[o+2]=255; md[o+3]=a; }
    mx.putImageData(id,0,0);
    return m;
  }

  // ---------- Simple flood grow (no edges) ----------
  function edgeGrowMask(img, sx, sy){
    const W=img.width,H=img.height, maxSide=1024, scale=Math.min(1, maxSide/Math.max(W,H));
    const sw=Math.max(1,Math.round(W*scale)), sh=Math.max(1,Math.round(H*scale));
    const sC=makeCanvas(sw,sh), sx2=sC.getContext('2d'); sx2.drawImage(img,0,0,sw,sh);
    const src = sx2.getImageData(0,0,sw,sh).data;
    const seedX = clamp(Math.round(sx*scale),0,sw-1), seedY=clamp(Math.round(sy*scale),0,sh-1);
    const p = 4*(seedY*sw + seedX), r0=src[p],g0=src[p+1],b0=src[p+2];
    const tol=28, out=new Uint8Array(sw*sh), st=[[seedX,seedY]]; out[seedY*sw+seedX]=1;

    while(st.length){
      const [x,y]=st.pop();
      for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
        if(nx<0||ny<0||nx>=sw||ny>=sh) continue;
        const id=ny*sw+nx; if(out[id]) continue;
        const q=4*id;
        const dr=src[q]-r0,dg=src[q+1]-g0,db=src[q+2]-b0;
        if(Math.sqrt(dr*dr+dg*dg+db*db)<=tol){
          out[id]=1; st.push([nx,ny]);
        }
      }
    }

    const ms=makeCanvas(sw,sh), msx=ms.getContext('2d'), id=msx.createImageData(sw,sh), d2=id.data;
    for(let i=0;i<sw*sh;i++){ const a=out[i]?255:0; const o=i*4; d2[o]=255; d2[o+1]=255; d2[o+2]=255; d2[o+3]=a; }
    msx.putImageData(id,0,0);
    const mf=makeCanvas(W,H), fx=mf.getContext('2d'); fx.imageSmoothingEnabled=false; fx.drawImage(ms,0,0,sw,sh, 0,0,W,H);
    return mf;
  }

  // ---------- Segmentation inference (YOLO/FSAM ‚Äî robust packing) ----------
  async function runSegmentation(session, key, img, seed){
    const info = MODELS[key] || {input:640};
    const size = info.input || 640;

    // Determine input meta (NHWC or NCHW)
    const inputName = session.inputNames[0];
    const meta = session.inputMetadata?.[inputName];
    const dims = meta?.dimensions || meta?.dims || [];

    const pack = makeLetterboxInputFlex(img, size, dims);

    const outputs = await session.run({[inputName]: pack.tensor});
    const names = Object.keys(outputs);
    // find proto (rank 4) and det (rank 3 or 2)
    let proto=null, det=null;
    for(const n of names){
      const t = outputs[n];
      const rank = t.dims.length;
      if(rank===4) proto = t;
      else det = t;
    }
    if(!proto || !det) throw new Error('Unexpected seg outputs');

    // Decode YOLOv8-seg style
    const mask = await decodeYOLOMaskChoose(det, proto, size, pack.scale, pack.dx, pack.dy, img.width, img.height, seed);
    return mask;
  }

  function makeLetterboxInputFlex(img, size, dims){
    // dims could be [1,3,640,640] or [1,640,640,3] or contain -1
    // decide nchw if second dim == 3, nhwc if last dim == 3
    const isNCHW = dims && dims.length===4 && (dims[1]===3 || (dims[1]===-1 && dims[3]!==3));
    const c = makeCanvas(size,size), x=c.getContext('2d');
    x.fillStyle='#000'; x.fillRect(0,0,size,size);
    const r = Math.min(size/img.width, size/img.height);
    const nw=Math.round(img.width*r), nh=Math.round(img.height*r);
    const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
    x.drawImage(img, dx,dy,nw,nh);
    const id = x.getImageData(0,0,size,size).data;

    if(isNCHW){
      const arr = new Float32Array(1*3*size*size);
      // NCHW: [1,3,H,W] RGB
      let oR=0, oG=size*size, oB=2*size*size;
      for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
          const p = (y*size + x)*4;
          arr[oR++] = id[p]/255;
          arr[oG++] = id[p+1]/255;
          arr[oB++] = id[p+2]/255;
        }
      }
      const tensor = new ort.Tensor('float32', arr, [1,3,size,size]);
      return {tensor, scale:r, dx, dy, layout:'nchw'};
    }else{
      // NHWC default
      const arr = new Float32Array(size*size*3);
      let j=0;
      for(let i=0;i<id.length;i+=4){ arr[j++]=id[i]/255; arr[j++]=id[i+1]/255; arr[j++]=id[i+2]/255; }
      const tensor = new ort.Tensor('float32', arr, [1,size,size,3]);
      return {tensor, scale:r, dx, dy, layout:'nhwc'};
    }
  }

  function IOU(a,b){
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h, areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
    return inter / Math.max(1e-6, areaA+areaB-inter);
  }
  function nms(cand, iouThr){
    const keep=[];
    for(const a of cand){
      let ok=true;
      for(const b of keep){ if(IOU(a,b)>iouThr){ok=false; break;} }
      if(ok) keep.push(a);
    }
    return keep;
  }

  async function decodeYOLOMaskChoose(det, proto, inputSize, scale, dx, dy, outW, outH, seed){
    // det could be shape [1, N, C] or [1, C, N]
    const dd = det.data, ds = det.dims;
    let N, C, major; // major: which axis is channels
    if(ds.length===3){
      // choose orientation
      if(ds[1] > ds[2]){ C=ds[1]; N=ds[2]; major=1; } else { C=ds[2]; N=ds[1]; major=2; }
    }else{ throw new Error('Unsupported det shape'); }

    const protoData = proto.data, ps = proto.dims; // [1, M, Hm, Wm]
    const M = ps[1], Hm = ps[2], Wm = ps[3];

    const getVector = (i) => {
      // return vector of length C for candidate i (anchor i)
      const v = new Float32Array(C);
      if(major===1){
        for(let c=0;c<C;c++) v[c] = dd[c*N + i];
      }else{
        for(let c=0;c<C;c++) v[c] = dd[i*C + c];
      }
      return v;
    };

    const maskDim = M; // prototypes
    const clsCount = Math.max(0, C - 4 - 1 - maskDim);
    const cand = [];
    for(let i=0;i<N;i++){
      const vec = getVector(i);
      const cx = vec[0], cy = vec[1], bw = vec[2], bh = vec[3];
      const conf = vec[4];
      if(conf < 0.2) continue;
      let best=-1, bsc=-1;
      for(let c=0;c<clsCount;c++){
        const sc = vec[5+c];
        if(sc>bsc){ bsc=sc; best=c; }
      }
      const score = conf * (bsc>0?bsc:1);
      if(score < 0.25) continue;
      const coeff = vec.slice(5+clsCount, 5+clsCount+maskDim);
      const x1=cx - bw/2, y1=cy - bh/2, x2=cx + bw/2, y2=cy + bh/2;
      cand.push({x1,y1,x2,y2,score,coeff});
    }
    cand.sort((a,b)=> b.score-a.score);
    const keep = nms(cand, 0.5).slice(0,30);
    if(keep.length===0) return null;

    // proto to flat [M, Hm*Wm]
    const P = new Float32Array(M*Hm*Wm);
    P.set(protoData);

    let bestCanvas=null, bestScore=-1;
    for(const det of keep){
      const c = det.coeff;
      const flat = new Float32Array(Hm*Wm);
      for(let i=0;i<Hm*Wm;i++){
        let s=0;
        for(let k=0;k<maskDim;k++){ s += P[k*Hm*Wm + i] * c[k]; }
        flat[i] = 1/(1+Math.exp(-s));
      }

      const small = makeCanvas(Wm,Hm), sx=small.getContext('2d');
      const id = sx.createImageData(Wm,Hm);
      for(let i=0;i<Hm*Wm;i++){
        const a = Math.round(255*clamp(flat[i],0,1));
        const o=i*4; id.data[o]=255; id.data[o+1]=255; id.data[o+2]=255; id.data[o+3]=a;
      }
      sx.putImageData(id,0,0);

      const big = makeCanvas(outW,outH), bx=big.getContext('2d');
      // place using letterbox reverse mapping
      bx.drawImage(small, 0,0, inputSize,inputSize, -dx, -dy, inputSize/scale, inputSize/scale);

      if(seed){
        if(maskHit(big, seed.x, seed.y)){ bestCanvas = big; break; }
        // fallback: choose by proximity *and* score
        const cx = (det.x1+det.x2)/2, cy=(det.y1+det.y2)/2;
        const dist = Math.hypot(seed.x - (cx - dx)/scale, seed.y - (cy - dy)/scale);
        const sc = det.score / (1 + 0.002*dist);
        if(sc>bestScore){ bestScore=sc; bestCanvas=big; }
      }else{
        if(det.score>bestScore){ bestScore=det.score; bestCanvas=big; }
      }
    }
    return bestCanvas;
  }

  function maskHit(maskCanvas, x, y){
    if(!maskCanvas) return false;
    const ctx = maskCanvas.getContext('2d');
    const d = ctx.getImageData(clamp(x|0,0,maskCanvas.width-1), clamp(y|0,0,maskCanvas.height-1), 1,1).data;
    return d[3] > 10;
  }

  // ---------- Depth inference ----------
  async function runDepth(session, key, img){
    const info = MODELS[key] || {input:256};
    const size = info.input || 256;

    const inputName = session.inputNames[0];
    const meta = session.inputMetadata?.[inputName];
    const dims = meta?.dimensions || meta?.dims || [];
    const isNCHW = dims && dims.length===4 && (dims[1]===3 || (dims[1]===-1 && dims[3]!==3));

    const c = makeCanvas(size,size), x=c.getContext('2d');
    x.fillStyle='#000'; x.fillRect(0,0,size,size);
    const r = Math.min(size/img.width, size/img.height);
    const nw=Math.round(img.width*r), nh=Math.round(img.height*r);
    const dx=Math.floor((size-nw)/2), dy=Math.floor((size-nh)/2);
    x.drawImage(img, dx,dy,nw,nh);
    const id = x.getImageData(0,0,size,size).data;

    let tensor=null;
    if(isNCHW){
      const arr = new Float32Array(1*3*size*size);
      let oR=0, oG=size*size, oB=2*size*size;
      for(let y=0;y<size;y++) for(let x=0;x<size;x++){
        const p=(y*size+x)*4; arr[oR++]=id[p]/255; arr[oG++]=id[p+1]/255; arr[oB++]=id[p+2]/255;
      }
      tensor = new ort.Tensor('float32', arr, [1,3,size,size]);
    }else{
      const arr = new Float32Array(size*size*3); let j=0;
      for(let i=0;i<id.length;i+=4){ arr[j++]=id[i]/255; arr[j++]=id[i+1]/255; arr[j++]=id[i+2]/255; }
      tensor = new ort.Tensor('float32', arr, [1,size,size,3]);
    }

    const out = await session.run({[inputName]: tensor});
    const first = out[Object.keys(out)[0]];
    const dimsOut = first.dims;
    let H,W,raw = first.data;
    if(dimsOut.length===4){ H=dimsOut[2]; W=dimsOut[3]; }
    else if(dimsOut.length===3){ H=dimsOut[1]; W=dimsOut[2]; }
    else throw new Error('Unexpected depth output shape');

    let mn=Infinity, mx=-Infinity;
    for(let i=0;i<raw.length;i++){ const v=raw[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
    const rng = mx-mn || 1;

    const small = makeCanvas(W,H), sx2=small.getContext('2d');
    const im2 = sx2.createImageData(W,H);
    for(let i=0;i<W*H;i++){
      const v = (raw[i]-mn)/rng; const g = Math.round(255*v);
      const o=i*4; im2.data[o]=g; im2.data[o+1]=g; im2.data[o+2]=g; im2.data[o+3]=255;
    }
    sx2.putImageData(im2,0,0);

    const big = makeCanvas(img.width,img.height), bx=big.getContext('2d');
    bx.imageSmoothingEnabled=true; bx.drawImage(small,0,0,W,H, 0,0,img.width,img.height);

    const map = new Float32Array(img.width*img.height);
    const bd = bx.getImageData(0,0,img.width,img.height).data;
    for(let i=0,j=0;i<map.length;i++,j+=4) map[i] = bd[j]/255;

    return {canvas:big, map};
  }

  // ---------- Pipeline ----------
  async function runPipeline(){
    if(!state.img || !state.seed) return;
    dom.aiStatus.textContent = 'processing‚Ä¶';
    showStatus('Generating‚Ä¶');

    // SEG
    let segMask = null;
    try{
      if(state.segKey==='edgegrow'){
        segMask = edgeGrowMask(state.img, state.seed.x, state.seed.y);
      }else{
        const s = await ensureSession(state.segKey);
        segMask = await runSegmentation(s, state.segKey, state.img, state.seed);
        if(!segMask){
          log('Seg produced no mask; fallback to EdgeGrow');
          segMask = edgeGrowMask(state.img, state.seed.x, state.seed.y);
        }
      }
    }catch(e){
      log('Segmentation failed, fallback EdgeGrow:', e.message||e);
      segMask = edgeGrowMask(state.img, state.seed.x, state.seed.y);
    }
    state.maskCanvas = segMask;

    // DEPTH
    let depthCanvas=null, depthMap=null;
    try{
      if(state.depthKey!=='none' || state.effect.includes('depth') || state.effect==='edge-bound-grow'){
        if(state.depthKey==='none'){
          log('Depth not selected; depth-dependent steps will use no-depth.');
        }else{
          const d = await ensureSession(state.depthKey);
          const dep = await runDepth(d, state.depthKey, state.img);
          depthCanvas = dep.canvas; depthMap = dep.map;
        }
      }
    }catch(e){
      log('Depth failed; continuing without depth:', e.message||e);
    }
    state.depthCanvas = depthCanvas; state.depthMap = depthMap;

    // PREVIEW
    pv.layout(); pv.render();
    dom.aiStatus.textContent = 'ready';
    showStatus('Done', true);
  }

  // ---------- Events ----------
  dom.uploadImg.addEventListener('click', ()=> dom.imgFile.click());
  dom.imgFile.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      const im = new Image();
      im.onload = ()=>{
        state.img = im; state.seed=null; state.maskCanvas=null; state.depthCanvas=null; state.depthMap=null;
        dom.edHint.classList.add('hidden');
        ed.updateSize(); ed.fit(); ed.draw(); pv.layout(); pv.render();
        log(`Image loaded: ${f.name} ${im.width}x${im.height}`);
      };
      im.src = r.result;
    };
    r.readAsDataURL(f);
  });

  dom.reset.addEventListener('click', ()=>{
    state.img=null; state.seed=null; state.maskCanvas=null; state.depthCanvas=null; state.depthMap=null;
    ed.updateSize(); ed.ctx.clearRect(0,0,ed.c.width,ed.c.height);
    dom.edHint.classList.remove('hidden');
    pv.ctx.clearRect(0,0,pv.c.width,pv.c.height);
  });

  dom.download.addEventListener('click', ()=>{
    if(!state.img){ alert('Upload an image first.'); return; }
    // render full-res composite and save
    const out = makeCanvas(state.img.width, state.img.height), ox=out.getContext('2d');
    // bg grayscale
    const tmp = makeCanvas(out.width,out.height), tx=tmp.getContext('2d'); tx.drawImage(state.img,0,0);
    const im = tx.getImageData(0,0,out.width,out.height); const d=im.data;
    for(let i=0;i<d.length;i+=4){ const y=Math.round(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]); d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255; }
    tx.putImageData(im,0,0); ox.drawImage(tmp,0,0);
    // fg
    const mask = buildFinalMaskFullRes();
    const fg = makeCanvas(out.width,out.height), fx=fg.getContext('2d'); fx.drawImage(state.img,0,0); fx.globalCompositeOperation='destination-in'; fx.drawImage(mask,0,0);
    ox.drawImage(fg,0,0);
    const a = document.createElement('a'); a.href = out.toDataURL('image/png'); a.download = `colorsplash-${Date.now()}.png`; a.click();
  });

  dom.segSel.addEventListener('change', ()=>{
    state.segKey = dom.segSel.value;
    const info = MODELS[state.segKey];
    state.supportsPrompt = !!info?.prompt;
    dom.promptTxt.disabled = !state.supportsPrompt || !dom.usePrompt.checked;
    log('Segmentation model:', state.segKey);
    // Preload (async)
    if(state.segKey!=='edgegrow') ensureSession(state.segKey).catch(e=>log('Seg preload failed:', e.message||e));
  });
  dom.depthSel.addEventListener('change', ()=>{
    state.depthKey = dom.depthSel.value;
    log('Depth model:', state.depthKey);
    if(state.depthKey!=='none') ensureSession(state.depthKey).catch(e=>log('Depth preload failed:', e.message||e));
  });
  dom.effectSel.addEventListener('change', ()=>{ state.effect = dom.effectSel.value; if(state.img){ pv.layout(); pv.render(); } });
  dom.band.addEventListener('input', ()=>{ if(state.img){ pv.layout(); pv.render(); } });
  dom.depthT.addEventListener('input', ()=>{ if(state.img){ pv.layout(); pv.render(); } });
  dom.edgeT.addEventListener('input', ()=>{ if(state.img){ pv.layout(); pv.render(); } });
  dom.feather.addEventListener('input', ()=>{ if(state.img){ pv.layout(); pv.render(); } });

  dom.usePrompt.addEventListener('change', ()=>{
    dom.promptTxt.disabled = !dom.usePrompt.checked || !state.supportsPrompt;
  });

  dom.run.addEventListener('click', ()=>{
    if(!state.img){ alert('Upload an image first.'); return; }
    if(!state.seed){ alert('Click a seed point in ORIGINAL first.'); return; }
    runPipeline().catch(e=>log('AI error:', e?.message||e));
  });

  // editor interactions
  dom.edWrap.addEventListener('mousedown', e=>{
    if(!state.img) return;
    if(e.button!==0) return;
    if(e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) return;
    const p = ed.toImageXY(e.clientX,e.clientY);
    const sx = clamp(Math.round(p.x),0,state.img.width-1);
    const sy = clamp(Math.round(p.y),0,state.img.height-1);
    state.seed = {x:sx,y:sy}; ed.draw(); log(`Seed set at (${sx}, ${sy}).`);
    if(state.aiOn) runPipeline().catch(err=>log('AI error:', err?.message||err));
  });

  dom.edWrap.addEventListener('wheel', (e)=>{
    if(!state.img) return; e.preventDefault();
    const r = dom.edCanvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    const zf = 1.1; const zoom = e.deltaY<0 ? zf : 1/zf;
    const ns = clamp(state.ed.s*zoom, 0.1, 20);
    state.ed.x = mx - (mx - state.ed.x)*zoom; state.ed.y = my - (my - state.ed.y)*zoom; state.ed.s = ns;
    ed.draw();
  }, {passive:false});

  // logs
  dom.logFab.addEventListener('click', ()=> dom.logs.classList.toggle('visible'));
  dom.clearLog.addEventListener('click', ()=> dom.log.textContent='');
  dom.clearCache.addEventListener('click', async ()=>{ await idbClear(); state.sessions={}; state.cacheBuffers={}; log('Cache cleared.'); });
  dom.selfTest.addEventListener('click', async ()=>{
    for(const k of Object.keys(MODELS)){
      const m=MODELS[k];
      if(!m.gh && !m.db) continue;
      if(m.gh){
        try{ const r = await fetch(m.gh, {method:'HEAD', mode:'cors'}); log(`[HEAD GH] ${k}: ${r.status}`); }catch(e){log(`[HEAD GH] ${k}: ${e.message}`);}
      }
      if(m.db){
        try{ const r = await fetch(m.db, {method:'HEAD', mode:'cors'}); log(`[HEAD DB] ${k}: ${r.status}`); }catch(e){log(`[HEAD DB] ${k}: ${e.message}`);}
      }
      await sleep(50);
    }
  });

  // ---------- Layout ----------
  function layoutAll(){ ed.updateSize(); ed.fit(); ed.draw(); pv.layout(); pv.render(); }
  window.addEventListener('resize', layoutAll);

  // ---------- INIT ----------
  (async function init(){
    log('App ready. Version 3.1.0');
    await idbOpen();
    const providers = await pickProviders();
    log('Runtime:', providers.includes('webgpu') ? 'WebGPU + WASM fallback' : 'WASM only');

    // AI on by default, compact bar already visible
    dom.aiBadge.textContent = 'ü§ñ AI: ON';
    layoutAll();
  })();

})();
</script>
</body>
</html>
