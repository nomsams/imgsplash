<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Color Splash Pro X ‚Äî Minimal AI Mode (Stable Demo, Releases + Dropbox)</title>

<!--
===============================================================================
STABLE DEMO (v2.5.0 ‚ÄúMinimal AI Mode + Releases/Dropbox + Multi-Effects‚Äù)
What‚Äôs in this build:
- Robust, minimal AI pipeline with MANY failsafes.
- Two panes (ORIGINAL & PREVIEW), dual monocles (left/right).
- Seed click in ORIGINAL. Wheel=Zoom, Space+drag=Pan.
- AI Bar with:
  ‚Ä¢ Segmentation model dropdown (EdgeGrow fallback; GitHub Releases; Dropbox; local upload; URL import).
  ‚Ä¢ Depth model dropdown (None; GitHub Releases; Dropbox; local upload; URL import).
  ‚Ä¢ ‚ÄúRefine with Depth‚Äù checkbox (used by some effect modes).
  ‚Ä¢ ‚ÄúEffect Mode‚Äù selector:
      - Segmentation only
      - Depth: seed band
      - Depth: global threshold
      - Edges: Sobel+Laplacian
      - Seg ‚à© Depth
      - Seg ‚à© Edges
      - Seg ‚à© Depth ‚à© Edges
      - (Seg ‚à™ Depth) refined by Edges
  ‚Ä¢ Tunables: Depth band, Depth threshold, Edge threshold, Feather (px)
  ‚Ä¢ ‚ÄúUse‚Äù button (runs pipeline using the current seed)

- Thumbnails under PREVIEW (final mask + depth map).
- Logs panel (floating) with Clear Logs + Clear Cached Models (IndexedDB).
- Model sources:
  ‚Ä¢ Built-ins pointing at YOUR GitHub Releases (provided).
  ‚Ä¢ Built-ins for Dropbox DIRECT links (provided).
  ‚Ä¢ Import ONNX from file (cached in IndexedDB).
  ‚Ä¢ Import ONNX from URL (must allow CORS; cached in IndexedDB).
  ‚Ä¢ Paste JSON model list (name + direct_download_url) to extend menus live.

- ONNX Runtime Web with WebGPU (if available) + WASM fallback.
- YOLOv8n-seg and FastSAM-X/FastSAM-s decode path (generic YOLO-like seg).
- MiDaS-small / Depth-Anything v2 small depth path (generic first-output decode).

IMPORTANT:
- Cross-origin model fetches REQUIRE CORS. GitHub Releases and Dropbox DIRECT
  usually set proper CORS. If a URL blocks CORS, the app will tell you‚Äîthen you
  can mirror to same-origin (/models/) or use the local upload/import buttons.
===============================================================================
-->

<style>
  :root{
    --bg:#eef2f7; --panel:#ffffff; --ink:#111827; --muted:#6b7280; --border:#e5e7eb;
    --primary:#2563eb; --primary-2:#1e40af; --chip:#f3f4f6; --shadow:rgba(0,0,0,.08);
    --shadow-2:rgba(0,0,0,.15);
  }
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:var(--ink); background:var(--bg); display:flex; flex-direction:column; overflow:hidden;
  }
  header{
    background:var(--panel); border-bottom:1px solid var(--border); display:flex; align-items:center; gap:.5rem;
    padding:.55rem .75rem; position:relative; z-index:5; box-shadow:0 1px 6px var(--shadow);
  }
  .brand{font-weight:800; color:var(--primary)}
  .toolbar{display:flex; gap:.4rem; flex-wrap:wrap; align-items:center; margin-left:.5rem}
  button{
    background:#fff; border:1px solid var(--border); padding:.42rem .7rem; border-radius:8px; font-weight:600;
    display:inline-flex; align-items:center; gap:.42rem; cursor:pointer; box-shadow:0 1px 0 rgba(0,0,0,.02);
    transition:background .15s, border-color .15s, transform .05s;
  }
  button:hover{background:#f9fbff; border-color:#cfe0ff}
  button:active{transform:translateY(1px)}
  button.primary{background:var(--primary); border-color:var(--primary); color:#fff}
  button.primary:hover{background:var(--primary-2)}
  button.ghost{background:#fff}
  .badge{margin-left:auto; font-size:.8rem; color:#1f2937; background:#eef2ff; border:1px solid #dbe5ff; padding:.2rem .5rem; border-radius:6px}
  .version-pin{
    position:fixed; top:8px; right:8px; background:#111827; color:#fff; font-size:.72rem; padding:.25rem .45rem; border-radius:6px; opacity:.9; z-index:10;
    box-shadow:0 6px 16px rgba(0,0,0,.2);
  }
  .shell{flex:1; display:grid; grid-template-rows:auto 1fr; gap:10px; padding:10px; overflow:hidden}
  .row{min-height:0; display:grid; grid-template-columns:1fr 1fr; gap:10px}
  .panel{
    background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow:0 2px 10px var(--shadow);
    display:flex; flex-direction:column; min-height:0; overflow:hidden; position:relative;
  }
  .panel-h{padding:.5rem .75rem; border-bottom:1px solid var(--border); font-weight:700; color:#374151; text-align:center;}
  .panel-c{flex:1; min-height:0; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; background:#e9eef6;}
  .canvas-wrap{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; overflow:hidden; cursor:default;}
  .canvas-wrap.panning{cursor:grabbing}
  canvas{display:block; background:#fff}
  #editorCanvas{position:absolute; transform-origin:top left}
  #previewCanvas{position:absolute; top:0; left:0}

  /* monocles */
  .monocle{
    position:absolute; width:148px; height:148px; background:#fff; border:2px solid var(--border); border-radius:10px; overflow:hidden;
    box-shadow:0 8px 18px var(--shadow-2); display:none; z-index:3;
  }
  .monocle canvas{width:100%; height:100%; display:block; background:#000}
  #mono-left{top:10px; left:10px}
  #mono-right{top:10px; right:10px}

  .ai-bar{
    background:#fff; border:1px solid var(--border); border-radius:12px; display:none; padding:.5rem .6rem; gap:.45rem; align-items:center; flex-wrap:wrap;
  }
  .ai-bar.visible{display:flex}
  .chip{padding:.25rem .45rem; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:.82rem; color:#334155}
  .ai-bar select, .ai-bar input[type="number"], .ai-bar input[type="range"]{
    padding:.32rem .5rem; border:1px solid var(--border); border-radius:8px; background:#fff; font-weight:600;
  }
  .ai-bar .spacer{flex:1}

  .ai-outputs{
    position:absolute; left:6px; right:6px; bottom:6px; background:rgba(255,255,255,.96); border:1px solid var(--border); border-radius:10px; padding:6px;
    display:none; gap:12px; align-items:flex-start; z-index:2; flex-wrap:wrap;
  }
  .ai-outputs.visible{display:flex}
  .ai-plot{display:flex; flex-direction:column; align-items:center; gap:4px}
  .ai-plot canvas{width:160px; height:auto; max-height:100px; background:#f1f3f8; border:1px solid var(--border); border-radius:8px; image-rendering:pixelated}
  .ai-plot .cap{font-size:.72rem; color:#475569}

  .progress-wrap{position:absolute; left:12px; right:12px; bottom:12px; height:8px; border-radius:6px; background:#eef2ff; border:1px solid #dde6ff; overflow:hidden; opacity:0; transition:opacity .2s}
  .progress-wrap.visible{opacity:1}
  .progress{height:100%; width:0%; background:linear-gradient(90deg,#7aa2ff,#2563eb); transition:width .1s}

  #logFab{
    position:fixed; left:12px; bottom:12px; z-index:9; background:var(--primary); color:#fff; border:none; border-radius:999px; padding:.6rem .8rem;
    font-weight:800; box-shadow:0 10px 26px rgba(0,0,0,.25); cursor:pointer;
  }
  #logsPanel{
    position:fixed; left:12px; bottom:64px; width:420px; height:64vh; background:#fff; border:1px solid var(--border); border-radius:12px;
    box-shadow:0 16px 38px rgba(0,0,0,.25); display:none; overflow:hidden; z-index:9;
  }
  #logsPanel.visible{display:grid; grid-template-rows:auto auto auto 1fr auto}
  #logsHeader{padding:.5rem .75rem; border-bottom:1px solid var(--border); font-weight:700}
  #logsHelp{padding:.45rem .75rem; border-bottom:1px solid var(--border); color:#334155; font-size:.86rem; background:#fafbff}
  #logsBody{overflow:auto; padding:.5rem .6rem; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.83rem; color:#1f2937; background:#fff}
  .log-line{white-space:pre-wrap; margin:.15rem 0}
  #logsFooter{border-top:1px solid var(--border); padding:.45rem .6rem; display:grid; grid-template-columns:1fr 1fr 1fr; gap:.4rem}
  .hidden{display:none!important}

  .instructions{
    background:#fff; border:1px solid var(--border); border-radius:12px; padding:.5rem .6rem; color:#374151; display:flex; gap:.5rem; align-items:center;
  }
  .instructions .kbd{font-family:ui-monospace,monospace; background:#f3f4f6; border:1px solid #e5e7eb; padding:.05rem .35rem; border-radius:4px}
  .kv{font-size:.74rem; color:#334155; background:#f8fafc; border:1px dashed #d5e3ff; padding:.15rem .35rem; border-radius:6px}
</style>

<!-- ONNX Runtime Web -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <header>
    <div class="brand">Color Splash Pro X</div>
    <div class="toolbar">
      <button id="uploadBtn" class="primary">üì§ Upload Image</button>
      <button id="resetBtn" class="ghost">üßπ Reset</button>
      <button id="downloadBtn" class="ghost">‚¨áÔ∏è Download</button>
      <button id="aiToggleBtn" class="ghost">ü§ñ AI Mode</button>
      <button id="addJsonBtn" class="ghost">‚ûï Add Models JSON</button>
    </div>
    <span class="badge" id="verBadge">v?</span>
  </header>

  <div class="version-pin" id="verPin">v?</div>

  <div class="shell">
    <!-- AI BAR -->
    <div id="aiBar" class="ai-bar">
      <span class="chip">AI Controls</span>

      <label>Segmentation:</label>
      <select id="segSel"></select>

      <label>Depth:</label>
      <select id="depthSel"></select>

      <label style="display:inline-flex; align-items:center; gap:.35rem">
        <input id="refineChk" type="checkbox"/>
        <span>Refine with Depth</span>
      </label>

      <label>Effect:</label>
      <select id="effectSel">
        <option value="seg">Segmentation only</option>
        <option value="depth-band">Depth: seed band</option>
        <option value="depth-thresh">Depth: global threshold</option>
        <option value="edges">Edges: Sobel+Laplacian</option>
        <option value="seg-and-depth">Seg ‚à© Depth</option>
        <option value="seg-and-edges">Seg ‚à© Edges</option>
        <option value="seg-and-depth-and-edges">Seg ‚à© Depth ‚à© Edges</option>
        <option value="seg-or-depth-edge-refine">(Seg ‚à™ Depth) refined by Edges</option>
      </select>

      <span class="kv">Band</span>
      <input id="bandRange" type="range" min="0.01" max="0.25" step="0.005" value="0.07" title="Depth band around seed"/>

      <span class="kv">Depth T</span>
      <input id="depthThrRange" type="range" min="0" max="1" step="0.01" value="0.5" title="Depth threshold (near/far)"/>

      <span class="kv">Edge T</span>
      <input id="edgeThrRange" type="range" min="0.02" max="0.6" step="0.01" value="0.18" title="Edge magnitude threshold"/>

      <span class="kv">Feather(px)</span>
      <input id="featherPx" type="number" min="0" max="12" step="1" value="2" style="width:68px" title="Mask blur before compose"/>

      <button id="useBtn" class="primary">üöÄ Use</button>
      <div class="spacer"></div>
      <span id="aiStatus" class="chip">off</span>
    </div>

    <!-- INSTRUCTIONS -->
    <div class="instructions">
      <span>1) Upload an image. 2) Toggle <b>AI Mode</b>, choose Seg/Depth models or keep ‚ÄúEdgeGrow/None‚Äù. 3) Click your object in <b>ORIGINAL</b>. 4) Pick <b>Effect</b> and press <b>Use</b>. Tips: <span class="kbd">Space</span>+drag to pan, wheel to zoom.</span>
    </div>

    <!-- MAIN PANES -->
    <div class="row">
      <!-- ORIGINAL -->
      <section class="panel">
        <div class="panel-h">ORIGINAL ‚Äî Editor (click seed ¬∑ Space=Pan ¬∑ Wheel=Zoom)</div>
        <div class="panel-c">
          <div id="editorWrap" class="canvas-wrap" tabindex="0">
            <canvas id="editorCanvas"></canvas>
            <div id="mono-left" class="monocle"><canvas id="monoLeftCanvas"></canvas></div>
          </div>
          <div id="edEmpty" class="chip" style="position:absolute;pointer-events:none;">Drop or upload an image</div>
          <div class="progress-wrap" id="progWrap"><div class="progress" id="progBar"></div></div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel">
        <div class="panel-h">PREVIEW ‚Äî Color Splash (multi-method)</div>
        <div class="panel-c" id="previewContainer">
          <div id="previewWrap" class="canvas-wrap">
            <canvas id="previewCanvas"></canvas>
            <div id="mono-right" class="monocle"><canvas id="monoRightCanvas"></canvas></div>
          </div>
          <!-- AI substep thumbnails -->
          <div id="aiThumbs" class="ai-outputs">
            <div class="ai-plot">
              <canvas id="maskThumb"></canvas>
              <div class="cap">Final Mask</div>
            </div>
            <div class="ai-plot">
              <canvas id="depthThumb"></canvas>
              <div class="cap">Depth Map</div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- LOGS -->
  <button id="logFab">üí¨ Logs</button>
  <div id="logsPanel">
    <div id="logsHeader">AI Logs & Model Manager</div>
    <div id="logsHelp">
      <div style="margin-bottom:.25rem">
        Use your GitHub <b>Releases</b> or <b>Dropbox DIRECT</b> links for cross-origin fetches with CORS.<br/>
        Or mirror models to <code>/models/</code> (same-origin). You can also import ONNX files or URLs (cached in <b>IndexedDB</b>).
      </div>
      <div>If a link fails with CORS/401/403, use the local upload option or host on same-origin.</div>
    </div>
    <div id="logsBody"></div>
    <div id="logsFooter">
      <button id="clearBtn">Clear Logs</button>
      <button id="clearCacheBtn">Clear Cached Models</button>
      <button id="selfTestBtn">Self-Test Links</button>
    </div>
  </div>

  <!-- hidden inputs -->
  <input id="imgInput" class="hidden" type="file" accept="image/*"/>
  <input id="segInput" class="hidden" type="file" accept=".onnx"/>
  <input id="depthInput" class="hidden" type="file" accept=".onnx"/>

<script>
(function(){
  'use strict';

  // ---------------- Meta ----------------
  const APP_VERSION = '2.5.0';
  id('verBadge').textContent = APP_VERSION;
  id('verPin').textContent = APP_VERSION;

  // ---------------- DOM ----------------
  const dom = {
    uploadBtn: id('uploadBtn'),
    resetBtn: id('resetBtn'),
    downloadBtn: id('downloadBtn'),
    aiToggleBtn: id('aiToggleBtn'),
    addJsonBtn: id('addJsonBtn'),

    aiBar: id('aiBar'),
    segSel: id('segSel'),
    depthSel: id('depthSel'),
    refineChk: id('refineChk'),
    effectSel: id('effectSel'),
    bandRange: id('bandRange'),
    depthThrRange: id('depthThrRange'),
    edgeThrRange: id('edgeThrRange'),
    featherPx: id('featherPx'),
    useBtn: id('useBtn'),
    aiStatus: id('aiStatus'),

    editorWrap: id('editorWrap'),
    editorCanvas: id('editorCanvas'),
    edEmpty: id('edEmpty'),
    previewContainer: id('previewContainer'),
    previewWrap: id('previewWrap'),
    previewCanvas: id('previewCanvas'),

    progWrap: id('progWrap'),
    progBar: id('progBar'),

    monoLeft: id('mono-left'),
    monoRight: id('mono-right'),
    monoLeftCanvas: id('monoLeftCanvas'),
    monoRightCanvas: id('monoRightCanvas'),

    aiThumbs: id('aiThumbs'),
    maskThumb: id('maskThumb'),
    depthThumb: id('depthThumb'),

    logFab: id('logFab'),
    logsPanel: id('logsPanel'),
    logsBody: id('logsBody'),
    clearBtn: id('clearBtn'),
    clearCacheBtn: id('clearCacheBtn'),
    selfTestBtn: id('selfTestBtn'),

    imgInput: id('imgInput'),
    segInput: id('segInput'),
    depthInput: id('depthInput'),
  };

  // ---------------- State ----------------
  const state = {
    image: null,
    ed: { x:0, y:0, s:1, panning:false, panStart:[0,0], tx:0, ty:0 },
    seed: null,
    aiActive: false,
    segKey: 'edgegrow',    // 'edgegrow' = built-in fallback (no model)
    depthKey: 'none',      // 'none' = no depth
    refine: false,
    effect: 'seg',
    sessions: {},          // { key : ort.InferenceSession }
    cachedBuffers: {},     // { key : Uint8Array } (from IDB or fetch)
    maskCanvas: null,      // final mask used in preview
    depthCanvas: null,     // depth viz
    depthMap: null,        // Float32Array normalized [0..1]
    models: {}             // dynamic registry (filled below)
  };

  // ---------------- Logs ----------------
  function log(...args){
    const line = document.createElement('div');
    line.className = 'log-line';
    line.textContent = `[${new Date().toLocaleTimeString()}] ` + args.join(' ');
    dom.logsBody.appendChild(line);
    dom.logsBody.scrollTop = dom.logsBody.scrollHeight;
    console.debug(...args);
  }

  // ---------------- Helpers ----------------
  function id(s){ return document.getElementById(s); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // ---------------- Progress ----------------
  let progTimer=null, progTarget=85;
  function startProgress(){
    dom.progWrap.classList.add('visible');
    dom.progBar.style.width = '0%';
    let p=0;
    clearInterval(progTimer);
    progTimer = setInterval(()=>{
      p = Math.min(p + 10, progTarget);
      dom.progBar.style.width = p + '%';
    }, 80);
  }
  function finishProgress(){
    clearInterval(progTimer);
    progTimer = null;
    dom.progBar.style.width = '100%';
    setTimeout(()=>{ dom.progWrap.classList.remove('visible'); dom.progBar.style.width='0%'; }, 240);
  }

  // ---------------- Editor & Preview ----------------
  const ed = {
    c: dom.editorCanvas,
    ctx: dom.editorCanvas.getContext('2d'),
    updateSize(){
      const w = dom.editorWrap.clientWidth, h = dom.editorWrap.clientHeight;
      this.c.width=w; this.c.height=h;
    },
    toImageXY(clientX, clientY){
      const r = this.c.getBoundingClientRect();
      const cx = clientX - r.left, cy = clientY - r.top;
      const x = (cx - state.ed.x)/state.ed.s;
      const y = (cy - state.ed.y)/state.ed.s;
      return {x, y};
    },
    fit(){
      if(!state.image) return;
      const iW = state.image.width, iH = state.image.height;
      const cW = dom.editorWrap.clientWidth, cH = dom.editorWrap.clientHeight;
      const s = Math.min(cW/iW, cH/iH)*0.98;
      state.ed.s = s;
      state.ed.x = (cW - iW*s)/2;
      state.ed.y = (cH - iH*s)/2;
    },
    draw(){
      const {ctx,c} = this;
      ctx.clearRect(0,0,c.width,c.height);
      if(!state.image) return;
      ctx.save();
      ctx.translate(state.ed.x, state.ed.y);
      ctx.scale(state.ed.s, state.ed.s);
      ctx.drawImage(state.image, 0,0);
      if(state.seed){
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 1/state.ed.s;
        ctx.beginPath();
        ctx.moveTo(state.seed.x-12, state.seed.y);
        ctx.lineTo(state.seed.x+12, state.seed.y);
        ctx.moveTo(state.seed.x, state.seed.y-12);
        ctx.lineTo(state.seed.x, state.seed.y+12);
        ctx.stroke();
      }
      ctx.restore();
    }
  };

  const pv = {
    c: dom.previewCanvas,
    ctx: dom.previewCanvas.getContext('2d'),
    layout(){
      if(!state.image) return;
      const rect = dom.previewContainer.getBoundingClientRect();
      const availW = Math.max(1, rect.width);
      const availH = Math.max(1, rect.height);
      const aspect = state.image.width/state.image.height;
      let w = availW, h = w/aspect;
      if(h>availH){ h = availH; w = h*aspect; }
      this.c.width = Math.round(w); this.c.height = Math.round(h);
      this.c.style.left = ((availW - this.c.width)/2) + 'px';
      this.c.style.top  = ((availH - this.c.height)/2) + 'px';
    },
    render(){
      if(!state.image) return;
      const {ctx,c} = this;
      ctx.clearRect(0,0,c.width,c.height);

      // Build full-res mask using requested effect
      const fullMask = buildEffectMaskFullRes();

      // Render color-splash
      const tmp = document.createElement('canvas');
      tmp.width = state.image.width; tmp.height = state.image.height;
      const tx = tmp.getContext('2d');
      tx.drawImage(state.image,0,0);
      const im = tx.getImageData(0,0,tmp.width,tmp.height);
      const d = im.data;
      for(let i=0;i<d.length;i+=4){
        const y = Math.round(0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]);
        d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255;
      }
      tx.putImageData(im,0,0);
      ctx.drawImage(tmp, 0,0, c.width,c.height);

      const fg = document.createElement('canvas');
      fg.width = state.image.width; fg.height = state.image.height;
      const fx = fg.getContext('2d');
      fx.drawImage(state.image,0,0);
      fx.globalCompositeOperation = 'destination-in';
      fx.drawImage(fullMask,0,0);
      ctx.drawImage(fg, 0,0, c.width, c.height);
    }
  };

  function buildEffectMaskFullRes(){
    const W = state.image.width, H = state.image.height;
    const m = document.createElement('canvas');
    m.width=W; m.height=H;
    const mx = m.getContext('2d');
    mx.clearRect(0,0,W,H);

    // Source pieces
    const seg = state.maskCanvas; // latest computed "base" mask (seg or edgegrow)
    const depth = state.depthMap; // Float32Array or null
    const feather = parseInt(dom.featherPx.value||'2',10);

    // Make individual masks as needed for effect
    let segMask = null, depthMask = null, edgesMask = null;

    // Segmentation mask
    if(seg) segMask = seg;

    // Depth-based masks
    const effect = state.effect;
    if(depth && (effect.includes('depth') || effect==='depth-band' || effect==='depth-thresh' || state.refine)){
      if(effect==='depth-band' || effect.includes('depth') || state.refine){
        const band = parseFloat(dom.bandRange.value||'0.07');
        const dm = makeDepthBandMask(depth, W,H, state.seed, band);
        depthMask = mergeOr(depthMask, dm);
      }
      if(effect==='depth-thresh'){
        const thr = parseFloat(dom.depthThrRange.value||'0.5');
        const near = true; // choose near foreground (you could add a toggle)
        const dm2 = makeDepthThresholdMask(depth, W,H, thr, near);
        depthMask = mergeOr(depthMask, dm2);
      }
    }

    // Edge mask (from image itself)
    if(effect==='edges' || effect.includes('edges')){
      edgesMask = makeEdgesMask(state.image, 0.7, 0.3, parseFloat(dom.edgeThrRange.value||'0.18'));
    }

    // Combine per effect
    let finalMask = null;
    switch(effect){
      case 'seg':
        finalMask = segMask || edgeGrowMask(state.image, state.seed?.x??Math.round(W/2), state.seed?.y??Math.round(H/2));
        break;
      case 'depth-band':
        finalMask = depthMask || fallbackNullMask(W,H);
        break;
      case 'depth-thresh':
        finalMask = depthMask || fallbackNullMask(W,H);
        break;
      case 'edges':
        finalMask = edgesMask || fallbackNullMask(W,H);
        break;
      case 'seg-and-depth':
        finalMask = intersectMasks(segMask, depthMask) || segMask || depthMask || fallbackNullMask(W,H);
        break;
      case 'seg-and-edges':
        finalMask = intersectMasks(segMask, edgesMask) || segMask || edgesMask || fallbackNullMask(W,H);
        break;
      case 'seg-and-depth-and-edges':
        finalMask = intersectMasks(intersectMasks(segMask, depthMask), edgesMask) || intersectMasks(segMask, depthMask) || segMask || depthMask || edgesMask || fallbackNullMask(W,H);
        break;
      case 'seg-or-depth-edge-refine': {
        const base = unionMasks(segMask, depthMask) || segMask || depthMask || fallbackNullMask(W,H);
        finalMask = edgesMask ? intersectMasks(base, edgesMask) : base;
        break;
      }
      default:
        finalMask = segMask || fallbackNullMask(W,H);
    }

    // Feather/blur
    const featherPx = clamp(parseInt(feather,10)||0, 0, 12);
    if(featherPx>0){
      const out = document.createElement('canvas');
      out.width=W; out.height=H;
      const ox = out.getContext('2d');
      ox.filter = `blur(${featherPx}px)`;
      ox.drawImage(finalMask,0,0);
      ox.filter='none';
      return out;
    }
    return finalMask;
  }

  function fallbackNullMask(W,H){
    const c = document.createElement('canvas'); c.width=W; c.height=H; return c;
  }
  function intersectMasks(a,b){
    if(!a || !b) return null;
    const W = a.width, H = a.height;
    const out = document.createElement('canvas'); out.width=W; out.height=H;
    const ox = out.getContext('2d');
    ox.drawImage(a,0,0);
    ox.globalCompositeOperation = 'destination-in';
    ox.drawImage(b,0,0);
    return out;
  }
  function unionMasks(a,b){
    if(!a && !b) return null;
    if(a && !b) return a;
    if(!a && b) return b;
    const W = a.width, H = a.height;
    const out = document.createElement('canvas'); out.width=W; out.height=H;
    const ox = out.getContext('2d');
    ox.drawImage(a,0,0);
    ox.globalCompositeOperation = 'destination-over';
    ox.drawImage(b,0,0);
    return out;
  }
  function mergeOr(existing, add){
    if(!add) return existing || null;
    return unionMasks(existing, add);
  }

  // ---------------- Image I/O ----------------
  dom.uploadBtn.addEventListener('click', ()=> dom.imgInput.click());
  dom.imgInput.addEventListener('change', e=>{
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      const img = new Image();
      img.onload = ()=>{
        state.image = img;
        state.seed = null;
        state.maskCanvas = null;
        state.depthCanvas = null;
        state.depthMap = null;
        dom.edEmpty.classList.add('hidden');
        ed.updateSize(); ed.fit(); ed.draw();
        pv.layout(); pv.render();
        dom.aiThumbs.classList.remove('visible');
        log(`Image loaded: ${f.name} ${img.width}x${img.height}`);
      };
      img.src = r.result;
    };
    r.readAsDataURL(f);
  });

  dom.resetBtn.addEventListener('click', ()=>{
    state.image = null; state.seed = null; state.maskCanvas = null; state.depthCanvas = null; state.depthMap = null;
    ed.updateSize(); ed.ctx.clearRect(0,0,ed.c.width,ed.c.height);
    pv.ctx.clearRect(0,0,pv.c.width,pv.c.height);
    dom.edEmpty.classList.remove('hidden');
    dom.aiThumbs.classList.remove('visible');
    log('Reset.');
  });

  dom.downloadBtn.addEventListener('click', ()=>{
    if(!state.image){ alert('Upload an image first.'); return; }
    // Full-res render
    const out = document.createElement('canvas');
    out.width = state.image.width; out.height = state.image.height;
    const ox = out.getContext('2d');

    // grayscale
    const tmp = document.createElement('canvas');
    tmp.width = out.width; tmp.height = out.height;
    const tx = tmp.getContext('2d');
    tx.drawImage(state.image,0,0);
    const im = tx.getImageData(0,0,out.width,out.height);
    const d = im.data;
    for(let i=0;i<d.length;i+=4){
      const y = Math.round(0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]);
      d[i]=y; d[i+1]=y; d[i+2]=y; d[i+3]=255;
    }
    tx.putImageData(im,0,0);
    ox.drawImage(tmp,0,0);

    // mask & colorized
    const mask = buildEffectMaskFullRes();
    const fg = document.createElement('canvas'); fg.width=out.width; fg.height=out.height;
    const fx = fg.getContext('2d'); fx.drawImage(state.image,0,0);
    fx.globalCompositeOperation = 'destination-in'; fx.drawImage(mask,0,0);
    ox.drawImage(fg,0,0);

    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = `colorsplash-${Date.now()}.png`;
    a.click();
  });

  // ---------------- Interactions (Editor) ----------------
  dom.editorWrap.addEventListener('mousedown', (e)=>{
    if(!state.image) return;
    if(e.button===0){
      if(!e.ctrlKey && !e.metaKey && !e.altKey){
        const p = ed.toImageXY(e.clientX,e.clientY);
        const sx = Math.round(clamp(p.x,0,state.image.width-1));
        const sy = Math.round(clamp(p.y,0,state.image.height-1));
        state.seed = {x:sx,y:sy};
        ed.draw();
        log(`Seed set at (${sx}, ${sy}).`);
        if(state.aiActive) runAIPipeline('click').catch(err=>log('AI error:', err?.message||err));
      }
    }
  });
  dom.editorWrap.addEventListener('keydown', e=>{
    if(e.code==='Space'){ state.ed.panning = true; dom.editorWrap.classList.add('panning'); }
  });
  dom.editorWrap.addEventListener('keyup', e=>{
    if(e.code==='Space'){ state.ed.panning = false; dom.editorWrap.classList.remove('panning'); }
  });
  dom.editorWrap.addEventListener('mousedown', e=>{
    if(e.button===0 && state.ed.panning){
      state.ed.panStart=[e.clientX, e.clientY]; state.ed.tx = state.ed.x; state.ed.ty = state.ed.y;
      const move = (ev)=>{
        const dx = ev.clientX - state.ed.panStart[0]; const dy = ev.clientY - state.ed.panStart[1];
        state.ed.x = state.ed.tx + dx; state.ed.y = state.ed.ty + dy; ed.draw(); updateMonocle(ev,'editor');
      };
      const up = ()=>{
        window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up);
        dom.editorWrap.classList.remove('panning');
      };
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
    }
  });
  dom.editorWrap.addEventListener('wheel', (e)=>{
    if(!state.image) return; e.preventDefault();
    const r = dom.editorCanvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    const zf = 1.1; const zoom = e.deltaY<0 ? zf : 1/zf;
    const ns = clamp(state.ed.s*zoom, 0.1, 20);
    state.ed.x = mx - (mx - state.ed.x)*zoom; state.ed.y = my - (my - state.ed.y)*zoom; state.ed.s = ns;
    ed.draw(); updateMonocle(e,'editor');
  }, {passive:false});
  dom.editorWrap.tabIndex = 0;

  // ---------------- Monocles ----------------
  function updateMonocle(e, where){
    if(!state.image) return;
    const hopIfNear = (monoEl, panelRect, side)=>{
      const pad=10, mrect = monoEl.getBoundingClientRect();
      const dx = Math.max(0, Math.max(mrect.left - e.clientX, e.clientX - mrect.right));
      const dy = Math.max(0, Math.max(mrect.top  - e.clientY, e.clientY - mrect.bottom));
      const dist = Math.hypot(dx,dy);
      if(dist<18){
        if(side==='left'){ monoEl.style.left = (panelRect.width - mrect.width - pad) + 'px'; monoEl.style.right = 'auto'; }
        else { monoEl.style.right = (panelRect.width - mrect.width - pad) + 'px'; monoEl.style.left = 'auto'; }
      } else {
        if(side==='left'){ monoEl.style.left = pad+'px'; monoEl.style.right='auto'; }
        else { monoEl.style.right = pad+'px'; monoEl.style.left='auto'; }
      }
    };

    if(where==='editor'){
      const mC = dom.monoLeftCanvas; if(mC.width===0){ mC.width=148; mC.height=148; }
      const mctx = mC.getContext('2d');
      const rect = dom.editorCanvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left - state.ed.x)/state.ed.s;
      const cy = (e.clientY - rect.top  - state.ed.y)/state.ed.s;
      const box=64;
      const sx = Math.floor(clamp(cx - box/2, 0, state.image.width - box));
      const sy = Math.floor(clamp(cy - box/2, 0, state.image.height - box));
      mctx.imageSmoothingEnabled = false; mctx.clearRect(0,0,mC.width,mC.height);
      mctx.drawImage(state.image, sx,sy, box,box, 0,0, mC.width,mC.height);
      const fx = ((cx - sx)/box) * mC.width; const fy = ((cy - sy)/box) * mC.height;
      mctx.strokeStyle = '#0a46ff'; mctx.lineWidth = 1; mctx.beginPath(); mctx.moveTo(fx, 0); mctx.lineTo(fx, mC.height); mctx.moveTo(0, fy); mctx.lineTo(mC.width, fy); mctx.stroke();
      dom.monoLeft.style.display='block'; hopIfNear(dom.monoLeft, dom.editorWrap.getBoundingClientRect(), 'left');
    } else {
      const mC = dom.monoRightCanvas; if(mC.width===0){ mC.width=148; mC.height=148; }
      const mctx = mC.getContext('2d');
      const rect = dom.previewCanvas.getBoundingClientRect();
      const scaleX = state.image.width / Math.max(1, dom.previewCanvas.width);
      const scaleY = state.image.height / Math.max(1, dom.previewCanvas.height);
      const cx = (e.clientX - rect.left)*scaleX;
      const cy = (e.clientY - rect.top )*scaleY;
      const box=64;
      const sx = Math.floor(clamp(cx - box/2, 0, state.image.width - box));
      const sy = Math.floor(clamp(cy - box/2, 0, state.image.height - box));

      mctx.imageSmoothingEnabled = false; mctx.clearRect(0,0,mC.width,mC.height);
      const px = sx/scaleX, py = sy/scaleY; const pw = box/scaleX, ph = box/scaleY;
      mctx.drawImage(dom.previewCanvas, Math.round(px),Math.round(py), Math.round(pw),Math.round(ph), 0,0, mC.width,mC.height);

      const fx = ((cx - sx)/box) * mC.width; const fy = ((cy - sy)/box) * mC.height;
      mctx.strokeStyle = '#0a46ff'; mctx.lineWidth = 1; mctx.beginPath(); mctx.moveTo(fx,0); mctx.lineTo(fx,mC.height); mctx.moveTo(0,fy); mctx.lineTo(mC.width,fy); mctx.stroke();

      dom.monoRight.style.display='block'; hopIfNear(dom.monoRight, dom.previewWrap.getBoundingClientRect(), 'right');
    }
  }
  dom.editorWrap.addEventListener('mousemove', e=> updateMonocle(e,'editor'));
  dom.previewWrap.addEventListener('mousemove', e=> updateMonocle(e,'preview'));
  dom.editorWrap.addEventListener('mouseenter', ()=> dom.monoLeft.style.display='block');
  dom.previewWrap.addEventListener('mouseenter', ()=> dom.monoRight.style.display='block');

  // ---------------- Layout ----------------
  function layoutAll(){
    ed.updateSize(); ed.fit(); ed.draw(); pv.layout(); pv.render();
  }
  window.addEventListener('resize', layoutAll);

  // ---------------- AI Mode ----------------
  dom.aiToggleBtn.addEventListener('click', ()=>{
    state.aiActive = !state.aiActive;
    dom.aiBar.classList.toggle('visible', state.aiActive);
    dom.aiStatus.textContent = state.aiActive ? 'ready' : 'off';
    log('AI Mode', state.aiActive ? 'ON' : 'OFF');
  });
  dom.refineChk.addEventListener('change', ()=>{ state.refine = dom.refineChk.checked; log('Refine with Depth:', state.refine ? 'ON' : 'OFF'); });
  dom.effectSel.addEventListener('change', ()=>{ state.effect = dom.effectSel.value; log('Effect:', state.effect); });

  // --- Build Seg/Depth dropdowns (with YOUR Releases & Dropbox) ---
  const BUILTIN_MODELS = {
    // Segmentation
    'edgegrow': { type:'seg', label:'No model (EdgeGrow fallback)', url:null, inputSize:640, flavor:'edgegrow' },
    'gh-yolov8n-seg': { type:'seg', label:'YOLOv8n-seg (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/yolov8n-seg.onnx', inputSize:640, flavor:'yolov8' },
    'gh-fastsam-s'  : { type:'seg', label:'FastSAM-s (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/FastSAM-s.onnx', inputSize:640, flavor:'fastsam' },
    'gh-fastsam-x'  : { type:'seg', label:'FastSAM-X (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/FastSam-X.onnx', inputSize:640, flavor:'fastsam' },
    'db-fastsam-x'  : { type:'seg', label:'FastSAM-X (Dropbox DIRECT)', url:'https://dl.dropboxusercontent.com/scl/fi/hpwyjvgc9yl0mbf2ty9dr/FastSam-X.onnx?rlkey=i9kfkcucagp5tb4qm0m1fgwm5&dl=1', inputSize:640, flavor:'fastsam' },

    // Depth
    'none': { type:'depth', label:'None', url:null, inputSize:256, flavor:'none' },
    'gh-midas-small': { type:'depth', label:'MiDaS v2.1 Small (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/midas_small.onnx', inputSize:256, flavor:'midas' },
    'gh-da-v2-small': { type:'depth', label:'Depth Anything V2 Small FP32 (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small.onnx', inputSize:518, flavor:'depth-anything' },
    'gh-da-v2-small-int8': { type:'depth', label:'Depth Anything V2 Small INT8 (GitHub Releases)', url:'https://github.com/nomsams/imgsplash/releases/download/models/depth_anything_v2_small_int8.onnx', inputSize:518, flavor:'depth-anything' },
    'db-midas-small': { type:'depth', label:'MiDaS v2.1 Small (Dropbox DIRECT)', url:'https://dl.dropboxusercontent.com/scl/fi/ljsrtwxbd5oscq6hgthrk/midas_small.onnx?rlkey=emtxd6xhxsjrpq8j2jbabqoxn&dl=1', inputSize:256, flavor:'midas' },
    'db-da-v2-small': { type:'depth', label:'Depth Anything V2 Small (Dropbox DIRECT)', url:'https://dl.dropboxusercontent.com/scl/fi/oif7z9iap5ua1wlef04e3/depth_anything_v2_small.onnx?rlkey=tfv2lz4xalrxp30fmoes006gy&dl=1', inputSize:518, flavor:'depth-anything' },
    'db-da-v2-small-int8': { type:'depth', label:'Depth Anything V2 Small INT8 (Dropbox DIRECT)', url:'https://www.dropbox.com/scl/fi/8brcbml22th9om9axdv5t/depth_anything_v2_small_int8.onnx?rlkey=rqkjeu0bd222xx9sr13qdywnz&st=rqlxaq1n&dl=1', inputSize:518, flavor:'depth-anything' },

    // Placeholders for imports
    'upload-seg': { type:'seg', label:'Import Seg ONNX‚Ä¶', url:null, inputSize:640, flavor:'custom' },
    'url-seg':    { type:'seg', label:'Load Seg from URL‚Ä¶', url:null, inputSize:640, flavor:'custom' },
    'custom-seg': { type:'seg', label:'[Cached] Custom Seg', url:null, inputSize:640, flavor:'custom' },

    'upload-depth': { type:'depth', label:'Import Depth ONNX‚Ä¶', url:null, inputSize:256, flavor:'custom' },
    'url-depth':    { type:'depth', label:'Load Depth from URL‚Ä¶', url:null, inputSize:256, flavor:'custom' },
    'custom-depth': { type:'depth', label:'[Cached] Custom Depth', url:null, inputSize:256, flavor:'custom' },
  };

  function buildDropdowns(){
    // segmentation
    dom.segSel.innerHTML = '';
    addOpt(dom.segSel, 'edgegrow', BUILTIN_MODELS['edgegrow'].label);
    addOpt(dom.segSel, 'upload-seg', BUILTIN_MODELS['upload-seg'].label);
    addOpt(dom.segSel, 'url-seg', BUILTIN_MODELS['url-seg'].label);
    addOpt(dom.segSel, 'custom-seg', BUILTIN_MODELS['custom-seg'].label);
    addOpt(dom.segSel, 'gh-yolov8n-seg', BUILTIN_MODELS['gh-yolov8n-seg'].label);
    addOpt(dom.segSel, 'gh-fastsam-s', BUILTIN_MODELS['gh-fastsam-s'].label);
    addOpt(dom.segSel, 'gh-fastsam-x', BUILTIN_MODELS['gh-fastsam-x'].label);
    addOpt(dom.segSel, 'db-fastsam-x', BUILTIN_MODELS['db-fastsam-x'].label);

    // depth
    dom.depthSel.innerHTML = '';
    addOpt(dom.depthSel, 'none', BUILTIN_MODELS['none'].label);
    addOpt(dom.depthSel, 'upload-depth', BUILTIN_MODELS['upload-depth'].label);
    addOpt(dom.depthSel, 'url-depth', BUILTIN_MODELS['url-depth'].label);
    addOpt(dom.depthSel, 'custom-depth', BUILTIN_MODELS['custom-depth'].label);
    addOpt(dom.depthSel, 'gh-midas-small', BUILTIN_MODELS['gh-midas-small'].label);
    addOpt(dom.depthSel, 'gh-da-v2-small', BUILTIN_MODELS['gh-da-v2-small'].label);
    addOpt(dom.depthSel, 'gh-da-v2-small-int8', BUILTIN_MODELS['gh-da-v2-small-int8'].label);
    addOpt(dom.depthSel, 'db-midas-small', BUILTIN_MODELS['db-midas-small'].label);
    addOpt(dom.depthSel, 'db-da-v2-small', BUILTIN_MODELS['db-da-v2-small'].label);
    addOpt(dom.depthSel, 'db-da-v2-small-int8', BUILTIN_MODELS['db-da-v2-small-int8'].label);

    dom.segSel.value = state.segKey;
    dom.depthSel.value = state.depthKey;
  }
  function addOpt(sel, val, label){ const o=document.createElement('option'); o.value=val; o.textContent=label; sel.appendChild(o); }

  // dynamic model registry
  Object.assign(state.models, BUILTIN_MODELS);
  buildDropdowns();

  dom.segSel.addEventListener('change', async ()=>{
    const v = dom.segSel.value;
    if(v==='upload-seg'){ dom.segInput.click(); dom.segSel.value = state.segKey; return; }
    if(v==='url-seg'){
      const url = prompt('Enter DIRECT/CORS-enabled URL to segmentation ONNX (GitHub Releases/Dropbox or same-origin):');
      if(url){ await cacheUrlToKey('custom-seg', url, 'seg'); dom.segSel.value = 'custom-seg'; state.segKey = 'custom-seg'; }
      return;
    }
    state.segKey = v;
    if(v!=='edgegrow' && v!=='custom-seg'){
      ensureSession(v).catch(e=> log('Seg preload failed:', e?.message||e));
    }
    log('Segmentation model:', v);
  });

  dom.depthSel.addEventListener('change', async ()=>{
    const v = dom.depthSel.value;
    if(v==='upload-depth'){ dom.depthInput.click(); dom.depthSel.value = state.depthKey; return; }
    if(v==='url-depth'){
      const url = prompt('Enter DIRECT/CORS-enabled URL to depth ONNX (GitHub Releases/Dropbox or same-origin):');
      if(url){ await cacheUrlToKey('custom-depth', url, 'depth'); dom.depthSel.value = 'custom-depth'; state.depthKey = 'custom-depth'; }
      return;
    }
    state.depthKey = v;
    if(v!=='none' && v!=='custom-depth'){
      ensureSession(v).catch(e=> log('Depth preload failed:', e?.message||e));
    }
    log('Depth model:', v);
  });

  // File imports
  dom.segInput.addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    try{
      const buf = await f.arrayBuffer();
      await idbSet('custom-seg', buf);
      state.cachedBuffers['custom-seg'] = new Uint8Array(buf);
      state.sessions['custom-seg'] = null;
      state.segKey = 'custom-seg';
      dom.segSel.value = 'custom-seg';
      log(`Imported segmentation ONNX (${f.name}) into cache (key: custom-seg).`);
    }catch(err){ log('Import seg failed:', err?.message||err); }
  });
  dom.depthInput.addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    try{
      const buf = await f.arrayBuffer();
      await idbSet('custom-depth', buf);
      state.cachedBuffers['custom-depth'] = new Uint8Array(buf);
      state.sessions['custom-depth'] = null;
      state.depthKey = 'custom-depth';
      dom.depthSel.value = 'custom-depth';
      log(`Imported depth ONNX (${f.name}) into cache (key: custom-depth).`);
    }catch(err){ log('Import depth failed:', err?.message||err); }
  });

  // Add Models JSON (user paste)
  dom.addJsonBtn.addEventListener('click', ()=>{
    const txt = prompt('Paste JSON array with {"name","direct_download_url"} per entry. These will be added as custom models.\nExample:\n[\n {"name":"YOLOv8n-Seg (Releases)","direct_download_url":"https://.../yolov8n-seg.onnx"},\n {"name":"MiDaS Small (Releases)","direct_download_url":"https://.../midas_small.onnx"}\n]\n\nNOTE: Choose appropriate target dropdown afterwards and use "Load ... from URL‚Ä¶" to cache.');
    if(!txt) return;
    try{
      const arr = JSON.parse(txt);
      if(!Array.isArray(arr)) throw new Error('Not an array');
      let added=0;
      for(const it of arr){
        if(!it || !it.name || !it.direct_download_url) continue;
        const url = String(it.direct_download_url);
        // Heuristic: treat "seg" if file name contains seg|fastsam etc., else "depth"
        const lower = url.toLowerCase();
        const type = (lower.includes('seg') || lower.includes('fastsam') || lower.includes('mask')) ? 'seg' : 'depth';
        const key = 'user-' + Math.random().toString(36).slice(2,9);
        state.models[key] = { type, label: it.name + ' (User)', url, inputSize: type==='seg'?640:256, flavor: type==='seg'?'yolov8':'midas' };
        added++;
      }
      if(added>0){ log(`Added ${added} model entries. Use "Load from URL‚Ä¶" to cache into IndexedDB.`); }
      else { log('No valid entries found in JSON.'); }
    }catch(err){
      log('Invalid JSON:', err?.message||err);
    }
  });

  // Use button
  dom.useBtn.addEventListener('click', ()=>{
    if(!state.image){ alert('Upload an image first.'); return; }
    if(!state.seed){ alert('Click the object in the ORIGINAL panel to set a seed first.'); return; }
    runAIPipeline('use').catch(err=> log('AI error:', err?.message||err));
  });

  // ---------------- Model & ORT ----------------
  async function ensureSession(key){
    if(!key) return null;
    if(key==='edgegrow' || key==='none') return null;
    if(state.sessions[key]) return state.sessions[key];

    const info = state.models[key] || BUILTIN_MODELS[key];
    if(!info) throw new Error('Unknown model key: '+key);
    const providers = await pickProviders();

    dom.aiStatus.textContent = `loading ${key}‚Ä¶`;
    startProgress();

    let session = null;
    try{
      let bytes = null;
      if(state.cachedBuffers[key]){
        bytes = state.cachedBuffers[key];
        log(`Creating session from cached buffer: ${key} (${bytes.byteLength} bytes)`);
        session = await ort.InferenceSession.create(bytes, { executionProviders: providers, graphOptimizationLevel:'all' });
      }else if(info.url){
        const buf = await fetchAsBufferCORS(info.url);
        const u8 = new Uint8Array(buf);
        state.cachedBuffers[key] = u8;
        log(`Fetched ONNX: ${info.url} (${u8.byteLength} bytes)`);
        session = await ort.InferenceSession.create(u8, { executionProviders: providers, graphOptimizationLevel:'all' });
      }else{
        // custom-seg/depth from IDB
        const ib = await idbGet(key);
        if(!ib) throw new Error(`No cached buffer in IDB for ${key}. Import it first.`);
        const u8 = new Uint8Array(ib);
        state.cachedBuffers[key] = u8;
        log(`Loaded ONNX from IDB (${key}, ${u8.byteLength} bytes).`);
        session = await ort.InferenceSession.create(u8, { executionProviders: providers, graphOptimizationLevel:'all' });
      }
      state.sessions[key] = session;
      dom.aiStatus.textContent = `loaded ${key}`;
      finishProgress();
      return session;
    }catch(err){
      finishProgress();
      dom.aiStatus.textContent = `failed ${key}`;
      log(`Model load failed for ${key}:`, err?.message||err);
      throw err;
    }
  }

  async function pickProviders(){
    try{
      const adapter = await navigator.gpu?.requestAdapter();
      if(adapter && ort.env.webgpu){ return ['webgpu','wasm']; }
    }catch{}
    return ['wasm'];
  }

  async function fetchAsBufferCORS(url){
    try{
      const res = await fetch(url, {cache:'no-store', mode:'cors', redirect:'follow'});
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.arrayBuffer();
    }catch(err){
      log('Fetch failed (CORS/HTTP):', url, err?.message||err);
      throw err;
    }
  }

  async function cacheUrlToKey(key, url, type){
    try{
      const buf = await fetchAsBufferCORS(url);
      await idbSet(key, buf);
      state.cachedBuffers[key] = new Uint8Array(buf);
      state.sessions[key] = null;
      log(`Cached ${type} model from URL to IDB (key: ${key}, ${Math.round(buf.byteLength/1024)} KB).`);
    }catch(err){
      log(`URL cache failed for ${key}:`, err?.message||err);
    }
  }

  // ---------------- AI Pipeline ----------------
  async function runAIPipeline(trigger){
    if(!state.image || !state.seed) return;
    startProgress();
    dom.aiThumbs.classList.remove('visible');

    // 1) Segmentation (or EdgeGrow) to get a base mask
    let baseMask = null;
    try{
      if(state.segKey==='edgegrow'){
        baseMask = edgeGrowMask(state.image, state.seed.x, state.seed.y);
      }else{
        const segSession = await ensureSession(state.segKey);
        baseMask = await runSegmentation(segSession, state.segKey, state.image, state.seed);
        if(!baseMask){
          log('Seg produced no mask; using EdgeGrow fallback.');
          baseMask = edgeGrowMask(state.image, state.seed.x, state.seed.y);
        }
      }
    }catch(err){
      log('Segmentation failed ‚Üí EdgeGrow fallback:', err?.message||err);
      baseMask = edgeGrowMask(state.image, state.seed.x, state.seed.y);
    }

    // 2) Depth (if requested)
    let depthCanvas = null, depthMap = null;
    if(state.depthKey!=='none' || state.refine || state.effect.includes('depth') || state.effect==='depth-band' || state.effect==='depth-thresh'){
      try{
        if(state.depthKey==='none'){
          // no explicit model; but some effects need depth ‚Üí we can‚Äôt synthesize it ‚Üí skip
          log('Depth not selected; depth-dependent effects will behave as no-depth.');
        }else{
          const depthSession = await ensureSession(state.depthKey);
          const dep = await runDepth(depthSession, state.depthKey, state.image);
          depthCanvas = dep.canvas;
          depthMap = dep.map;
        }
      }catch(err){
        log('Depth failed; continuing without depth:', err?.message||err);
      }
    }

    // 3) Store & thumbnails
    state.maskCanvas = baseMask;
    state.depthCanvas = depthCanvas || null;
    state.depthMap = depthMap || null;

    try{
      const mt = dom.maskThumb.getContext('2d');
      const tw = dom.maskThumb.width = 160, th = dom.maskThumb.height = Math.round(160 * (state.image.height/state.image.width));
      mt.imageSmoothingEnabled = false; mt.clearRect(0,0,tw,th);
      mt.drawImage(baseMask,0,0, tw, th);

      const dt = dom.depthThumb.getContext('2d');
      const tw2 = dom.depthThumb.width = 160, th2 = dom.depthThumb.height = Math.round(160 * (state.image.height/state.image.width));
      dt.imageSmoothingEnabled = false; dt.clearRect(0,0,tw2,th2);
      if(depthCanvas) dt.drawImage(depthCanvas,0,0, tw2,th2);
      dom.aiThumbs.classList.add('visible');
    }catch{}

    // 4) Render preview with EFFECT combination
    pv.layout(); pv.render();
    finishProgress();
    log('Preview rendered (effect:', state.effect, ').');
  }

  // ---------------- Segmentation (YOLO-like + Fallback) ----------------
  async function runSegmentation(session, key, img, seed){
    const info = state.models[key] || BUILTIN_MODELS[key] || {inputSize:640, flavor:'yolov8'};
    const size = info.inputSize || 640;
    const flavor = info.flavor;

    if(flavor==='yolov8' || flavor==='fastsam' || flavor==='custom'){
      const {tensor, scale, dx, dy} = makeLetterboxInput(img, size);
      const feeds = {};
      const inputName = session.inputNames?.[0] || 'images';
      feeds[inputName] = tensor;

      const outputs = await session.run(feeds);
      const outNames = Object.keys(outputs);
      if(outNames.length<2) throw new Error('Unexpected seg outputs');
      const det = outputs[outNames[0]];  // [1, num, ch]
      const proto = outputs[outNames[1]]; // [1, maskDim, mh, mw]

      const detData = det.data, detShape = det.dims;
      const protoData = proto.data, protoShape = proto.dims;
      const num = detShape[1], ch = detShape[2];
      const maskDim = protoShape[1], mw = protoShape[3], mh = protoShape[2];
      const clsCount = ch - 4 - 1 - maskDim; // xywh, obj, classes, mask-coeffs
      const stride = ch;

      const cand = [];
      for(let i=0;i<num;i++){
        const off = i*stride;
        const cx = detData[off+0], cy = detData[off+1], bw = detData[off+2], bh = detData[off+3];
        const conf = detData[off+4];
        if(conf<0.2) continue;
        let best=-1, bsc=-1;
        for(let c=0;c<clsCount;c++){
          const sc = detData[off+5+c];
          if(sc>bsc){ bsc=sc; best=c; }
        }
        const score = conf * (bsc>0?bsc:1);
        if(score<0.25) continue;
        const coeff = detData.slice(off+5+clsCount, off+5+clsCount+maskDim);
        const x1 = cx - bw/2, y1 = cy - bh/2, x2 = cx + bw/2, y2 = cy + bh/2;
        cand.push({x1,y1,x2,y2,score,coeff});
      }
      cand.sort((a,b)=> b.score - a.score);
      const keep = nms(cand, 0.5).slice(0,20);
      if(keep.length===0) return null;

      const mask = await decodeYOLOMaskChoose(keep, protoData, maskDim, mw, mh, size, scale, dx, dy, img.width, img.height, seed);
      return mask;
    }

    // Fallback
    return edgeGrowMask(img, seed.x, seed.y);
  }

  function makeLetterboxInput(img, size){
    const c = document.createElement('canvas'); c.width=size; c.height=size;
    const x = c.getContext('2d'); x.fillStyle='#000'; x.fillRect(0,0,size,size);
    const r = Math.min(size/img.width, size/img.height);
    const nw = Math.round(img.width*r), nh = Math.round(img.height*r);
    const dx = Math.floor((size-nw)/2), dy = Math.floor((size-nh)/2);
    x.drawImage(img, dx,dy,nw,nh);

    const id = x.getImageData(0,0,size,size).data;
    const arr = new Float32Array(size*size*3);
    for(let i=0,j=0;i<id.length;i+=4){
      arr[j++]=id[i]/255; arr[j++]=id[i+1]/255; arr[j++]=id[i+2]/255;
    }
    const t = new ort.Tensor('float32', arr, [1,size,size,3]); // NHWC
    return {tensor:t, scale:r, dx, dy};
  }

  function nms(cand, iouThr){
    const keep=[];
    for(const a of cand){
      let ok=true;
      for(const b of keep){
        const iou = IOU(a,b);
        if(iou>iouThr){ ok=false; break; }
      }
      if(ok) keep.push(a);
    }
    return keep;
  }
  function IOU(a,b){
    const xx1 = Math.max(a.x1,b.x1), yy1 = Math.max(a.y1,b.y1);
    const xx2 = Math.min(a.x2,b.x2), yy2 = Math.min(a.y2,b.y2);
    const w = Math.max(0, xx2-xx1), h = Math.max(0, yy2-yy1);
    const inter = w*h;
    const areaA = (a.x2-a.x1)*(a.y2-a.y1);
    const areaB = (b.x2-b.x1)*(b.y2-b.y1);
    return inter / Math.max(1e-6, areaA + areaB - inter);
  }

  async function decodeYOLOMaskChoose(keep, protoData, maskDim, mw, mh, inputSize, scale, dx, dy, outW, outH, seed){
    const P = new Float32Array(maskDim*mw*mh); P.set(protoData);
    let bestCanvas=null, bestScore=-1;

    for(const det of keep){
      const c = det.coeff;
      const flat = new Float32Array(mw*mh);
      for(let i=0;i<mw*mh;i++){
        let s=0;
        for(let k=0;k<maskDim;k++){ s += P[k*mw*mh + i] * c[k]; }
        flat[i] = 1/(1+Math.exp(-s));
      }
      const small = document.createElement('canvas');
      small.width=mw; small.height=mh;
      const sx = small.getContext('2d');
      const id = sx.createImageData(mw,mh);
      for(let i=0;i<mw*mh;i++){
        const a = Math.round(255*clamp(flat[i],0,1));
        const o = i*4;
        id.data[o]=255; id.data[o+1]=255; id.data[o+2]=255; id.data[o+3]=a;
      }
      sx.putImageData(id,0,0);

      const big = document.createElement('canvas');
      big.width=outW; big.height=outH;
      const bx = big.getContext('2d');
      bx.drawImage(small, 0,0, inputSize,inputSize, -dx, -dy, inputSize/scale, inputSize/scale);

      if(seed){
        const hit = maskHit(big, seed.x, seed.y);
        if(hit){ bestCanvas = big; break; }
        else{
          const cx = (det.x1+det.x2)/2, cy=(det.y1+det.y2)/2;
          const dist = Math.hypot(seed.x - (cx - dx)/scale, seed.y - (cy - dy)/scale);
          const sc = det.score / (1 + 0.002*dist);
          if(sc>bestScore){ bestScore=sc; bestCanvas=big; }
        }
      }else{
        if(det.score>bestScore){ bestScore=det.score; bestCanvas=big; }
      }
    }
    return bestCanvas;
  }

  function maskHit(maskCanvas, x, y){
    if(!maskCanvas) return false;
    if(x<0||y<0||x>=maskCanvas.width||y>=maskCanvas.height) return false;
    const ctx = maskCanvas.getContext('2d');
    const d = ctx.getImageData(Math.floor(x),Math.floor(y),1,1).data;
    return d[3] > 10;
  }

  // Fallback (Auto Wand / EdgeGrow lite)
  function edgeGrowMask(img, sx, sy){
    const w = img.width, h = img.height;
    const maxSide = 1024;
    const scale = Math.min(1, maxSide / Math.max(w,h));
    const sw = Math.max(1, Math.round(w*scale));
    const sh = Math.max(1, Math.round(h*scale));

    const sC = document.createElement('canvas'); sC.width = sw; sC.height = sh;
    const sX = sC.getContext('2d'); sX.imageSmoothingEnabled = true; sX.drawImage(img, 0,0, sw,sh);

    const sx2 = Math.round(clamp(sx*scale,0,sw-1));
    const sy2 = Math.round(clamp(sy*scale,0,sh-1));

    const src = sX.getImageData(0,0,sw,sh);
    const data = src.data;

    const idx = (x,y)=> (y*sw + x);
    const pIdx = (x,y)=> idx(x,y)*4;

    const r0 = data[pIdx(sx2,sy2)], g0 = data[pIdx(sx2,sy2)+1], b0 = data[pIdx(sx2,sy2)+2];
    const tol = 28; // conservative
    const mask = new Uint8Array(sw*sh);

    const st = [[sx2,sy2]];
    mask[idx(sx2,sy2)] = 1;
    while(st.length){
      const [x,y] = st.pop();
      for(const [nx,ny] of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
        if(nx<0||ny<0||nx>=sw||ny>=sh) continue;
        const id = idx(nx,ny);
        if(mask[id]) continue;
        const p = pIdx(nx,ny);
        const dr=data[p]-r0, dg=data[p+1]-g0, db=data[p+2]-b0;
        const dist = Math.sqrt(dr*dr+dg*dg+db*db);
        if(dist<=tol){ mask[id]=1; st.push([nx,ny]); }
      }
    }

    const mSmall = document.createElement('canvas'); mSmall.width=sw; mSmall.height=sh;
    const msx = mSmall.getContext('2d');
    const id2 = msx.createImageData(sw,sh);
    for(let i=0;i<sw*sh;i++){
      const a = mask[i]?255:0; const o = i*4;
      id2.data[o]=255; id2.data[o+1]=255; id2.data[o+2]=255; id2.data[o+3]=a;
    }
    msx.putImageData(id2,0,0);

    const mFull = document.createElement('canvas'); mFull.width=w; mFull.height=h;
    const fx = mFull.getContext('2d'); fx.imageSmoothingEnabled = false; fx.drawImage(mSmall, 0,0, sw,sh, 0,0, w,h);
    return mFull;
  }

  // ---------------- Depth ----------------
  async function runDepth(session, key, img){
    const info = state.models[key] || BUILTIN_MODELS[key] || {inputSize:256, flavor:'midas'};
    const size = info.inputSize || 256;
    const c = document.createElement('canvas'); c.width=size; c.height=size;
    const x = c.getContext('2d');
    const r = Math.min(size/img.width, size/img.height);
    const nw = Math.round(img.width*r), nh = Math.round(img.height*r);
    const dx = Math.floor((size-nw)/2), dy = Math.floor((size-nh)/2);
    x.fillStyle='#000'; x.fillRect(0,0,size,size); x.drawImage(img, dx,dy,nw,nh);
    const d = x.getImageData(0,0,size,size).data;
    const arr = new Float32Array(size*size*3);
    for(let i=0,j=0;i<d.length;i+=4){ arr[j++]=d[i]/255; arr[j++]=d[i+1]/255; arr[j++]=d[i+2]/255; }
    const inputName = session.inputNames?.[0] || 'input';
    const tensor = new ort.Tensor('float32', arr, [1,size,size,3]);
    const out = await session.run({[inputName]: tensor});
    const first = out[Object.keys(out)[0]];
    // Dims may be (1,1,H,W) or (1,H,W,1) or (1,H,W)
    const dims = first.dims;
    let H, W, raw = first.data;
    if(dims.length===4){ H = dims[2]; W = dims[3]; }
    else if(dims.length===3){ H = dims[1]; W = dims[2]; }
    else { throw new Error('Unexpected depth output shape'); }

    let mn=Infinity, mx=-Infinity;
    for(let i=0;i<raw.length;i++){ const v = raw[i]; if(v<mn) mn=v; if(v>mx) mx=v; }
    const range = mx-mn || 1;

    const small = document.createElement('canvas'); small.width=W; small.height=H;
    const sx = small.getContext('2d');
    const id = sx.createImageData(W,H);
    for(let i=0;i<W*H;i++){
      const v = (raw[i]-mn)/range; const g = Math.round(255*v);
      id.data[i*4]=g; id.data[i*4+1]=g; id.data[i*4+2]=g; id.data[i*4+3]=255;
    }
    sx.putImageData(id,0,0);

    const big = document.createElement('canvas'); big.width = img.width; big.height = img.height;
    const bx = big.getContext('2d');
    bx.imageSmoothingEnabled = true; bx.drawImage(small, 0,0, W,H, 0,0, img.width, img.height);

    const map = new Float32Array(img.width*img.height);
    const bd = bx.getImageData(0,0,img.width,img.height).data;
    for(let i=0,j=0;i<map.length;i++,j+=4) map[i] = bd[j]/255;

    return {canvas:big, map};
  }

  function makeDepthBandMask(depthMap, W,H, seed, band){
    if(!seed) return null;
    const sd = depthMap[seed.y*W + seed.x];
    const lo = Math.max(0, sd - band), hi = Math.min(1, sd + band);
    const c = document.createElement('canvas'); c.width=W; c.height=H;
    const cx = c.getContext('2d'); const id = cx.createImageData(W,H);
    for(let i=0;i<W*H;i++){
      const ok = (depthMap[i]>=lo && depthMap[i]<=hi) ? 255 : 0;
      const o=i*4; id.data[o]=255; id.data[o+1]=255; id.data[o+2]=255; id.data[o+3]=ok;
    }
    cx.putImageData(id,0,0);
    return c;
  }
  function makeDepthThresholdMask(depthMap, W,H, thr, nearIsForeground=true){
    const c = document.createElement('canvas'); c.width=W; c.height=H;
    const cx = c.getContext('2d'); const id = cx.createImageData(W,H);
    for(let i=0;i<W*H;i++){
      const v = depthMap[i]; const ok = (nearIsForeground ? (v<=thr) : (v>=thr)) ? 255 : 0;
      const o=i*4; id.data[o]=255; id.data[o+1]=255; id.data[o+2]=255; id.data[o+3]=ok;
    }
    cx.putImageData(id,0,0);
    return c;
  }

  // ---------------- Edges (Sobel + Laplacian) ----------------
  function makeEdgesMask(img, alpha=0.7, beta=0.3, thr=0.18){
    const W = img.width, H = img.height;
    const maxSide = 1024;
    const scale = Math.min(1, maxSide / Math.max(W,H));
    const sw = Math.max(1, Math.round(W*scale)), sh = Math.max(1, Math.round(H*scale));

    // downsample grayscale
    const sC = document.createElement('canvas'); sC.width=sw; sC.height=sh;
    const sx = sC.getContext('2d');
    sx.drawImage(img, 0,0, sw,sh);
    const src = sx.getImageData(0,0,sw,sh); const sd = src.data;
    const gray = new Float32Array(sw*sh);
    for(let i=0,j=0;i<gray.length;i++,j+=4){
      gray[i] = (0.2126*sd[j] + 0.7152*sd[j+1] + 0.0722*sd[j+2])/255;
    }

    // Sobel
    const sob = new Float32Array(sw*sh);
    const gxK = [-1,0,1, -2,0,2, -1,0,1];
    const gyK = [-1,-2,-1, 0,0,0, 1,2,1];
    for(let y=1;y<sh-1;y++){
      for(let x=1;x<sw-1;x++){
        let gx=0, gy=0, p=0;
        for(let ky=-1;ky<=1;ky++){
          for(let kx=-1;kx<=1;kx++){
            const v = gray[(y+ky)*sw + (x+kx)];
            const i = (++p)-1;
            gx += v * gxK[i]; gy += v * gyK[i];
          }
        }
        sob[y*sw+x] = Math.hypot(gx,gy)/4.0; // normalize a bit
      }
    }

    // Laplacian
    const lap = new Float32Array(sw*sh);
    const lK = [0,1,0, 1,-4,1, 0,1,0];
    for(let y=1;y<sh-1;y++){
      for(let x=1;x<sw-1;x++){
        let s=0, p=0;
        for(let ky=-1;ky<=1;ky++){
          for(let kx=-1;kx<=1;kx++){
            const v = gray[(y+ky)*sw + (x+kx)];
            const i=(++p)-1; s += v * lK[i];
          }
        }
        lap[y*sw+x] = Math.abs(s);
      }
    }

    // Combine
    let mn=Infinity, mx=-Infinity;
    for(let i=0;i<gray.length;i++){
      const v = alpha*sob[i] + beta*lap[i];
      if(v<mn) mn=v; if(v>mx) mx=v;
    }
    const rng = mx-mn || 1;

    // Threshold ‚Üí mask
    const smallMask = document.createElement('canvas'); smallMask.width=sw; smallMask.height=sh;
    const msx = smallMask.getContext('2d'); const id2 = msx.createImageData(sw,sh);
    for(let i=0;i<gray.length;i++){
      const v = (alpha*sob[i] + beta*lap[i] - mn)/rng;
      const a = v>=thr ? 255 : 0;
      const o=i*4; id2.data[o]=255; id2.data[o+1]=255; id2.data[o+2]=255; id2.data[o+3]=a;
    }
    msx.putImageData(id2,0,0);

    // Upscale
    const mFull = document.createElement('canvas'); mFull.width=W; mFull.height=H;
    const fx = mFull.getContext('2d'); fx.imageSmoothingEnabled = false;
    fx.drawImage(smallMask, 0,0, sw,sh, 0,0, W,H);
    return mFull;
  }

  // ---------------- IDB (model cache) ----------------
  let idbDb = null;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open('cspx-models', 1);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if(!db.objectStoreNames.contains('onnx')) db.createObjectStore('onnx');
      };
      req.onsuccess = ()=>{ idbDb = req.result; resolve(); };
      req.onerror = ()=> reject(req.error);
    });
  }
  async function idbSet(key, buffer){
    if(!idbDb) await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = idbDb.transaction('onnx','readwrite');
      tx.objectStore('onnx').put(buffer, key);
      tx.oncomplete = resolve;
      tx.onerror = ()=> reject(tx.error);
    });
  }
  async function idbGet(key){
    if(!idbDb) await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = idbDb.transaction('onnx','readonly');
      const req = tx.objectStore('onnx').get(key);
      req.onsuccess = ()=> resolve(req.result||null);
      req.onerror = ()=> reject(req.error);
    });
  }
  async function idbClear(){
    if(!idbDb) await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = idbDb.transaction('onnx','readwrite');
      const req = tx.objectStore('onnx').clear();
      req.onsuccess = ()=> resolve();
      req.onerror = ()=> reject(req.error);
    });
  }

  // ---------------- Logs UI ----------------
  dom.logFab.addEventListener('click', ()=> dom.logsPanel.classList.toggle('visible'));
  dom.clearBtn.addEventListener('click', ()=>{ dom.logsBody.innerHTML=''; });
  dom.clearCacheBtn.addEventListener('click', async ()=>{
    try{
      await idbClear();
      state.sessions = {}; state.cachedBuffers = {};
      log('Cleared cached ONNX models from IndexedDB.');
    }catch(err){ log('Failed clearing cache:', err?.message||err); }
  });
  dom.selfTestBtn.addEventListener('click', async ()=>{
    const keys = Object.keys(BUILTIN_MODELS).filter(k=>BUILTIN_MODELS[k].url);
    for(const k of keys){
      const url = BUILTIN_MODELS[k].url;
      try{
        const res = await fetch(url, {method:'HEAD', mode:'cors', redirect:'follow'});
        log(`[HEAD] ${k} ‚Üí ${res.status} ${res.ok?'OK':''} ${url}`);
      }catch(err){ log(`[HEAD] ${k} FAILED:`, err?.message||err); }
      await sleep(100);
    }
  });

  // ---------------- Use / Effect parameter changes ‚Üí re-render ----------------
  [dom.bandRange, dom.depthThrRange, dom.edgeThrRange, dom.featherPx].forEach(el=>{
    el.addEventListener('input', ()=>{ if(state.image) { pv.layout(); pv.render(); }});
  });

  // ---------------- INIT ----------------
  (async function init(){
    log(`App ready. Version ${APP_VERSION}`);
    const providers = await pickProviders();
    log('Runtime:', providers.includes('webgpu') ? 'WebGPU + WASM fallback' : 'WASM only');
    ed.updateSize(); ed.draw(); pv.layout(); pv.render();
  })();

})();
</script>
</body>
</html>
