<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Splash App</title>
    <style>
        /* --- Global Styles & Layout --- */
        :root {
            --bg-color: #f4f4f9;
            --main-text: #333;
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --secondary-hover: #5a6268;
            --danger-color: #dc3545;
            --light-gray: #e9ecef;
            --border-color: #ced4da;
            --glow-color-1: rgba(255, 0, 0, 0.9);
            --glow-color-2: rgba(0, 255, 0, 0.9);
            --glow-color-3: rgba(0, 0, 255, 0.9);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--main-text);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header, footer {
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 0.5rem 1rem;
            z-index: 10;
        }

        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            overflow: hidden;
        }

        /* --- Controls --- */
        .controls-area, .options-area {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--light-gray);
        }
        
        .control-group {
            display: flex;
            gap: 0.5rem;
            border-left: 1px solid var(--border-color);
            padding-left: 0.75rem;
        }

        button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            border-color: var(--secondary-hover);
        }

        button.primary {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        button.primary:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
        }
        
        button.active {
            background-color: var(--secondary-hover);
            color: white;
            border-color: var(--secondary-hover);
        }
        
        button:disabled {
            background-color: var(--light-gray);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .options-area label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* --- Main Canvas & Drop Zone --- */
        .canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            overflow: hidden;
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .drop-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 1.5rem;
            color: var(--secondary-color);
            z-index: 5;
        }
        
        .drop-zone.hidden {
            display: none;
        }

        .drop-zone.dragover {
            border-color: var(--primary-color);
            background-color: rgba(0, 123, 255, 0.05);
        }

        /* --- Preview Gallery --- */
        .preview-gallery {
            flex-shrink: 0;
        }
        .previews-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
            margin-top: 0.5rem;
        }
        .preview-item {
            text-align: center;
        }
        .preview-item canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
            background-color: var(--light-gray);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .preview-item code {
            font-size: 0.75rem;
            color: var(--secondary-color);
        }

        /* --- UI Feedback & Modals --- */
        .status-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .status-indicator.visible {
            opacity: 1;
        }
        
        .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal-dialog {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }
        .modal-dialog .button-group {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .hidden {
            display: none !important;
        }

        /* --- Developer Log --- */
        .dev-log {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #222;
            color: #eee;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8rem;
            padding: 0.5rem;
            border-top: 2px solid var(--primary-color);
            z-index: 200;
        }
        .dev-log p { margin: 0 0 0.25rem; }
        .dev-log .log-toggle {
            position: absolute;
            top: -30px;
            right: 20px;
            background: #222;
            color: #eee;
            border: none;
            border-radius: 4px 4px 0 0;
        }

    </style>
</head>
<body>

    <header>
        <h1>Color Splash App</h1>
    </header>

    <main>
        <section class="controls-area" aria-label="Main Controls">
            <div class="control-group">
                <button id="uploadBtn" class="primary">üì§ Upload Image</button>
                <button id="saveBtn" disabled>üíæ Save Work</button>
                <button id="loadBtn">üìÇ Load Work</button>
            </div>
            <div class="control-group">
                <button id="undoBtn" disabled>‚Ü©Ô∏è Undo</button>
                <button id="redoBtn" disabled>‚Ü™Ô∏è Redo</button>
                <button id="resetBtn" disabled>üóëÔ∏è Start Over</button>
            </div>
            <div class="control-group">
                <button id="modeLassoBtn" class="active">‚ú® Find Object</button>
                <button id="modeBoxBtn">üî≤ Draw Box</button>
            </div>
        </section>

        <section class="options-area" aria-label="Tool Options">
            <!-- Options will be dynamically inserted here -->
        </section>

        <div class="canvas-container">
            <div id="dropZone" class="drop-zone">
                <p>Drag & Drop an image here, or click 'Upload Image'</p>
            </div>
            <canvas id="mainCanvas"></canvas>
            <div id="statusIndicator" class="status-indicator">Ready</div>
        </div>

        <section class="preview-gallery" aria-label="Preview Gallery">
            <button id="renderBtn" disabled>üé® Render Previews</button>
            <div class="previews-container">
                <div class="preview-item">
                    <canvas id="preview1"></canvas>
                    <code id="values1"></code>
                </div>
                <div class="preview-item">
                    <canvas id="preview2"></canvas>
                    <code id="values2"></code>
                </div>
                <div class="preview-item">
                    <canvas id="preview3"></canvas>
                    <code id="values3"></code>
                </div>
                <div class="preview-item">
                    <canvas id="preview4"></canvas>
                    <code id="values4"></code>
                </div>
                <div class="preview-item">
                    <canvas id="preview5"></canvas>
                    <code id="values5"></code>
                </div>
            </div>
        </section>
    </main>

    <!-- Modals and Hidden Elements -->
    <div id="confirmModal" class="modal-overlay hidden">
        <div class="modal-dialog">
            <p>Are you sure you want to start over? All unsaved work will be lost.</p>
            <div class="button-group">
                <button id="confirmYesBtn" class="primary">Yes, Start Over</button>
                <button id="confirmNoBtn">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="devLog" class="dev-log hidden">
        <button class="log-toggle" id="logToggleBtn">Toggle Log</button>
        <p>Developer Log Initialized...</p>
    </div>
    <button class="log-toggle" id="logToggleBtnClosed" style="position:fixed; bottom:0; right:20px; z-index:199;">Show Log</button>

    <input type="file" id="fileInput" accept="image/*" class="hidden">
    <input type="file" id="loadInput" accept=".json, .txt" class="hidden">

    <script>
    // Senior Dev Implementation: Wrapped in an IIFE to encapsulate the logic.
    (function() {
        'use strict';

        // --- 1. DOM Element Cache ---
        const dom = {
            // Buttons
            uploadBtn: document.getElementById('uploadBtn'),
            saveBtn: document.getElementById('saveBtn'),
            loadBtn: document.getElementById('loadBtn'),
            undoBtn: document.getElementById('undoBtn'),
            redoBtn: document.getElementById('redoBtn'),
            resetBtn: document.getElementById('resetBtn'),
            modeLassoBtn: document.getElementById('modeLassoBtn'),
            modeBoxBtn: document.getElementById('modeBoxBtn'),
            renderBtn: document.getElementById('renderBtn'),
            confirmYesBtn: document.getElementById('confirmYesBtn'),
            confirmNoBtn: document.getElementById('confirmNoBtn'),
            logToggleBtn: document.getElementById('logToggleBtn'),
            logToggleBtnClosed: document.getElementById('logToggleBtnClosed'),
            // Areas
            optionsArea: document.querySelector('.options-area'),
            dropZone: document.getElementById('dropZone'),
            mainCanvas: document.getElementById('mainCanvas'),
            statusIndicator: document.getElementById('statusIndicator'),
            confirmModal: document.getElementById('confirmModal'),
            devLog: document.getElementById('devLog'),
            // Inputs
            fileInput: document.getElementById('fileInput'),
            loadInput: document.getElementById('loadInput'),
            // Previews
            previews: [
                { canvas: document.getElementById('preview1'), code: document.getElementById('values1') },
                { canvas: document.getElementById('preview2'), code: document.getElementById('values2') },
                { canvas: document.getElementById('preview3'), code: document.getElementById('values3') },
                { canvas: document.getElementById('preview4'), code: document.getElementById('values4') },
                { canvas: document.getElementById('preview5'), code: document.getElementById('values5') },
            ]
        };

        // --- 2. State Management ---
        let state = {
            originalImage: null,
            currentMode: 'lasso', // 'lasso' or 'box'
            selections: [],
            history: [],
            historyIndex: -1,
            isDirty: false, // Has changes since last render
            isRendering: false,
        };
        
        const SELECTION_COLORS = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
        let inactivityTimer = null;

        // --- 3. Core Modules ---

        /**
         * Logger: Handles logging to console and the on-screen dev log.
         */
        const logger = {
            log(message) {
                console.log(message);
                const p = document.createElement('p');
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                dom.devLog.appendChild(p);
                dom.devLog.scrollTop = dom.devLog.scrollHeight;
            }
        };

        /**
         * UI Manager: Handles all DOM updates and UI feedback.
         */
        const uiManager = {
            init() {
                logger.log('UI Manager Initialized');
                this.updateModeUI();
                this.updateButtonStates();
            },
            
            updateModeUI() {
                dom.modeLassoBtn.classList.toggle('active', state.currentMode === 'lasso');
                dom.modeBoxBtn.classList.toggle('active', state.currentMode === 'box');
                
                dom.optionsArea.innerHTML = ''; // Clear previous options
                if (state.currentMode === 'lasso') {
                    dom.optionsArea.innerHTML = `
                        <label for="aggressiveness">Aggressiveness: </label>
                        <input type="range" id="aggressiveness" min="1" max="100" value="20">
                        <button id="addSelectionBtn" disabled>‚ú® Add another object</button>
                    `;
                } else {
                    dom.optionsArea.innerHTML = `
                        <label><input type="checkbox" id="multiBoxCheck"> Add another box</label>
                    `;
                }
                // Re-attach listeners for new elements if needed
            },
            
            updateButtonStates() {
                const hasImage = !!state.originalImage;
                const canUndo = state.historyIndex > 0;
                const canRedo = state.historyIndex < state.history.length - 1;

                dom.saveBtn.disabled = !hasImage;
                dom.resetBtn.disabled = !hasImage;
                dom.renderBtn.disabled = !hasImage || state.isRendering;
                dom.undoBtn.disabled = !canUndo;
                dom.redoBtn.disabled = !canRedo;
                
                const addSelectionBtn = document.getElementById('addSelectionBtn');
                if (addSelectionBtn) addSelectionBtn.disabled = !hasImage;
            },
            
            showStatus(message, duration = 2000) {
                logger.log(`Status: ${message}`);
                dom.statusIndicator.textContent = message;
                dom.statusIndicator.classList.add('visible');
                setTimeout(() => dom.statusIndicator.classList.remove('visible'), duration);
            },

            toggleModal(show) {
                dom.confirmModal.classList.toggle('hidden', !show);
            },

            toggleLog(show) {
                dom.devLog.classList.toggle('hidden', !show);
                dom.logToggleBtnClosed.classList.toggle('hidden', show);
            }
        };

        /**
         * State Manager: Handles history for Undo/Redo and auto-saving.
         */
        const stateManager = {
            saveState() {
                // Clear redo history
                if (state.historyIndex < state.history.length - 1) {
                    state.history = state.history.slice(0, state.historyIndex + 1);
                }
                
                const snapshot = JSON.parse(JSON.stringify({ selections: state.selections }));
                state.history.push(snapshot);
                state.historyIndex++;
                
                logger.log(`State saved. History length: ${state.history.length}`);
                uiManager.updateButtonStates();
                this.autoSaveToLocalStorage();
            },

            undo() {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    this.loadStateFromHistory();
                    logger.log(`Undo performed. Index: ${state.historyIndex}`);
                }
            },

            redo() {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    this.loadStateFromHistory();
                    logger.log(`Redo performed. Index: ${state.historyIndex}`);
                }
            },
            
            loadStateFromHistory() {
                const snapshot = state.history[state.historyIndex];
                state.selections = JSON.parse(JSON.stringify(snapshot.selections));
                canvasRenderer.render();
                uiManager.updateButtonStates();
                this.autoSaveToLocalStorage();
            },

            reset() {
                state.selections = [];
                state.history = [];
                state.historyIndex = -1;
                this.saveState(); // Save the initial empty state
                canvasRenderer.render();
            },
            
            autoSaveToLocalStorage() {
                if (!state.originalImage) return;
                try {
                    const dataToSave = {
                        selections: state.selections,
                        imageDataUrl: state.originalImage.src
                    };
                    localStorage.setItem('colorSplashAutoSave', JSON.stringify(dataToSave));
                    logger.log('Work auto-saved to browser.');
                } catch (e) {
                    logger.log('Error auto-saving: ' + e.message);
                    uiManager.showStatus('Could not auto-save. Browser storage might be full.');
                }
            },

            loadFromLocalStorage() {
                const savedData = localStorage.getItem('colorSplashAutoSave');
                if (savedData) {
                    logger.log('Found auto-saved work.');
                    if (confirm('It looks like you have unsaved work. Do you want to load it?')) {
                        const parsedData = JSON.parse(savedData);
                        const img = new Image();
                        img.onload = () => {
                            fileHandler.processNewImage(img);
                            state.selections = parsedData.selections;
                            stateManager.saveState(); // Add to history
                            canvasRenderer.render();
                            uiManager.showStatus('Auto-saved work loaded.');
                        };
                        img.src = parsedData.imageDataUrl;
                    }
                }
            }
        };

        /**
         * Canvas Renderer: Handles all drawing operations.
         */
        const canvasRenderer = {
            ctx: dom.mainCanvas.getContext('2d'),
            offscreenCanvas: document.createElement('canvas'),
            offscreenCtx: null,

            init() {
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            },

            render() {
                if (!state.originalImage) return;
                logger.log('Starting main render...');

                const canvas = dom.mainCanvas;
                const img = state.originalImage;
                
                // Fit image to canvas while maintaining aspect ratio
                const hRatio = canvas.width / img.width;
                const vRatio = canvas.height / img.height;
                const ratio = Math.min(hRatio, vRatio);
                const centerShift_x = (canvas.width - img.width * ratio) / 2;
                const centerShift_y = (canvas.height - img.height * ratio) / 2;

                this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.ctx.drawImage(img, 0, 0, img.width, img.height, centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                
                // Get image data from the scaled drawing
                const imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Create grayscale version
                for (let i = 0; i < data.length; i += 4) {
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = avg;
                    data[i + 1] = avg;
                    data[i + 2] = avg;
                }
                
                // Put grayscale back, then "cut holes" for selections
                this.ctx.putImageData(imageData, 0, 0);

                this.ctx.save();
                this.ctx.globalCompositeOperation = 'destination-in';
                
                // Draw selections to create mask
                state.selections.forEach(sel => {
                    // TODO: Implement drawing selections
                });

                this.ctx.restore();

                logger.log('Main render complete.');
                
                // Trigger preview render after a delay
                state.isDirty = true;
                clearTimeout(inactivityTimer);
                inactivityTimer = setTimeout(() => {
                    if (state.isDirty) this.renderPreviews();
                }, 10000);
            },

            renderPreviews() {
                if (!state.originalImage || state.isRendering) return;
                
                logger.log('Starting preview render...');
                state.isRendering = true;
                uiManager.updateButtonStates();
                dom.renderBtn.innerHTML = '<span class="spinner"></span> Rendering...';

                // Simulate async rendering
                setTimeout(() => {
                    // TODO: Implement the 5 preview renders with different effects
                    uiManager.showStatus('Previews updated!');
                    logger.log('Preview render complete.');
                    state.isRendering = false;
                    state.isDirty = false;
                    dom.renderBtn.innerHTML = 'üé® Render Previews';
                    uiManager.updateButtonStates();
                }, 500);
            }
        };

        /**
         * File Handler: Manages image/JSON loading and saving.
         */
        const fileHandler = {
            init() {
                dom.uploadBtn.addEventListener('click', () => dom.fileInput.click());
                dom.fileInput.addEventListener('change', this.handleFileSelect);
                
                dom.loadBtn.addEventListener('click', () => dom.loadInput.click());
                dom.loadInput.addEventListener('change', this.handleLoadJson);

                dom.saveBtn.addEventListener('click', this.handleSaveJson);

                // Drag and Drop
                dom.dropZone.addEventListener('dragover', this.handleDragOver);
                dom.dropZone.addEventListener('dragleave', this.handleDragLeave);
                dom.dropZone.addEventListener('drop', this.handleDrop);
            },

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => fileHandler.processNewImage(img);
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            },

            processNewImage(img) {
                logger.log(`Image loaded: ${img.width}x${img.height}`);
                state.originalImage = img;
                dom.dropZone.classList.add('hidden');
                
                // Resize canvas to match image aspect ratio for better drawing
                const aspectRatio = img.width / img.height;
                const container = dom.mainCanvas.parentElement;
                dom.mainCanvas.width = container.clientWidth;
                dom.mainCanvas.height = container.clientWidth / aspectRatio;

                stateManager.reset();
                canvasRenderer.render();
                uiManager.showStatus('Image loaded successfully!');
            },

            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                dom.dropZone.classList.add('dragover');
            },
            
            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                dom.dropZone.classList.remove('dragover');
            },

            handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                dom.dropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => fileHandler.processNewImage(img);
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            },

            handleSaveJson() {
                const dataStr = JSON.stringify({ selections: state.selections }, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'colorsplash-work.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                logger.log('Work saved to JSON file.');
            },

            handleLoadJson(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            if (data.selections && Array.isArray(data.selections)) {
                                state.selections = data.selections;
                                stateManager.saveState();
                                canvasRenderer.render();
                                uiManager.showStatus('Work loaded successfully!');
                            } else {
                                throw new Error('Invalid JSON format.');
                            }
                        } catch (err) {
                            logger.log('Error loading JSON: ' + err.message);
                            uiManager.showStatus('Failed to load file. Invalid format.');
                        }
                    };
                    reader.readAsText(file);
                }
            }
        };

        // --- 4. Event Listeners Setup ---
        function initializeEventListeners() {
            // Mode switching
            dom.modeLassoBtn.addEventListener('click', () => {
                state.currentMode = 'lasso';
                uiManager.updateModeUI();
            });
            dom.modeBoxBtn.addEventListener('click', () => {
                state.currentMode = 'box';
                uiManager.updateModeUI();
            });

            // History
            dom.undoBtn.addEventListener('click', () => stateManager.undo());
            dom.redoBtn.addEventListener('click', () => stateManager.redo());

            // Reset
            dom.resetBtn.addEventListener('click', () => uiManager.toggleModal(true));
            dom.confirmYesBtn.addEventListener('click', () => {
                fileHandler.processNewImage(state.originalImage); // Reloads image and resets state
                uiManager.toggleModal(false);
            });
            dom.confirmNoBtn.addEventListener('click', () => uiManager.toggleModal(false));
            
            // Previews
            dom.renderBtn.addEventListener('click', () => canvasRenderer.renderPreviews());

            // Dev Log
            dom.logToggleBtn.addEventListener('click', () => uiManager.toggleLog(false));
            dom.logToggleBtnClosed.addEventListener('click', () => uiManager.toggleLog(true));
        }

        // --- 5. Application Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            logger.log('Application Initializing...');
            uiManager.init();
            canvasRenderer.init();
            fileHandler.init();
            initializeEventListeners();
            stateManager.loadFromLocalStorage();
            stateManager.saveState(); // Save initial empty state
            logger.log('Application Ready.');
        });

    })();
    </script>
</body>
</html>
